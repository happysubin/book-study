# chapter 8. 경계 간 매핑하기

매핑을 찬성하는 이유
* 두 계층 간에 매핑을 하지 않으면 양 계층에서 같은 모델을 사용해야 하는데 이렇게 하면 두 계층이 강하게 결합된다.

매핑에 반대하는 개발자
* 두 계층 간에 매핑을 하게 되면 보일러플레이트 코드를 너무 많이 만든다.
* 많은 유스케이스들이 오직 CRUD만 수행하고 계층에 같은 모델을 사용하기 때문에 계층 사이의 매핑은 과합니다.

DTO 재활용에 대한 문제로 보인다.

## 매핑하지 않기 전략

* 포트 인터페이스가 도메인 모델을 입출력 모델로 사용하면 두 계층 간의 매핑을 할 필요가 없다.
* 즉 웹 계층과 애플리케이션 계층 모두 도메인 클래스에 접근해야 한다는 것이다. 영속성 계층과 애플리케이션 계층도 마찬가지다.
* 그러면 도메인과 애플리케이션 계층은 웹이나 영속성과 관련된 특수한 요구사항에 관심이 없음에도 불구하고 Account 도메인 모델 클래스는 이런 모든 요구사항을 다뤄야한다.
* 그럼 도메인 클래스가 웹, 애플리케이션, 영속성 계층과 관련된 이유로 인해 변경돼야 하기 때문에 단일 책임 원칙을 위반한다.
* 기술적인 요구사항이 아니더라도, 각 곛 ㅡㅇ이 도메인 클래스에 특정 커스텀 필드를 두도록 요구할 수 있다. 그러면 한 계층을 위해 필요한 필드들을 포함하는 파편화된 도메인 모델로 이루어진다.

__모든 계층이 정확히 같지 않은 구조의, 정확히 같은 정보를 필요로 한다면 '매핑하지 않기'가 완벽한 선택지다.__

* 대신 이런 경우는 매우 드물다. 또한 애플리케이션 계층이나 도메인 계층에서 웹과 영속성 문제르 ㄹ다루게 되면 곧바로 다른 전략을 취해야 한다.
* 작가님의 경험에 따르면 보통 많은 유스케이스가 단순 CRUD로 시작했다가 시간이 지남에 따라 매핑 전략이 필요한, 풍부한 행동과 유효성 검증을 가진 제대로 된 비즈니스 유스케이스로 바뀐다고 한다.

## 양방향 매핑 전략

* 각 계층이 전용 모델을 가진 매핑 전략을 양방향 매핑 전략이라고 한다.
* 각 게층은 도메인 모델과는 완전히 다른 구조의 전용 모델을 가지고 있다.
* 각 계층이 전용 모델을 가지고 있는 덕분에 각 계층이 전용 모델을 변경하더라도 다른 계층에는 영향이 없다.
* 이 매핑 전략은 웹이나 영속성 관심사로 오염되지 않은 깨끗한 도메인 모델로 이어진다.

양방향 매핑의 또 다른 장점은 개념적으로는 매핑하지 않기 전략 다음으로 간단한 전략이라는 것이다. 매핑 책임이 명확하다. 즉 바깥쪽 계층/어댑터는 안쪽 계층의 모델로 매핑하고, 다시 반대 방향으로 매핑한다. 안쪽 계층은 해당 계층의 모델만 알면 되고 매핑 대신 도메인 로직에 집중할 수 있다.

* 단점은 너무 많은 보일러플레이트 코드가 생긴다.
* 또한 도메인 모델이 계층 경계를 넘어서 통신하는 데 사용되고 있다는 점이다.
* 양방향 매핑 전략도 은총알이 아니다. 즉 완벽한 해결책이 아니라는 것이다.

## 완전 매핑 전략

* 이 매핑 전략에서는 각 연사마다 별도의 입출력 모델을 사용한다.
* 계층 경계를 넘어 통신할 때 도메인 모델을 사용하는 대신 SendMoneyUseCase 포트의 입력 모델로 동작하는 SendMoneyCommand처럼 각 작업에 특화된 모델을 사용한다.
* 이런 모델을 가리켜 커맨드(command), 요청(request) 혹은 이와 비슷한 단어로 표현한다.
* 한 계층을 다른 여러 개의 커멘드로 매핑하는 데는 하나의 웹 모델과 도메인 모델 간의 매핑보다 더 많은 코드가 필요하다.
* 하지만 이렇게 매핑하면 여러 유스케이스의 요구사항을 함께 다뤄야하는 매핑에 비해 구현하고 유지보수하기가 훨씬 쉽다.
* 작가님은 이 매핑 전략을 전역 패턴으로 추천하지는 않는다고 한다.
* 이 전략은 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다고 한다.
* 애플리케이션 계층과 영속성 계층 사이엥서는 매핑 오버헤드 때문에 사용하지 않는 것이 좋다.

매핑 전략은 여러 가지를 섞어쓸 수 있고, 섞어 써야만 한다. 어떤 매핑 전략도 모든 계층에 걸쳐 전역 규칙일 필요는 없다.

## 단방향 매핑 전략

* 이 전략에서는 모든 계층의 모델들이 같은 인터페이스를 구현한다.
* 동일한 상태 인터페이스를 구현하는 도메인 모델과 어댑터 모델을 이용하면 각 계층은 다른 계층으로부터 온 객체를 단방향으로만 매핑하기만 하면 된다.
* 인터페이스는 관련 있는 특성에 대한 게터 메서드를 제공해서 도메인 모델의 상태를 캡슐화한다.
* 도메인 모델 자체는 풍부한 행동을 구현할 수 있고, 애플리케이션 계층 내의 서비스에서 이러한 행동에 접근할 수 있다.
* 도메인 객체를 바깥 계층으로 전달하고 싶으면 매핑 없이 할 수 있다.
* 왜냐면 도메인 객체가 인커밍/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 때문이다.
* 그러고 나면 바깥 계층에서는 상태 인터페이스를 이용할지, 전용 모델로 매핑해야 할지 결정할 수 있다.
* 행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다.
* 바깥 계층에서 애플리케이션 계층으로 전달하는 객체들도 이 상태 인터페이스를 구현하고 있다.
* 애플리케이션 계층에서는 이 객체를 실제 도메인 모델로 매핑해서 도메인 모델의 행동에 접근할 수 있게 된다.
* 이 매핑은 팩터리라는 DDD 개념과 어울린다. DDD용어인 팩터리는 어떤 특정한 상태로부터 도메인 객체를 재구성할 책임을 가지고 있다.
* 이 전략에서 매핑 책임은 명확하다.
* 만약 한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 이용할 수 있도록 다른 무언가로 매핑하는 것이다.
* 그러므로 각 계층은 한 방향으로만 매핑한다. 그래서 이 전략의 이름이 단방향 매핑 전략인 것이다.
* 하지만 매핑이 계층을 넘나들며 퍼져 있기 때문에 이 전략은 다른 전략에 비해 개념적으로 어렵다.
* 이 전략은 계층 간의 모델이 비슷할 때 효과적이다.

### 어떤 매핑전략을 고를지는 그때그때 다르다. 상황마다 적절한 매핑 전략을 정해야 한다.