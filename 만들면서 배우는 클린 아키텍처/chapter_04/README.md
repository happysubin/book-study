#chapter 4. 유스케이스 구현하기

## 유스케이스 둘러보기

일반적으로 유스케이스는 다음과 같은 단계를 따른다.

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

* 유스케이스는 인커밍 어댑터로부터 입력을 받는다.
* 유스케이스 코드가 도메인 로직에만 집중해야하며, 입력 유효성 검증으로 오염되면 안된다.
* 유스케이스는 비즈니스 규칙을 검증할 책임이 있다. 따라서 도메인 엔티티와 이 책임을 공유한다.
* 비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다.
* 일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다.
* 유스케이스는 또 다른 아웃고잉 어댑터를 호출할 수도 있다.
* 마지막 단계는 아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환하는 것이다.

송금하기 유스케이스를 구현하는 예제를 진행했다.

## 입력 유효성 검증

* 입력 유효성 검증은 애플리케이션의 책임이라고 한다.
* 애플리케이션 계층에서 입력 유효성을 검증해야 하는 이유는, 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력 값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.
* 유스케이스 클래스가 아니라면 어디서 입력 유효성을 검증해야 할까? 바로 입력 모델이다.
* 예제에서는 bean validation을 사용해 생성자에서 검증을 함.
* SelfValidation 추상 클래스를 제공.
* 입력 모델에 임ㅆ는 유효성 검증 코드를 통해 유스케이스 구현체 주위에 사실상 오류 방지 계층을 만들었다. 일종의 보호막 개념.

## 생성자의 힘

* 빌더는 호출하는 코드에 새로운 필드를 추가하는 것을 잊어버림.
* 컴파일러는 유효하지 않은 상태의 불변 객체를 만드려는 시도에 대해서는 경고해주지 못한다.
* 물론 런타임, 테스트 코드에서 유효성 검증 로직이 동작해서 누락된 파라미터에 대해 예외를 던질 수 있다.
* 말하고자하는 바는 생성자를 사용하면 절대로 파라미터를 누락할 일이 없다. 또한 요즘 IDE는 훌륭해서 생성자 파라미터명도 보여준다.
* 즉 안전한 생성자를 사용하자고 말하고 있다.

## 유스케이스 입력마다 다른 모델

* 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다.
* 비용도 발생하는데, 들어오는 데이터를 각 유스케이스에 해당하는 입력 모델에 매핑해야 하기 때문이다.
* 이해하기론 유스케이스마다 결국 DTO를 하나하나 만들어라 라는 말과 유사하다고 생각한다.

## 비즈니스 규칙 검증하기

* 비즈니스 규칙 검증에서 가장 좋은 방법은 비즈니스 규칙을 도메인 엔티티에 넣는 것이다.
* 이렇게 하면 이 규칙을 지켜야 하는 비즈니스 로직 바로 옆에 규칙이 위치하기 때문에 위치를 정하는 것도 쉽고 추가하기도 쉽다.
* 만약 도메인 엔티티에서 비즈니스 규칙을 검증하기가 여의치 않다면, 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.
* 유효성을 검증하는 코드를 호출하고, 유효성 검증이 실패할 경우 유효성 검증 전용 예외를 던진다.
* 사용자와 통신하는 어댑터는 이 예외를 에러 메시지로 사용자에게 보여주거나 적절한 다른 방법으로 처리한다.
* 복잡한 비즈니스 규칙의 경우에는 데이터베이스에서 도메인 모델을 로드해서 상태를 검증해야 할 수도 있다.
* 어쨋든 도메인 모델을 로드해야 한다면 도메인ㄴ 엔티티 내에 비즈니스 규칙을 구현해야 한다.

## 풍부한 도메인 모델 vs 빈약한 도메인 모델

* 풍부한 도메인 모델에서는 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다.
* 엔티티들은 상태를 변경하는 이 메서드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용한다.
* 유스케이스는 도메인 모델의 진입점으로 동작한다.
* 이어서 유스케이스는 사용자의 의도만을 표현하면서 이 의도를 실제 작업을 수행하는 체계화된 도메인 엔티티 메서드 호출로 변환한다.
* 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.
* 빈약한 도메인 모델은 게터와 세터만 가지고 어떤 도메인 로직도 가지고 있지 않다.
* 즉 도메인 로직이 유스케이스 클래스에 구현돼 있다는 것이다.
* 비즈니스 규칙을 검증하고, 엔티티의 상태를 바꾸고, 데이터베이스 저장을 담당하는 아웃고잉 포트에 엔티티를 전달할 책임 역시 유스케이스 클래스에 있다.
* 풍분한 도메인 모델이 아닌 풍부한 유스케이스가 된다.
* 적절히 상황에 맞는 것을 선택하면 된다.

## 유스케이스마다 다른 출력 모델

* 입력과 마찬가지로 출력도 각 유스케이스에 맞게 구체적일수록 좋다.
* 역시 DTO를 하나하나 만들어라라는 말과 동일하다고 생각한다.

## 읽기 전용 유스케이스는 어떨까?

* 애플리케이션 코어의 관점에서 이 작업은 간단한 데이터 쿼리다.
* 그러힉 때문에 프로젝트 맥락에서 유스케이스로 간주되지 않는다면 실제 유스케이스와 구분하기 위해 쿼리로 구현할 수 있다.
* 한 가지 방법은 쿼리를 위한 인커밍 전용 포트를 만들고 이를 쿼리 서비스에 구현하는 것이다.
* 쿼리 서비스는 유스케이스 서비스와 동일한 방식으로 동작한다.
* 인커밍 포트를 구현하고, 데이터베이스로부터 실제로 데이터를 로드하기 위해 아웃고잉 포트를 호출한다.
* 이처럼 읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 코드 상에서 명확하게 구분한다.
* CQS, CQRS 같은 개념과 잘 어울린다.

## 정리

* 꼼꼼한 입력 유효성 검증, 유스케이스별 입출력 모델은 지속 가능한 코드를 만드는 데 큰 도움이 된다.