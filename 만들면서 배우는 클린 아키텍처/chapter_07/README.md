# chapter 7. 아키텍처 요소 테스트하기

육각형 아키텍처에서의 테스트 전략에 대해 논의.

## 테스트 피라미드

* 테스트 피라미드에 따르면 비용이 많이 드는 테스트는 지양하고 비용이 적게 드는 테스트를 많이 만들어야 한다.
* 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다.
* 위에서 말한 테스트는 단위(일반적으로 하나의 클래스)가 제대로 동작하는지 확인할 수 있는 단위 테스트다.
* 여러 개의 단위와 단위를 넘는 경계, 아키텍처 경계, 시스템 경계를 결합하는 테스트는 만드는 비용이 더 비싸지고, 실행이 느려지며, 깨지기 더 쉬워진다.
* 테스트 피라미드는 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 한다는 것을 보여준다.
* 그렇지 않으면 새로운 기능 개발보다 테스트를 만드는데 시간을 더 쏟게 된다.
* 테스트 피라미드에서는 단위 테스트 -> 통합 테스트 -> 시스템 테스트 순이다.
* 단위 테스트는 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트한다.
* 만약 테스트하는 클래스가 다른 클래스에 의존한다면 목으로 대체한다.
* 통합 테스트는 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증한다.
* 두 계층 간의 경계를 걸쳐서 테스트할 수 있으므로 객체 네트워크가 완전하지 않거나 어떤 시점에는 mock을 대상으로 수행해야한다.
* 시스템 테스트는 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다.
* 백엔드 아키텍처를 얘기 중이므로 엔드 투 엔드 테스트는 제외.

## 단위 테스트로 도메인 엔티티 테스트하기

* 단위테스트가 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법이다.
* 도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 필요하지 않다.

## 단위 테스트로 유스케이스 테스트하기

* BDD 행동-주도 개발을 도입.
* given 섹션에서는 출금 및 입금 계좌 도메인의 인스턴스를 각각 생성하고 적절한 상태로 만들어서 given()으로 시작하는 메서드에 인자로 넣었다.
* when 섹션에서는 유스케이스를 실행하기 위해 sendMoney() 메서드를 호출.
* then 섹션에서는 트랜잭션이 성공적이었는지 확인, 출금 및 입금 Account, 계쫘에 락을 걸고 해제하는 책임을 가진 AccountLock에 대해 특정 메서드가 호출됐는지 검증한다.
* Mockito를 사용해 목 객체를 생성.
* Mockito 목 객체에 대해 특정 메서드가 호출됐는지 검증할 수 있는 then 메서드도 제공한다.
* 테스트에서는 어떤 상호 작용을 검증하고 싶은지 신중하게 생각해야 한다.
* 모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다.
* 만약 모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 한다. 이는 테스트의 가치를 떨어뜨린다.
* 역시 테스트도 SRP 한번에 1개만 검사하는 것이 좋은 것 같다.

## 통합 테스트로 웹 어댑터 테스트하기

* isOk 메서드로 응답의 상태가 200임을 보장.
* MockMvc 객체를 이용해 모킹했으므로 실제로 HTTP 프로토콜을 통해 테스트한 것은 아님.
* 입력을 JSON에서 SendMoneyCommand 객체로 매핑하는 전 과정은 다룬다.
* 웹 컨트롤러가 스프링 프레임워크와 강하게 묶여 있기 때문에 격리된 상태로 테스트하기보다는 이 프레임워크와 통합된 상태로 테스트하는 것이 합리적이다.

## 통합 테스트로 영속성 어댑터 테스트하기

* 비슷한 이유로 영속성 어댑터의 테스트에는 단위 테스트보다는 통합 테스트를 적용하는 것이 합리적이다.
* 어댑터의 로직 뿐만 아니라 데이터베이스 매핑도 검증하고 싶기 때문이다.
* @DataJpaTest 애너테이션으로 스프링 데이터 리포지토리를 포함해서 데이터베이스 접근에 필요한 객체 네트워크를 인스턴스화해야한다고 스프링에 알려준다.
* Import 애노테이션을 추가해서 특정 객체가 이 네트워크에 추가됐다는 것을 명확하게 표현.
* 데이터베이스를 모킹하지 않았다는 사실이 중요하다.
* 참고로 스프링은 기본적으로 인메모리 데이터베이스를 테스트에서 사용한다. 아무것도 설정할 필요 없이 곧바로 테스트할 수 있다. 아주 실용적.
* 그러나 배포 환경에서는 인메모리 데이터베이스를 사용하지 않는 경우가 많다. sql 고유 문법의 문제가 있을 수 있기 때문이다.
* 이러한 이유로 영속성 어댑터 테스트는 실제 데이터베이스를 대상으로 진행해야 한다.
* TestContatiner 같은 라이브러리는 필요한 데이터베이스를 도커 컨테이너에 띄울 수 있다. 이게 국룰인 것 같다.

## 시스템 테스트로 주요 경로 테스트하기

* @SpringBootTest 애노테이션을 사용해 시스템 테스트 진행
* MockMvc를 통해 보내지 않고 TestRestTemplate을 이용해서 요청을 보낸다. 테스트를 프로덕션 환경에 조금 더 가깝게 만들기 위해 실제 HTTP 통신을 진행.
* 실제 통신처럼 실제 출력 어댑터도 사용.
* 테스트 가독성을 위해 지저분한 로직들을 헬퍼 메서드 안으로 감춤.
* 이런 여러가지 헬퍼 메서드들은 여러 가지 상태를 검증할 때 사용할 수 있는 도메인 특화 언어를 형성. DSL
* 이런 도메인 특화 언어는 시스템 테스트에서 더욱 의미있다. 
* 시스템 테스트는 더욱 사용자 관점에서 애플리케이션을 검증 가능. 적절한 어휘를 사용하면 더 쉬워진다.
* 어휘를 사용하면 애플리케이션 사용자를 상징하지만 프로그래머는 아닌 도메인 전문가가 테스트에 대해 생각하고 피드백을 줄 수 있다.
* 시스템 테스트는 여러 개의 유스케이스를 결합해서 시나리오를 만들 때 빛이 난다.
* 각 시나리오는 사용자가 애플리케이션을 사용하면서 거쳐갈 특정 경로를 의미한다.
* 시스템 테스트를 통해 중요한 시나리오들이 커버된다면 최신 변경사항들이 애플리케이션을 망가뜨리지 않았음을 가정할 수 있고, 배포될 준비가 됐다는 확실을 가질 수 있다.

## 얼마만큼의 테스트가 충분할까?

* 라인 커버리지는 테스트 성공을 측정하는 데 있어서는 잘못된 지표다.
* 코드의 중요한 부분이 커버되지 않을 수 있기 때문에 100%를 제외한 어떤 목표도 무의미하다.
* 100%도 버그가 안잡힐 수 있다.
* 얼마나 마음 편하게 소프트웨어르 배포할 수 있느냐가 테스트의 성공 기준이다.
* 테스트를 실행한 후에 소프트웨어를 배포해도 될 만큼 테스트를 신뢰한다면 그것으로 충분하다.
* 자주 배포할수록 테스트를 더 신뢰할 수 있다.
* 처음 몇 번의 배포는 믿음이 필요하다. 그렇지만 프로덕션의 버그를 수정하고 이로부터 배우는 것을 우선순위로 삼는다면 올바른 방향이다.
* 각가의 프로덕션 버그에 대해서 "테스트가 이 버그를 왜 잡지 못했을까"에 대해 생각하고 이에 대한 답변을 기록하고, 이 케이스를 커버할 수 있는 테스트를 추가해야 한다.
* 시간이 지나면 이 작업들이 배포할때마다 마음을 편하게 해주고, 남겨둔 기록은 시간이 지날수록 상황이 개선되고 있음을 증명해준다.

다음은 육각형 아키텍처에서 사용하는 테스트 전략이다.

1. 도메인 엔티티를 구현할 때는 단위테스트로 커버하자.
2. 유스케이스를 구현할 때는 단위테스트로 커버하자.
3. 어댑터를 구현할 때는 통합 테스트로 커버하자.
4. 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버하자.

__구현할때 라는게 중요하다. 구현하고 나서 추가하면 테스트는 미룬 일처럼 느껴진다. 그러나 구현할 때 작성하면 개발 도구로 느껴진다.__

* 새로운 필드를 추가할때마다 테스트를 고치는데 한 시간을 쓰면 뭔가 잘못된 것.
* 테스트가 코드의 구조적 변경에 너무 취약할 것이므로 개선점에 신경을 써야 한다.

## 정리

* 육각형 아키텍처는 도메인 로직과 어댑터를 분리.
* 덕분에 핵심 도메인 로직은 단위 테스트, 어댑터는 통합 테스트로 처리하는 명확한 테스트 전략을 정의 가능.
* 입출력 포트는 테스트에서 아주 뚜렷한 모킹 지점이다.
* 모킹하는 것이 너무 무거워지거나 코드의 특정 부분을 커버하기 위해 어떤 종류의 테스트를 써야 할지 모르겠다면 이는 경고 신호다.
* 이런 측면에서 테스트는 아키텍처의 문제에 대해 경고핟고 유지보수 가능한 코드를 만들기 위한 올바른 길로 인도하는 카나리아의 역할도 한다.
