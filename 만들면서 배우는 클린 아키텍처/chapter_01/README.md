# chapter 1. 계층형 아키텍처의 문제는 무엇일까?

* 일반적인 계층형 아키텍처는 웹 계층, 도메인 계층, 영속성 계층으로 이루어진다. 
* 맨위의 웹 계층에서는 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다.
* 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출한다.

사실 계층형 아키텍처는 견고한 아키텍처 패턴이다. 계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다.
원한다면 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다. 기존 기능에 영향을 주지 않고 기능 추가도 가능하다.
 
그렇다면 계층형 아키텍처의 문제점은 무엇일까? 

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

* 정의에 따르면 전통적은 계층형 아키텍처의 토내는 데이터베이스다.
* 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.
* 모든 것이 영속성 계층을 토대로 만들어지므로, 이런 방식ㅇ느 다양한 이유로 문제를 초래한다.

우리는 상태가 아니라 행동을 중심으로 모델링한다.
어떤 애플리케이셔이든상태가 중요한 요소이긴 하지만 행동이 상태를 바꾸는  주체이기 때문에 행동이 비즈니스를 이끌어간다.
 
그렇다면 왜 도메인 로직이 아닌 데이터베이스를 토대로 아키텍처를 만드는 것일까?

* 도메인 로직을 먼저 구현했는가? 아니면 영속성 계층을 먼저 구현했는가?
* 아마 데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현했을 것이다.
* 전통적인 계층형 아키텍처에서는 합리적인 방법이다. 의존성의 방향에 따라 자연스럽게 구현한 것이기 때문이다.
* 하지만 비즈니스 관점에서는 전혀 맞지 않는 방법이다.
* __다른 무엇보다도 도메인 로직을 먼저 만들어야 한다.__
* 그래야만 우리가 로직을 제대로 이해했는지 확인할 수 있다.
* 도메인 로직이 맞다는 것을 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.

데이터베이스 중심 아키텍처가 만들어지는 가장 큰 원인은 ORM을 사용하기 때문이다. ORM과 계층형 아키텍처를 사용하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

* ORM에 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다.
* 계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근할 수 있다.
* 그리고 이러한 엔티티에 접근할 수 있다면 분명 사용한다.
* 하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.
* 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시로딩, 지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야 한다.

영속성 코드가 사실상 도메인코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워진다.
이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대된다.

## 지름길을 택하기가 쉬워진다.

전통적인 계층형 아키텍처에서 적용되는 유일한 규칙은, 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다.

* 따라서 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면된다. 그러면 접근 가능하고, 깔끔하게 문제가 해결된다.
* 딱 한 번 하는 것은 괜찮다. 그러나 이후 부터는 언제나 그렇게 해도 된다는 마음이 생겨버린다. 특히 마감일이 다가올수록..
* 그럼 개발자들은 이런 편한 지름길을 택한다.
* 결론적으로 영속성 계층에서는 모든 것에 접근 가능하기 때문에 시간이 지나면서 점점 비대해진다.
* 그러니 아키텍처의 지름길 모드를 끄고 싶다면, 적어도 추가적인 아키텍처 규직을 강제하지 않는 한 계층은 최선의 선택이 아니다.
* 여기서 강제란 해당 규칙이 깨졌을 때 빌드가 실패하도록 만드는 것이다.

## 테스트하기 어려워진다.

계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다.
엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없지 않을까?

* 도메인 계층을 건너뛰는 것은 도메인 로직을 코드 여기저기에 흩어지게 만든다.
* 처음몇번은 괜찮지만, 이런일이 자주 일어나면 문제가 있다.
* 첫 번째 문제는 단 하나의 필드를 조작하는 것에 불과하더라도 도메인로직을 웹 계층에 구현한다는 것이다.(유스케이스가 확장된다면 문제가 발생)
* 두 번째 문제는 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야 한다는 것이다. 이렇게 되면 단위테스트의 복잡도가 올라간다.
* 테스트 설정이 복잡해지는 것은테스트를 전혀 작성하지 않는 방향으로 가는 첫 걸음이다. 복잡한 설정을 할 시간이 없기 때문이다.

## 유스케이스를 숨긴다.

* 프로젝트에서 기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는 데 도움이 되야 한다.
* 이런 관점에서 계층형 아키텍처는 어떻게 우리의 발목을 잡을까?
* 계층형 아키텍처에서는 도메인 로직이 흔어지기 쉽다.
* 유스케이스가 간단해서 도메인 계층을 생략한다면 웹 계층에 존재할 수도 있고, 도메인 계층과 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌트를 아래로 내렸다면 영속성 계층에 존재할 수도 있다.
* 이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태다.
* __계층형 아키텍처는 도메인 서비스의 너비에 관한 규칙을 강제하지 않는다.__
* 즉 유스케이스를 담당하는 서비스가 아주 커지기도 한다.
* 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.
* 그럼 서비스를 테스트하기 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

## 동시작업이 어려워진다.

* 애플리케이션에서 새로운 유스케이스를 추가한다고 가정한다.
* 누구는 웹 계층에 필요한 기능을 추가할 수 있고, 누구는 도메인 계층에, 누구는 영속성 계층에 기능을 추가할 수 있다.
* 계층형 아키텍처에서는 이렇게 작업할 수 없다.
* 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 한다.
* 그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.
* 물론 인터페이스를 같이 정의하고 이 인터페이스로 작업하면 된다.
* 가능하지만, 이전에 말했듯이 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다.
* 데이터베이스 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면을 개별적으로 작업할 수 없기 때문이다.
* 특히 넓은 서비스가 존재하면 동시 작업은 더욱 어렵다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

* 올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수 하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있게 된다.
* 그러나 계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다.
* 아주 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기가 어려워지기 쉽다.
* 그리고 이런 훈련은 보통 PM이 개발팀에 새로운 마감일을 설정할 때마다 조금씩 느슨해지기 마련이다.

나의 결론: 계층형 아키텍처는 안좋은 방향으로 흘러갈 가능성이 높다. 물론 이상적이게 도메인 주도로 개발하면 훌륭한 아키텍처다.