# chapter 3. 코드 구성하기

* 코드를 구성하는 방법을 살펴본다. 표현력 있는 패키지 구조를 확인하자.

## 계층으로 구성하기

첫 번째 방식은 계층을 이용. web, domain, persistence와 같이 계층으로 패키지를 구성한다.
적어도 3가지 이유로 최적의 구조가 아니다.

1. 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다.
2. 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
3. 패키지 구조를 통해서는 우리가 목표로 하는 아키텍처를 파악할 수 없다.

## 기능으로 구성하기

* 도메인 위주로 구성하는 것이 예로 나왔다. UserController, UserService, UserRepositoryImpl
* 사실 기능에 의한 패키징 방식은 사실 계층에 의한 패키징 방식보다 아키텍처의 가시성을 떨어뜨린다.

## 아키텍처적으로 표현력 있는 패키지 구조

* 육각형 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉(주도하거나 주도되는) 어댑터다.
* 아래는 애플리케이션의 아키텍처를 표현하는 패키지 구조 예시다.

```
src
    account
        adapter
            in
                web
                    AccountController
            out
                persistence
                    AccountPersistenceAdapter
                    SpringDataAccountRepository
        domain
            Account
            Activity
        application
            SendMoneyService
            port
                in
                    SendMoneyUseCase
                out
                    LoadAccountPort
                    UpdateAccountStatePort
```

* 구조의 각 요소들은 패키지 하나씩에 직접 매핑된다. 최상위에는 Account와 관련된 유스케이스를 구현한 모듈임을 나타내는 account 패키지가 있다.
* 그 다음 레벨에는 도메인 모델이 속한 domain 패키지가 있다. application 패키지는 도메인 모델을 둘러싼 서비스 계층을 말한다.
* SendMoneyService는 인커밍 포트 인터페이스인 SendMoneyUserCase를 구현한다.
* 아웃고잉 포트 인터페이스이자 영속성 어댑터에 의해 구현된 LoadAccountPort와 UpdateAccountStatePort를 사용한다.
* adapter 패키지는 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터와 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한다.
* 위 예제의 경우 각각의 하위 패키지를 가진 web 어댑터와 persistence 어댑터로 이루어진 간단한 웹 애플리케이션이 된다.

이 코드는 이른바 '아키텍처-코드 갭' 혹은 '모델-코드 갭'을 효과적으로 다룰 수 있는 요소다.
이러한 용어는 대부분의 소프트웨어 개발 프로젝트에서 아키텍처가 코드에 직접적으로 매핑될 수 없는 추상적 개념이라는 사실을 보여준다.
 
이 패키지 구조의 또 다른 장점은 DDD 개념에 직접적으로 대응시킬 수 있다는 점이다.
* account 같은 상위 레벨 페키지는 다른 바운디드 컨텍스트와 통신할 전용 진입점과 출구를 포함하는 바운디드 컨텍스트에 해당한다.
* domain 패키지 내에서는 DDD가 제공하는 몯느 도구를 이용해 우리가 원하는 어떤 도메인 모델이든 만들 수 있다.

## 의존성 주입의 역할

* 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.
* 웹 어댑터와 같이 인커밍 어댑터에 대해서는 그렇게 하기가 쉽다.
* 제어 흐름의 방향이 어댑터와 도메인 코드 간의 의존성 방향과 같은 방향이기 때문이다.
* 어댑터는 그저 애플리케이션 계층에 위치한 서비스를 호출할 뿐이다.
* 영속성 어댑터와 같이 아웃고잉 어댑터에 대해서는 제어 흐름의 반대 방향으로 의존성을 돌리기 위해 의존성 역전 원칙을 이용해야 한다.
* 애플리케이션 계층에 인터페이스를 만들고 어댑터에 해당 인터페이스를 구현한 클래스를 두면 된다.
* 육각형 아키텍처에서는 이 인터페이스가 포트다.
* 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까? 이 부분에서는 의존성 주입을 사용한다.
* 모든 계층에 의존성을 가진 중립적인 컴포넌트를 하나 도입하는 것이다.
* 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.