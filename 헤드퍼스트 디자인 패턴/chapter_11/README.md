# chapter 11. 객체 접근 제어하기(프록시 패턴)

## 원격 프록시의 역할

원격 프록시는 원격 객체의 로컬 대변자 역할을 한다.

* 원격 객체란 자바 가상 머신의 힙에서 살고 있는 객체를 뜻한다. 정확히 말하면 다른 주소 공간에서 돌아가고 있는 객체다.
* 로컬 대변자의 어떤 메서드를 호출하면, 다른 원격 객체에게 그 메서드 호출을 전달해주는 객체를 로컬 대변자라고 한다.

즉 클라이언트는 원격 객체의 메서드 호출을 하는 것처럼 행동하다.
하지만 실제로는 로컬 힙에 들어있는 프록시 객체의 메서드를 호출한다.
네트워크 통신과 관련된 저수준 작업은 프록시 객체에서 처리한다.

## JAVA RMI(Remote Method Invocation)

* RMI는 우리 대신 클라이언트와 서비스 보조 객체를 만들어 준다.
* 보조 객체에는 원격 서비스와 똑같은 메서드가 들어있따.
* RMI를 사용하면 네트워킹 및 입출력 관련 코드를 작성하지 않아도 된다.
* 클라이언트는 그냥 같은 로컬 JVM에 있는 메서드를 호출하듯이 원격 메서드를 호출할 수 있다.
* 또한 클라이언트가 원격 객체를 찾아서 접근할 때 쓸 수 있는 룩업 서비스도 RMI에서 제공한다.
* RMI와 로컬 메서드 호출의 차이점도 임ㅆ다.
* 클라이언트는 로컬 메서드 호출과 똑같은 식으로 메서드를 호출하지만, 실제로는 클라이언트 보조 객체가 네트워크로 호출을 전송해야 하므로 네트워킹 및 입출력 기능이 반드시 필요하다는 차이점이 있다.

RMI에서 클라이언트 보조 객체는 스텁, 서비스 보조 객체는 스켈레톤이라고 부른다. 스텁이라고 부르는 보조 객체가 프록시 역할을 맡는다.

## 원격 서비스 실습

### 1. 원격 인터페이스 만들기

1. java.rmi.Remote를 확장한다.
2. 모든 메서드를 RemoteException을 던지도록 선언한다.
3. 원격 메서드의 인자와 리턴값은 반드시 원시 형식 또는 Serializable 형식으로 선언한다.

### 2. 서비스 구현 클래스 만들기.

* 서비스 클래스에 원격 인터페이스를 구현한다.
* UnicastRemoteObject를 확장한다.
* RemoteException을 선언하는 생성자를 구현한다.
* 서비스를 RMI 레지스트리에 등록한다.

### 3. RMI 레지스트리 등록하기

### 4. 원격 서비스 실행하기

## 프록시 패턴의 정의

프록시 패턴은 특정 객체로부터의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공한다.

* 프록시는 다른 객체의 대리인이라고 봐도 무방하다.
* 원격 프록시가 접근을 제어해서 네트워크 관련 사항을 챙겨줬다.
* 프록시에서 접근을 제어하는 몇 가지 방법은 아래와 같다.
    * 원격 프록시를 써서 원격 객체로의 접근을 제어한다.
    * 가상 프록시를 써서 생성하기 힘든 자원으로의 접근을 제어할 수 있다.
    * 보호 프록시를 써서 접근 권한이 필요한 자원으로의 접근을 제어할 수 있다.

## 원격 프록시 vs 가상 프록시

원격 프록시

* 원격 프록시는 다른 JVM에 들어있는 객체의 대리인에 해당하는 로컬 객체다.
* 프록시의 메서드를 호출하면 그 호출이 네트워크로 전달되어 결국 원격 객체의 메서드가 호출된다.
* 그리고 그 결과가 다시 프록시를 거쳐서 클라이언트에게 전달된다.

가상 프록시

* 가상 프록시는 생성하는 데 많은 비용이 드는 객체를 대신한다.
* 진짜 객체가 필요한 상황이 오기 전까지 객체의 생성이 미루는 기능을 제공한다.
* 객체 생성 전이나 객체 생성 도중에 객체를 대신하기도 한다.
* 객체 생성이 끝나면 진짜 객체에게 직접 요청을 한다.

## 보호 프록시 만들기

* 자바의 java.lang.reflect 패키지 안에 프록시 기능이 내장되어 있다.
* 이 패키지를 사용하면 즉석에서 하나 이상의 인터페이스를 구현하고, 지정한 클래스에 메서드 호출을 전달하는 프록시 클래스를 만들 수 있다.
* 진짜 프록시 클래스는 실행 중에 생성되므로 이러한 자바 기술을 __동적 프록시__ 라고 한다.
* 자바에서 proxy 클래스를 생성해주므로 proxy 클래스에게 무슨 일을 해야 하는지 알려 줄 방법이 필요하다.
* 필요한 코드를 직접 구현하는 건 아니기에 이전처럼 그 코드를 프록시 클래스에 넣을 수 없다.
* 그 코드는 InvocationHandler에 넣어야 한다.
* InvocationHandler는 프록시에 호출되는 모든 메서드에 응답한다.
* Proxy에서 메서드 호출을 받으면 항상 InvocationHandler에 진짜 작업을 부탁한다고 생각하면 된다.

보호 프록시란 접근 권한을 바탕으로 객체로의 접근을 제어하는 프록시다.


## 동적 프록시 만들기

1. 2개의 InvocationHandler 만들기
2. 동적 프록시 생성 코드 만들기
3. 적절한 프록시로 Person 객체 감싸기

* __프록시가 동적이라고 하는 이유는 클래스 실행 중에 생성되기 때문이다.__
* InvocationHandler 자체는 프록시가 아니다. 메서드 호출을 처리해주는 클래스다.
* 실제 프록시는 Proxy.newProxyInstance()라는 정적 메서드에 의해서 실행 중에 동적으로 생성된다.