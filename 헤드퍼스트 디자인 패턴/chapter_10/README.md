# chapter 10. 객체의 상태 바꾸기(상태 패턴)

## 뽑기 기계 코드

* 상태를 인스턴스 변수에 저장함. 상태는 정수 값으로 SOLD_OUT = 0, NO_QUARTER = 1 등 이렇게 할당함.
* 새로운 요구 사항이 들어왔다. 따라서 새로운 상태를 추가해야함.
* 그러면 엄청나게 많은 조건문을 모든 메서드에 추가해야한다. 코드를 엄청 고쳐야 하며, 이는 버그 발생확률을 높이는 행위다.
* __역시 바뀌는 부분은 캡슐화를 진행해야 한다.__
* 상태별 행동을 별도의 클래스에 넣어 두고 모든 상태에서 각각 자기가 할 일을 구현하도록 하는 것이 좋을 것 같다.

## 상태 패턴을 도입한 리팩토링

* 상태 패턴을 기반으로 리팩토링을 진행해 다음과 같은 결과를 얻었다.
* 각 상태의 행동을 별개의 클래스로 국지화했다.
* 관리하기 힘든 골칫덩어리 if 선언문들을 없앴다.
* 각 상태를 변경에는 닫혀 있게 했고, GumballMachine 클래스는 새로운 상태 클래스를 추가하는 확장에는 열려 있도록 고쳤다.
* 더 이해하기 좋은 코드 베이스와 클래스 구조를 만들었다.

## 상태 패턴의 정의

__상태 패턴을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다. 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다.__

* 해당 패턴은 상태를 별도의 클래스로 캡슐화한 다음 현재 상태를 나타내는 객체에게 행동을 위임하므로 내부 상태가 바뀔 때 행동이 달라지게 된다는 사실을 쉽게 알 수 있다.

전략 패턴과 매우 비슷해 보인다. 그러나 용도는 다르다.

* 상태 패텬을 사용할 때는 상태 객체에 일련의 행동이 캡슐화 된다.
* 상황에 따랄 Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡기게 된다. 
* 그 객체의 내부 상태에 따라 현재 상태를 나타내는 객체가 바뀌게 되고, 그 결과로 Context 객체의 행동도 자연스럽게 바뀐다.
* 클라이언트는 상태 객체를 몰라도 된다.
* 하지만 전략 패턴을 사용할 때는 일반적으로 클라이언트가 Context 객체엑 어떤 전략 객체를 사용할지 지정해준다.
* 일반적으로 전략 패턴은 서브 클래스를 만드는 방법을 대신해서 유연성을 극대화하는 용도로 쓰인다.
* Context 객체에 수많은 조건문을 넣는 대신에 상태 패턴을 사용한다고 생각하면 된다.
* 행동을 상태 객체 내에 캡슐화하면 Context 내의 상태 객체를 바꾸는 것만으로도 Context 객체의 행동을 바꿀 수 있다.