# chapter 1. 디자인 패턴의 세계로 떠나기(디자인 패턴 소개와 전략 패턴)

## 오리 시뮬레이션 게임

* Duck이라는 추상 클래스를 만들고, 이를 상속하는 다양한 구체 오리 클래스를 여러 가지 만듦.
* 요구사항 변경으로 Duck 클래스에 fly()라는 메서드를 추가.
* 그러나 fly 메서드를 추가하면서 문제 발생. fly() 메서드는 일부 서브 클래스에 적합하지 않음. (ex.고무 오리새)
* 인터페이스를 여러 개 만들어 구현하는 방법을 선택 -> 메서드 몇 개 오버라이딩하는 의도로 인해 엄청난 중복 코드 발생.
* 마찬가지로 상속할 추상 클래스에 fly()를 추상 메서드로 구현 -> 상속한 서브 클래스에서 엄청난 오버라이딩으로 인한 중복 코드 발생.
* __즉 상속은 올바른 해결 방법이 아니다.__

## 소프트웨어 개발 불변의 진리

__소프트웨어 개발에서 절대로 바뀌지 않는 진리는 애플리케이션이 항상 변화한다는 것이다.__

## 문제를 명확하게 파악하기

* 애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다.
* 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 __캡슐화__ 한다.
* 그러면 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이면서 시스템의 유연성을 향상시킬 수 있다.
* 바뀌는 부분은 따로 뽑아서 캡슐화하자. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.
* __이 개념은 매우 간단하지만 다른 모든 디자인 패턴의 기반을 이루는 원칙이다__
* 늘 좋은 설계를 고민하고, 디자인 패턴을 배우는 근본적인 문제는 소프트웨어의 변화 때문이다.
* 개인적으로 if-else 구문이 보이면 추상화를 먼저 생각하도록 노력하자.

## 오리 행동 수정하기

* 각 오리의 행동은 인터페이스에 표현하고 표현한 인터페이스를 사용해서 행동을 구현한다.
* 새로운 디자인을 사용하면 Duck 서브 클래스는 인터페이스로 표현되는 행동을 사용한다.
* 따라서 실제 행동구현은 Duck 서브 클래스에 국한되지 않는다.
* 가장 중요한 점은 나는 행동과 꽥꽥거리는 행동을 Duck 클래스에서 정의한 메서드를 써서 구현하지 않고 다른 클래스에 위임한다는 것이다.
* 행동과 관련된 인터페이스의 구현 클래스 인스턴스를 Duck 서브 클래스에 멤버 변수로 두기 위해 의존성 주입을 하는 것이 좋다. 실행 시에 행동을 바꿀 수 있기 때문이다. 즉 런타임 의존성이 유연해진다.
* 물론 의존성 주입인 세터 주입을 사용해서도 실행 시에 행동을 바꿀 수 있다.

## 조합, 구성, Composition

* 'A에는 B가 있다' 관계를 생각해본다.
* 각 오리에는 FlyBehavior와 QuackBehavior가 있으며, 각각 나는 행동과 꽥꽥거리는 행동을 위임 받는다.
* 이런 식으로 두 클래스를 합치는 것을 구성, 조합(Composition)이라고 부른다.
* 조합을 사용해 시스템을 만들면 유연성을 크게 향상시킬 수 있다.
* 단순히 알고리즘군을 별도의 클래스 집합으로 캡슐화할 수 있으며 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행 시에 행동을 바꿀 수도 있다.
* 상속은 객체를 계층화하기 위해 사용하면 좋은 것 같다. 코드의 반복이 문제라면 상속보다는 조합을 우선시하자.

## 디자인 원칙 정리

* 소프트웨어 개발에서 절대로 바뀌지 않는 진리는 애플리케이션이 항상 변화한다는 것이다. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
* 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 즉 다형셩, 상위 형식에 맞춰서 프로그래밍한다. 역할이라고 생각해도 괜찮을 것 같다.
* 상속보다는 조합을 사용하자.