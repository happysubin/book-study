# chapter 2. 객체 꾸미기(데코레이터 패턴)

## 클래스 폭발 문제

* 음료를 추상 클래스로 만들어서 구체적인 커피를 정의할 때 서브 클래스로 만든다. 이때 계산 로직에서 발생한 클래스 폭발 문제를 살펴보았다.

## 데코레이터 패턴

* 상속을 써서 재료 가격을 총 산출 하는 방법은 좋은 방법이 아니었다. 클래스 폭발 문제가 발생했다.
* 다른 방법을 찾아보자. 특정 음료에서 시작해서 첨가물로 그 음료를 __장식__ 해보자.
* 예를 들어 어떤 고객이 모카와 휘핑크림을 추가한 다크 로스트 커피를 주문한다면 다음과 같이 장식할 수 있다.

1. DarkLoast 객체를 가져온다.
2. Mocha 객체로 장식한다.
3. Whip r객체로 장식한다.
4. cost() 메서드를 호출한다. 이때 첨가물의 가격을 계산하는 일은 해당 객체에게 위임한다.

여기서 어떻게 객체를 장식할 수 있을까? 또한 이 과정에서 어떻게 위임할 수 있을까? 데코레이터 객체를 래퍼 객체라고 가정하고 생각해보자.

* 데코레이터의 슈퍼 클래스는 자신이 장식하고 있는 객체의 슈퍼 클래스와 같다.
* 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
* 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다.
* __데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다.__
* 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다.

### 데코레이터 패턴 정의

* 데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터를 사용하면 서브 클래스를 만들 때보다 훨씬 유연하게 기능ㅇ르 확장할 수 있다.

데코레이터 패턴에서 주의할 점.

* 구상 구성 요소로 어떤 작업을 처리하는 코드에 데코레이터 코드 패턴을 적용하면 제대로 작동하지 않는다. 예를 들어 에스프레소 커피에 할인을 하는 등의 작업. 데코레이터로 감싸면 내부 커피가 무엇인지 모르기 때문이다.
* 데코레이터 패턴을 쓰면 관리해야할 객체가 늘어나므로 실수할 가능성도 높아진다. 이때는 팩토리나 빌더 같은 다른 패턴으로 데코레이터를 만들고 사용한다.
* 나중에 그런 패턴을 배워 데코레이터로 장식된 구상 구성요소는 캡슐화가 잘되므로 걱정하지 않아도 된다. __빌더와 팩토리 패턴을 꼭 같이 도입해야하는 것 같다.__
* 프록시 패턴은 객체에 대한 접을 제어하고, 데코레이터 패턴 객체의 기능을 확장하는데 초점을 맞춘다.

### 데코레이터 적용 예시: 자바 I/O

* java.io 패키지는 데코레이터 패턴을 바탕으로 만들어졌다.
* InputStream은 추상 구성 요소다.
* FileInputStream, StringBufferdInputStream과 같은 클래스는 데코레이터에 감싸이는 구상 구성 요소 역할을 맡는 클래스다.
* BufferedInputStream과 ZipInputStreasm은 둘 다 FilterInputStream을 확장한 클래스이며, FilterInputStream은 InputStream을 확장한 클래스다.
* FilterInputStream은 추상 데코레이터다.
* 직접 자바 I/O 데코레이터를 만드는 실습을 진행했다.

## 디자인 원칙

* 클래스에는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다. Open-Close Principle OCP 원칙이다.