# chapter 6. 호출 캡슐화하기(커맨드 패턴)

## 커맨드 패턴 예시

* 객체지향 마을의 식당을 예시로 살펴보았다.
* 손님 - 클라이언트 객체 
* 종업원 - 인보커 객체
* 주문서 - 커맨드 객체
* 주방장 - 리시버 객체

## 커맨드 패턴 

* 커맨드 패턴을 사용하면 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 
* 이러면 요청을 쿠에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다.

커맨드 객체는 일련의 행동을 리시버와 연결함으로써 요청을 캡슐화한다.
이러려면 행동과 리시버를 한 객체에 넣고, execute()라는 메서드 하나만 외부에 공개하는 방법을 써야 한다.
이 메서드 호출에 따라 리시버에서 일련의 작업을 처리한다. 밖에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버가 어떤 일을 하는지 알 수 없다.
그냥 execute() 메서드를 호출하면 해당 요청이 처리된다는 사실만 알 수 있다.
 
명령으로 객체를 매개변수화하는 사례도 볼 수 있다. 람다식을 사용.

* 예시에서 종업원이 여러 개의 주문서로 매개변수화되는 것을 볼 수 있었다.
* 종업원이나 리모컨 즉 인보커는 특정 인터페이스만 구현되어 있다면 그 커맨드 객체에서 실제로 어떤 일을 하는지 신경 쓸 필요가 없다.

### 커맨드 패턴 다이어그램

* 클라이언트는 구체 클래스 커맨드를 생성하고 리시버를 설정 or 생성한다.
* 인보커에는 명령이 들어있으며, execute() 메서드를 호출함으로써, 커맨드 객체에게 특정 작업을 수행해 달라는 요구를 하게 된다.
* 리시버는 요구 사항을 수행할 때 어떤 일을 처리해야 하는지 알고 있는 객체다.
* 커맨드 객체는 리시버에 있는 메서드를 호출해서 요청된 작업을 수행한다.

참고

* NoCommand 객체는 일종의 널 객체다.
* 널 객체는 딱히 리턴할 객체도 없고 클라이언트가 null을 처리하지 않게 하고 싶을 때 활용하면 좋다.
* 널 객체는 여러 디자인 패턴에서 유용하게 쓰인다.

## 작업 취소 기능 구현

* 작업 취소 매서드인 undo를 커맨드 인터페이스 추상 메서드에 추가.
* 이를 서브 커맨드 객체가 오버라이딩함. 물론 리시버의 취소 메서드를 호출하는 로직을 호출해주는 역할.
* 이전 작업을 저장하는 상태변수도 추가함.

## 여러 동작을 한 번에 처리함

* 커맨드 인터페이스를 구현한 서브 클래스에서 커맨드 리스트를 가지고 있다.
* 이같은 구현을 통해 여러 동작을 한 번에 처리했다.

## 커맨드 패턴 활용

* 커맨드로 컴퓨테이션의 한 부분을 패키지로 묶어서 일급 객체 형태로 전달할 수도 있다.
* 그러먼 클라이언트 애플리케이션에서 커맨드 객체를 생성한 뒤 오랜 시간이 지나도 그 컴퓨테이션을 호출할 수 있다.
* 예시로는 작업 큐가 있다. 작업큐 한 쪽은 커맨드를 추가하고, 다른 쪽은 커맨드를 처리하는 스레드가 대기한다.
* 각 스레드는 우선 execute 메서드를 호출하고 호출이 완료되면 커매드 객체를 버리고 새로운 커맨드를 가져온다.
* 작업 큐 클래스는 계산 작업을 하는 객체들과 완전히 분리되어 있다.
* 큐에 커맨드 패턴을 구현하는 객체를 넣으면 그 객체를 처리하는 스레드가 생기고 자동으로 execute 메서드가 호출된다.
* 어떤 애플리케이션은 몯느 행동을 기록해 두었다가 애플리케이션이 다운되었을 때 행동을 다시 호출해서 복구할 수 있어야 한다.
* 커맨드 패턴을 사용하면 store, load 메서드를 추가해서 이런 기능을 구현할 수 있다.
* 로그 기록은 어떤 명령을 실행하면서 디스크에 실행 히스토리를 기록하고, 애플리케이션이 다운되면 커맨드 객체를 다시 로딩해서 execute 메서드를 자동으로 순서대로 실행하는 방식으로 작동한다.

### 커맨드 패턴에서 아직 인보크 객체가 잘 와닿지 않고, 로그 기록, 큐도 잘 와닿지 않는다. 복습이 더 필요할 것 같다.