# chapter 4. 객체지향 빵 굽기(팩토리 패턴)

## new 연산자

* new를 사용하면 구상 클래스의 인스턴스가 만들어진다. 인터페이스가 아닌 특정 구현을 사용하는 것이다.
* 구상 클래스를 바탕으로 코딩하면 나중에 코드를 수정해야 할 가능성이 커지고, 유연성이 떨이진다.
* 변화하는 무언가 때문에 new를 조심해서 사용해야 한다.
* 인터페이스에 맞춰서 코딩하면 시스템에서 일어날 수 임ㅆ는 여러 변화에 대응할 수 있다.
* 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용할 수 있기 때문이다.
* 모두 다형성 덕분이다.
* 반대로 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야 하므로 수많은 문제가 생길 수 있다.
* 즉 변경에 닫혀 있는 코드가 되는 것이다.
* 새로운 구상 형식을 써서 확장해야 할 때는 어떻게 해서든 다시 열 수 있게 만들어야 한다.

## 피자 코드 기초 예제

* if-else if 구문을 통해 구체 클래스 인스턴스를 생성함.
* 여기에 갈수록 새로운 피자가 추가되므로 if-else if 구문이 계속 장황해짐.
* 기억해야할 부분. 자주 변하는 부분은 캡슐화를 진행하자.
* 피자 인스턴스를 생성하는 부분을 뽑아 새로운 클래스를 작성함.
* 객체 생성을 처리하는 클래스를 팩토리라고 부른다.

참고

* 정적 팩토리 메서드와 지금 살펴보는 팩토리 메서드는 다르다. 정적 팩토리 메서드는 서브클래스를 만들어서 객체 생성 메서드의 행동을 변경할 수 없다. 물론 정적 메서드를 쓰면 인스턴스를 만들지 않아도 되는 장점이 있다.

## 간단한 팩토리 정의

* 간단한 팩토리는 디자인 패턴이라기보다는 프로그래밍에서 자주 쓰이는 관용구에 가깝다.

## 피자 가게 프레임워크 만들기

* 이번에는 피자를 생성하는 메서드를 추상 메서드로 선언하고, 지역별 스타일에 맞게 피자 가게의 서브 클래스를 만들었다.
* 팩토리 객체 대신 추상 메서드를 사용한다. 이제 각 지점에 맞게 서브 클래스를 만든다.
* 위 방식을 따르면 피자의 종류는 어떤 서브 클래스를 선택했느냐에 따라 결정된다.

## 팩토리 메서드 패턴

* PizzaStore를 계손 고친 결과, 구상 클래스 인스턴스 만드는 일을 하나의 객체가 전부 처리하는 방식에서 일련의 서브 클래스가 처리하는 방식으로 바꿈.
* 팩토리 메서드는 객체 생성을 서브 클래스에 캡슐화할 수 있다.
* 그러면 슈퍼 클래스에 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리할 수 있다.
* 우리가 지금 살펴본 방법은 __팩터리 메서드 패턴__ 이라고 한다.
* 팩토리 메서드 패턴은 서브클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화 한다.
* 생선자 클래스: PizzaStore, NYPizzaStore, ChicagoPizzaStore
* 제품 클래스: Pizza, NyStyleVeggiePizza, ChicagoStyleClamPizza 등

팩토리 메서드 패턴의 정의는 아래와 같다.

* 객체를 생성할 때 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정한다. 팩토리 메서드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 된다.
* 중요한 부분은 사용하는 서브클래스에 따라 생산되는 객체 인스턴스가 결정된다는 것이다.
* 결국 객체를 생성하는 코드를 캡슐화한 것이다. 이는 다시 말하면 __바뀌는 부분을 캡슐화한 것이다.__

## 의존성 뒤집기 원칙 (DIP)

* 새로운 피자 가게 클래스는 if- else if 구문을 사용해 하나의 메서드에서 피자 구체 클래스를 생성해서 리턴한다.
* 구상 클래스 의존성을 줄이면 좋다. 이런 원칙을 의존성 뒤집기 원칙이라고 한다.
* 의존성 뒤집기는 추상화를 더 많이 강조한다.
* 이 원칙에는 고수준 구성 요소가 저수준 구성 요소에 의존하면 안 되며, 항상 추상화에 의존하게 만들어야 한다는 뜻이 담겨 있다.
* 피자 가게는 고수준 구성 요소고, 피자 클래스는 저수준 구성 요소라고 할 수 있다.
* 피자 가게 클래스는 구상 피자 클래스에 의존하고 있다.
* 의존성 뒤집기 원칙에 따르면, 구상 클래스처럼 구체적인 것이 아닌 추상 클래스나 인터페이스와 같이 추상적인 것에 의존하는 코드를 만들어야 한다.
* 현재 제일 큰 문제점은 피자 가게 클래스가 모든 피자의 종류에 의존한다는 것이다. 주문 메서드에서 모든 구상 피자 인스턴스를 생성하기 때문이다.
* 팩터리 메서드 패턴을 적ㄷ용하면 고수준 구성 요소인 피자가게와 저수준 구성 요소인 피자 객체 모두가 추상 클래스인 피자에 의존한다는 사실을 알 수 있다.
* 팩터리 메서드 패턴은 이렇게 의존성 뒤집기 원칙을 준수할 수 있는 패턴이다. (DIP를 준수하는 유일한 패턴은 아니다)

### DIP를 지키는 방법

* 변수에 구상 클래스의 레퍼런스를 제공하지 말자. (이말은 의존성 주입을 받으라는 말처럼 들린다)
* 구상 클래스에서 유도된 클래스를 만들지 말자. (인터페이스나 추상 클래스처럼 추상화된 것으로부터 클래스를 만들어야 한다. 즉 역할을 먼저 만들어야함.)
* 베이스 클레스에 이미 구현되어 있는 메서드를 오버라이드하지 말자. (이미 구현되어 있는 메서드를 오버라이드한다면 베이스 클래스가 제대로 추상화되지 않는다.)

## 원재료 팩토리 만들기

* 팩토리에서 윈재료군에 들어있는 각각의 원재료를 생산한다. 즉 반북, 소스, 치즈 같은 걸 생산한다.
* 지역별로 팩토리를 만들어야 한다. 다양한 원재료 클래스를 구현해야 하며, 상황에 따라 서로 다른 지역에서도 같은 재료를 사용할 수 있다. 원재료 팩토리를 PizzaStore 코드에서 사용하도록 하나로 묶어야 한다.
* 기존 코드에서 달라진 점은 원재료를 팩토리에서 바로 가져온다는 점 말고는 없다.
* 팩터리 메서드 패턴을 사용했던 코드와 다른 점은 지역별로 다른 재료를 사용한다는 것이다.
* 피자 코드에서는 팩토리로 피자 재료를 만든다.
* 만들어지는 재료는 어떤 팩토리를 쓰는지에 따라 달라진다.
* 피자 클래스는 어떤 재료가 배달되는지 전혀 신경 쓰지 않는다.
* 이제 피자 클래스와 지역별 재료가 분리되어 있어서 모든 지역에서 어떤 팩토리를 사용하든 클래스는 그대로 재사용할 수 있다.

## 추상 팩토리 패턴

* 추상 팩토리 패턴은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공한다.
* 구상 클래스는 서브 클래스에서 만든다. 제품군은 피자를 만들 때 사용한 모든 재료를 의미한다.
* 추상 팩토리 패턴을 사용하면 클라이언트에서 추상 인터페이스로 일련의 제품을 공급받을 수 있다.
* 이때 실제로 어떤 제품이 생산되는지는 전혀 알 필요가 없다.
* 따라서 클라이언트와 팩토리에서 생산되는 제품을 분리할 수 있다.

템플릿 메서드 패턴과 팩토리 메서드 패턴은 비슷하나, 사용 용도가 다른 것 같다. 템플릿 메서드는 기능 확장, 팩토리 메서드 패턴은 서브 클래스에게 객체 생성을 위임하는 패턴.

## 디자인 원칙

* 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.