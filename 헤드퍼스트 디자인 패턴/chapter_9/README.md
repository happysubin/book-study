# 컬렉션 잘 관리하기 (반복자 패턴과 컴포지트 패턴)

## 반복을 캡슐화하기

* __지금까지 배운 제일 중요한 내용은 바뀌는 부분은 캡슐화하라다.__
* 하나의 클래스는 List를, 다른 하나는 배열[]을 사용하고 있다.
* 그러므로 for문을 통한 출력을 사용하면 서로 다른 코드를 사용한다.
* 이같은 반복 작업 처리 방법을 캡슐화하기 위해 Iterator라는 객체를 만들어서 도입한다.
* 이 방법이 바로 반복자 패턴이라고 부른다.
* 반복자 패턴은 Iterator 인터페이스에 의존한다는 사실을 먼저 알아야 한다.

## 순수 Iterator과 java.util.Iterator

* 직접 만든 Iterator를 사용해 배열과 리스트 반복 출력문을 통합함.
* 추후에는 java.util 패키지에서 제공하는 Iterator 인터페이스를 통해 반복 출력문을 통합함.
* 다형성을 통해 클라이언트에서 구상 클래스 대신 인터페이스 Iterator 타입을 사용해서 문제를 해결함.
* Menu 인터페이스를 Iterator를 반환하는 메서드 1개만을 가짐. 이 iterator를 리턴하는 메서드를 오버라이딩해서 문제를 해결.
* 물론 Iterator를 별도로 오버라이딩해 배열과 리스트를 가져오는 서브 클래스를 각자 구현함.


## 반복자 패턴의 정의

__반복자 패턴은 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공한다.

* 이 패턴을 사용하면 집합체 내에서 어떤 식으로 일이 처리되는지 전혀 모르는 상태에서 그 안에 들어있는 모든 항목을 대상으로 반복 작업을 수행할 수 있습니다.
* 컬렉션 객체 안에 들어있는 모든 항목에 접근하는 방식이 통일되어 있으면 종류에 관계없이 몯느 집합체에 사용할 수 있는 다형적인 코드를 만들 수 있다.
* 또한 반복자 패턴을 사용하면 모든 항목에 일일이 접근하는 작업을 컬렉션 객체가 아닌 반복자 객체가 맡게 된다.
* 집합체의 인터페이스와 구현이 간단해지고 집합체는 반복작업에서 손을 떼고 원래 자신이 할 일(객체 컬렉션 관리)에만 전념할 수 있다.

__컬렉션은 집합체(애그리게이트)라고도 부르며, 구체 집합체는 객체 컬렉션이 들어있다. 그 안에 들어있는 컬렉션의 Iterator로 라턴하는 메서드를 구현한다.__ 

## 단일 역할 원칙 (SRP)

* 집합체에서 내부 컬렉션 관련 기능과 반복자용 메서드 관련 기능을 구현한다면 어떠한가?
* 그러면 집합체에 들어가는 메서드 개수가 늘어나는데, 이는 좋지 않다.
* 좋지 않은 이유는, 클래스에서 원래 그 클래스의 역할(집합체 관리)외에 다른 역할(반복자 메서드)을 처리할 때 2가지 이유로 그 클래스가 바뀔 수 있다.
* 첫째, 컬렉션이 어떤 이유로 바뀌면 그 클래스도 바뀌어야 한다.
* 둘째, 반복자 관련 기능이 바뀌웠을 때도 클래스가 바뀌어야 한다.
* 이런 이유로 어떤 클래스가 바뀌는 이유는 단 하나뿐이어야 한다.

## 종업원 코드 개선하기

* 이제 메뉴를 추가하면 종업원 코드에 새로운 메뉴와 관련된 코드를 추가해야 한다. 그래야지 정상적으로 출력할 수 있다.
* 그러나 이는 OCP 원칙에 위배된다. 우리의 경우는 팬케이크 메뉴, 카페메뉴 등 코드를 총 3번 고쳤다.
* 그래서 메뉴들을 아예 종업원 인스턴스 List로 묶었다.
* 새로운 요구 사항으로 디저트 메뉴를 서브 메뉴로 추가해달라는 요청이 들어옴. 요구사항은 아래와 같이 정리된다.
    * 메뉴, 서브 메뉴, 메뉴 항목 등을 모두 넣을 수 있는 트리 형태의 구조가 필요하다.
    * 각 메뉴에 있는 모든 항목을 대상으로 특정 작업을 할 수 있는 방법을 제공해야하며, 그 방법은 적어도 지금 사용중인 반복자만큼 편리해야 한다.
    * 더 유연한 방법으로 아이템을 대상으로 반복 작업을 수행할 수 있어야 한다.
현재 코드에서는 이것이 불가능. 이를 해결해보자.

## 컴포지트 패턴의 정의

컴포지트 패턴으로 객체를 트리구조로 구성해서 부분-전체 계층 구조를 구현한다. 컴포지트 패턴을 사용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있다.

* 이 패턴을 사용하면 중첩되어 있는 메뉴 그룹과 항목을 똑같은 구조 내에서 처리할 수 있다.
* 메뉴와 항목을 같은 구조에 넣어서 부분-전체 계층 구조를 생성할 수 있다.
* 여기서 부분 계층 구조란, 부분들이 계층을 이루고 있지만 모든 부분을 묶어서 전체로 다룰 수 있는 구조를 의미한다.
* 쉽게 말해 메뉴, 서브메뉴, 서브서브메뉴로 구성된 트리구조가 임ㅆ다고 하면 각각이 모두 복합 객체가 될 수 있다는 말이다.
* 각 메뉴 안에 다른 메뉴와 메뉴 항목이 들어갈 수 있다. 결국 개별 객체도 메뉴라고 할 수 있다.

## 컴포지트 패턴 코드 결과

* 컴포지트 패턴에서는 단일 역할 원칙을 깨는 대신 투명성을 확보하는 패턴이다.
* Component 인터페이스에 자식들을 관리하는 기능과 잎으로써의 기능을 전부 넣어서 클라이언트가 복합 객체와 잎을 똑같은 방식으로 처리할 수 있도록 만들었다.
* 어떤 원소가 복합 객체인지 잎인지가 클라이언트에게 투명하게 보인다.
* Component 클래스에는 두 종류의 기능이 모두 들어있다 보니 안전성은 약간 떨어진다.
* 이런 문제는 모두 디자인상의 결정 사항에 속한다. 다른 방향으로 디자인해서 여러 역할을 서로 다른 인터페이스로 분리할 수도 있다.
* 안정성을 챙기는 대신 투명성이 떨어지고, 코드에서 조건문이라든가 instanceof 연산자 같은 걸 써야 한다.

__ 방금 지적한 내용은 상황에 따라 원칙을 적절하게 사용해야함을 보여주는 예시다.__

## 디자인 원칙

__어떤 클래스가 바뀌는 이유는 단 하나뿐이어야 한다.__
