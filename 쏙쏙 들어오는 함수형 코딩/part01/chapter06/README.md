## chapter06. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

### 모든 동작을 불변형으로 만들 수 있나요??

이전 장에서 카피-온-라이트 원칙을 적용해 구현함. 배열을 복사하고 값을 바꾼 다음 리턴.

> 데이터 구조안에 데이터 구조가 있는 경우 데이터가 중첩되었다고 한다. 배열 안에 데이터가 있으면 중첩된 데이터

### 동작을 읽기, 쓰기 또는 둘 다로 분류하기

동작을 읽기 또는 쓰기 또는 둘 다 하는 것으로 분류할 수 있따. 

어떤 동작은 읽기인데, 읽기 동작은 데이터를 바꾸지 않고 꺼낸다. 데이터를 바꾸지 않으므로 쉽다.
__만약 인자에만 의존해 정보를 가져온다는 읽기 동작이라면 계산이라고 할 수 있다.__

어떤 동작은 쓰기인데, 쓰기 동작은 어떻게든 데이터를 바꾼다.
바뀌는 값은 어디서 사용될지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.

#### 장바구니 동작

1. 제품 개수 가져오기 (읽기)
2. 제품 이름으로 제품 가져오기 (읽기)
3. 제품 추가하기 (쓰기)
4. 제품 이름으로 제품 빼기 (쓰기)
5. 제품 이름으로 제품 구매 수량 바꾸기 (쓰기)

동작 중 3개가 쓰기다. 쓰기 동작은 불변성 원칙에 따라 구현해야 한다.

불변성 원칙은 __카피-온-라이트라고 한다.__ 하스켈이나 클로저 같은 언어도 이 원칙을 지킴. js는 직접 구현해야함.

읽으면서 쓰는 동작은 어떠한가? 어떤 경우에는 데이터를 바꾸면서 동시에 정보를 가져오는 경우도 있다.

#### 제품에 대한 동작

1. 가격 설정하기 //쓰기 
2. 가격 가져오기 //읽기
3. 이름 가져오기 //읽기

### 카피-온-라이트 원칙 세 단계

1. 복사본 만들기
2. 복사본 변경하기(원하는 만큼)
3. 복사본 리턴하기

add_element_last() 함수는 아래와 같은 특징을 가진다.

```js
function add_element_last(array, elem) {
    let new_array = array.slice();
    new_array.push(elem)
    return new_array
}
```

1. 배열을 복사하고 기존 배열을 변경하지 않음
2. 복사본은 함수 범위에 있기 때문에 다른 코드에서 값을 바꾸기 위해 접근할 수 없습
3. 복사본을 변경하고 나서 함수를 나간다. (리턴) 이후에는 값을 바꿀 수 없다.

그럼 add_element_last() 함수는 읽기인가 쓰기인가??

__데이터를 바꾸지 않았고 정보를 리턴했기 때문에 읽기다. 우리는 쓰기를 읽기로 바꿨다.__


### 카피-온-라이트로 쓰기를 읽기로 바꾸기

장바구니 빼는 동작을 쓰기에서 읽기로 바꾸는 과정을 진행

처음 코드는 전역변수 cart를 넘기면 전역변수 cart가 수정되는 상황.

우리는 이 전역변수 cart가 바뀌지 않기를 원함. 따라서 카피-온-라이트를 적용.

1. 배열을 복사하고
2. 복사한 배열을 수정 후 (요소 삭제)
3. 복사한 배열을 리턴. 그리고 이를 전역변수로 사용하던 변수에 할당함

추후에는 카피-온-라이트를 최적화함. 조회의 근간이 되는 값이 존재할 때만 카피-온-라이트를 하도록 수정. 없다면 그냥 기존 값을 그대로 리턴.

### 쓰기를 하면서 읽기도 하는 동작은 어떻게 할까?

```js
const a = [1, 2, 3, 4]
const b = a.shift()
```

shift 메서드는 값을 바꾸는 동시에 배열에 첫 번째 항목을 리턴한다.

이 동작을 카피-온-라이트 동작으로 어떻게 바꿀까?

1. 읽기와 쓰기 함수로 각각 분리한다.
2. 함수에서 값을 두 개 리턴한다.

첫 번째가 더 좋은 방법.

### 쓰면서 읽기도 하는 함수를 분리하기

읽기와 쓰기 동작으로 분리하기

shift() 메서드의 읽기 동작은 첫 번째 항목 값을 단순히 리턴.

```js
function first_element(array) {
    return array[0]
}
```

아래는 결괏값을 무시하고 shift만 수행하도록 수정

```js
function drop_first(array) {
    array.shift()
}
```

### 쓰기 동작을 카피-온-라이트로 바꾸기

drop_first() 함ㅅ는 인자로 들어온 값을 변경하는 쓰기다. 이제 이것을 카피 온 라이트로 바꾸자.

```js
function drop_frist(array) {
    let array_copy = array.slice();
    array_copy.shift()
    return array_copy
}
```

### 값을 두 개 리턴하는 함수로 만들기

```js
function shift(array) {
    let array_copy = array.slice()
    const first = array_copy.shift()
    return {
        first : first,
        array : array_copy
    }
}
```

### 불변 데이터 구조를 읽는 것은 계산이다..

* 변경 가능한 데이터를 읽는 것은 액션이다.
* 쓰기는 데이터를 변경 가능한 구조로 만든다.
* 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터다.
* 불변 데이터 구조를 읽는 것은 계산이다.
* 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다. 대신 액션은 줄어든다.

### 애플리케이션에는 시간에 따라 변하는 상태가 있다.

우리의 예시로는 쇼핑 카트가 시간에 따라 변한다.

장바구니가 바뀌면 shipping_cart 전역변수에 새로운 값을 할당함. 이런 교체 방식이 함수형 프로그래밍에서 많이 사용된다.

### 불변 데이터는 충분히 빠르다.

* 언제든 최적화가 가능하다. -> 불변 데이터를 쓰다가 느리면 그 때 최적화 ㄱㄱ
* 가비지 콜렉터는 매우 빠르다.
* 생각 보다 많이 복사하지 않는다.
* 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

### 객체에 대한 카피-온-라이트

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

```js
const object = {a :1 , b :2}
const copy = Object.assign({}, object);

function setPrice(item, new_price) {
    item.price = new_price
}

function setPriceV2(item, new_price) {
    let item_copy = Object.assign({}, item)_
    item_copy.price = new_price
    return item_copy
}

```

### 중첩된 쓰기를 읽기를 바꾸기

제품 이름으로 해당 제품의 가격을 바꾸는 쓰기 동작을 수정해야 한다.

이 동작은 중첩된 데이터 구조를 바꿔야 하는 조금 특별한 동작이다. 장바구니 배열 안에 중첩된 항목을 바꿔야 한다.

앞에서 setPrice() 함수를 구현했기 때문에 setPriceByName()에서 제품에 값을 설정하는 코드에 카피-온-라이트 버전의 setPrice() 를 사용할 수 있다.

중첩된 쓰기도 중첩되지 않은 쓰기와 같은 패턴을 사용한다. 복사본을 만들고 변경한 다음 복사본을 리턴한다.


최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야 한다.

데이터의 일부를 바꾸려면 변경하려는 값과 사위의 모든 값을 복사해야 한다.

얕은 복사를 하면 구조적으로 같은 하위 객체들을 공유한다. 참조 값이 동일하기 때문.

__카피 온 라이트는 데이터를 변경하기 전에 얕은 복사를 한다. 그리고 리턴한다. 이렇게 하면 통제할 수 있는 범위에서 불변성을 구현할 수 있다.__
