# Chapter 13. 서브클래싱과 서브타이핑

* 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.
* 프레임워크는 설계와 코드를 함께 사용하기 위한 것이다. 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
* 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다.
* 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.
* 디자인 패턴이 협력을 일관성 있게 만들기 위해 재사용할 수 있는 묶음이라면, 프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드다.
* 결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.

## part 1. 디자인 패턴과 설계 재사용

* 패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징 있다.
  * 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
  * 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 짓을 다른 사람과 의사소통할 수 있다.
  * 페탄은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
  * 패턴의 요점은 패턴이 실무에서 탄생한다는 점이다.
* 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 아이디어다.
* 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.
* 패턴은 치열한 실무 현장의 역학관계 속에서 검증되고 인증된 자산이므로, 실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.
* 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄의 4가지로 분류하는 것이다.

### 패턴과 책임-주도 설계

* 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
* 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.
* 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다.
* 특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구상할 수 있다.
* 패턴의 구성 요소는 클래스가 아니라 역할이다.
* Composite, Strategy, Template Method, DECORATOR 패턴 적용 예제를 살펴봄.

### 패턴은 출발점이다.

* 패턴은 출발점이지 도착점이 아니다.
* 패턴은 설계의 목표가 돼서는 안된다. 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.
* 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하자.
* 패턴을 사용하면서 부딪히게 되는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생한다.
* 부적절한 상황에서 부적절하게 사용된 패턴으로 인해 소프트웨어의 엔프로피가 증가하는 부작용을 낳기 쉽다.
* 패턴을 적용할 때는 항상 설계를 좀 더 단순화하고 명확하게 만들 수 있는 방법이 없는지를 고민해야 한다.
* 패턴을 가장 효과적으로 적용하는 방뻡은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것이다.
* 패턴이 적용된 최종 결과를 이해하는 것보다는 패턴을 목표로 리팩터링하는 이유를 이해하는 것이 훨씬 가치 있으며, 훌륭한 소프트웨어 설계가 발전해 온 과정을 공부하는 것이 훌륭한 설계 자체를 공부하는 것보다 훨씬 중요하다고 이야기한다.
* 패턴은 공통적인 문제에 적절한 해법을 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수도 있다.
* 문제를 분석하고 창의력을 발휘함으로써 패턴을 현재의 문제에 적합하도록 적절하게 수정하라.

## part 2. 프레임워크와 코드 재사용

* 디자인 패턴은 프로그래밍 언어에 독립적으로 재사용 가능한 설계 아이디어를 제공하는 것을 목적으로 한다.
* 따라서 언어에 종속적인 구현 코드를 정의하지 않으므로 디자인 패턴을 적용하기 위해서는 설계 아이디어를 프로그래밍 언어의 특성에 맞춰 가공해야 하고 매번 구현 코드를 재작성해야 한다.
* 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.
* 프레임워크란 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계 또는 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격을 의미한다.
* 프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.
* 프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.
* 프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화다.
* 추상 클래스와 인터페이스는 일관성 있는 협력을 만들기 위한 핵심재료다.
* 협력을 일관성 있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화해야 한다.
* 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야 한다.
* 하지만 상위 정책이 세부 사항에 의존하면 상위 정책이 필요한 모든 경우에 세부 사항도 항상 함께 의존하므로 상위 정책의 재사용성이 낮아진다.
* 이 문제를 해결 하는 최고의 방법은 의존성 역전 원칙에 맞게 사우이 정책과 세부 샇아 모두 추상화에 의존하게 하는 것이다.
* 프레임 워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 배포 단위로 분리해야 한다.
* 예제를 통해 일관성 있는 협력과 프레임워크 사이의 관계를 살펴봄.

### 제어 역전 원리

* 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이며, 의존성 역전은 의존성의 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
* 상위 정책이 구체적인 세부사항에 의존하는 전통적인 구조에선느 상위 정책의 코드가 하부의 구체적인 코드를 호출한다.
* 즉 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷 코드를 호출한다.
* 그러나 의존성을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브 클래스의 메서드를 호출한다.
* 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다.
* 즉 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다.
* 이를 제어 역전의 원리, 또는 할리우드 원리라고 한다.
* 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다.
* 그리고 이렇게 완성되지 않은 채로 남겨진 동작을 훅이라고 말한다.
* 우리의 코드는 수동적인 존재다. 프레임워크가 우리의 코드를 호출해줄 때까지 그저 넋 놓고 기다리고 있어야 한다.