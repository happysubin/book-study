# 부록 A. 계약에 의한 설계

* 구현이 복잡하고 부수효과를 가진 다수의 메서드들을 연이어 호출하는 코드를 분석하는 경우에는 실행 결과를 예측하기 어렵다.
* 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.
* 우리에게 필요한 것은 명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단이다.
* 이 시점이 되면 계약에 의한 설계가 주는 혜택으로 눈을 돌릴 때가 된 것이다.
* 계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다.
* 클라이언트 개발자는 오퍼레이션의 구현을 살펴보지 않더라도 객체의 사용법을 쉽게 이해할 수 있다.
* 계약은 실행 가능하기 때문에 구현에 동기화돼 있는지 여부를 런타임에 검증할 수 있다.

## part 1. 협력과 계약

* C#의 Code Contracts 예제를 살펴봄.
* 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 표현하고 자동으로 문서화할수 있을 뿐만 아니라 실행을 통해 검증할 수 있다.
* 계약의 세부적인 내용은 상황마다 다르지만 일반적으로 다음과 같은 특성을 지닌다.
  * 가 계양 당사자는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다.
  * 각 계양 당사자의 이익과 의무는 계약서에 문서화된다.
* 한쪽의 의무가 반대쪽의 권리가 된다.
* 두 계약 당사자 중 어느 한쪽이라도 계약서에 명시된 내용을 위반한다면 계약은 정상적으로 완료되지 않을 것이다.
* 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어다.

## part 2. 계약에 의한 설계

* 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것이다.
  * 협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다.
  * 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다.
* 계약에 의한 설계 개념은 인터페이스에 대해 프로그래밍하라는 원칙을 확장한 것이다.
* 계약에 의한 설계를 이용하면 오퍼레이션의 시그니처를 구성하는 요소들을 이용해 협력에 참여하는 객체들이 지켜야하는 제약 조건을 명시할 수 있다.
* 이 제약 조건을 인터페이스의 일부로 만듦으로써 코드를 분석하지 않고도 인터페이스의 사용법을 이해할 수 있다.
* 계약에 의한 설계를 구성하는 세 가지 요소가 있는데 사전조건, 사후조건, 불변식이다.
* 이번에는 Screening에 대한 제약 조건을 사전조건, 사후조건, 불변식으로 구현함.
* 사전조건은 메서드가 정상적으로 실행되기 위해 만족해야 하는 조건이다.
* 사후조건은 메서드의 실행 결과가 올바른지를 검사하고 실행 후에 객체가 유효한 상태로 남아 있는지를 검증한다.
* 불변식은 인스턴스 생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세한다. 불변식은 객체의 내부 상태와 관련이 있다.
* 불변식은 생성자 실행 후, 메서드 실행 전, 메서드 실행 후에 호출돼야 한다.

## part 3. 계약에 의한 설계와 서브타이핑

* 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.
* 리스코프 치환 원칙의 규칙은 두 가지 종류로 세분화할 수 있다.
* 첫 번째 규칙은 협력에 참여하는 객체에 대한 기대를 표현하는 계약 규칙이고, 두 번째 규칙은 교체 가능한 타입과 관련된 가변성 규칙이다.
* 계약 규칙은 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙이다.
* 가변성 규칙은 파라미터와 리턴 타입의 변형과 관련된 규칙이다.
* 서브타입에 더 강력한 사전 조건을 정의할 수 없다. 사전 조건을 완화하는 것은 가능하다.
* 서브타입에 더 완화된 사후 조건을 정의할 수는 없다. 사후 조건을 강화하는 것은 가능하다.
* 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.
* 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다.
* 일반적으로 부모 클래스가 던지는 예외가 속한 상속 계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우 자식 클래스는 부모 클래스를 대체할 수 없다. 따라서 서브타입이 아니다.
* 클라이언트의 관점에서 부모 클래스에 대해 기대했던 것보다 더 적은 일을 수행하는 자식 클래스는 부모 클래스와 동일하지 않다.
* 부모 클래스보다 못한 자식 클래스는 서브타입이 아니다.
* 서브 타입의 리턴 타입은 공변성을 가져야 한다. S가 T의 서브타입이라고 생각하자.
  * 공변성: S와 T 사이의 서브타입 관계가 그대로 유지된다. 이 경우 해당 위치에서 서브타입인 S가 슈퍼타입 T 대신 사용될 수 있다. 우리가 흔히 이야기하는 리스코프 치환 원칙은 공변성과 관련된 원칙이라고 생각하면 된다.
  * 반공변성: S와 T 사이의 서브타입 관계가 역전된다. 이 경우 해당 위치에서 슈퍼타입인 T가 서브타입인 S 대신에 사용될 수 있다.
  * 무공변성: S와 T 사이에는 아무런 관계도 존재하지 않는다. 따라서 S 대신 T를 사용하거나 T 대신 S를 사용할 수 없다.
* 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성을 리턴 타입 공변성이라고 부른다.
* 리턴 타입 공변성이란 메서드를 구현한 클래스의 타입 계층 방향과 리턴 타입의 타입 계층 방향이 동일한 경우를 가리킨다.
* 슈퍼타입 대신 서브타입을 반환하는 것은 더 강력한 사후조건을 정의하는 것과 같다.
* 자바는 리턴타입에 대해 공변적이지만 C#은 리턴 타입에 대해 무공변적이다.
* 서브타입의 메서드 파라미터는 반공변성을 가져야한다.
* 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성을 파라미터 타입 반공변성이라고 한다.
* 파라미터 타입 반공변성이란 메서드를 정의한 클래스의 타입 계층과 파라미터의 타입 계층의 방향이 반대인 경우 서브타입 관계를 만족하는 것을 의미한다.
* 서브타입 대신 슈퍼타입을 파라미터로 받는 것은 더 약한 사전조건을 정의하는 것과 같다.
* 자바는 파라미터 반공변성을 지원하지 않는다. 객체지향 언어 중에서 반공변성을 지원하는 언어는 거의 없다.
* 제네릭 프로그래밍에서는 파라미터 반공변성이 중요한 의미를 가진다.

### 함수 타입과 서브타이핑

* 최근의 객체지향 언어들은 이름 없는 메서드를 정의할 수 있게 허용한다.
* 익명 함수, 함수 리터럴, 람다 표현식등의 다양한 이름으로 불린다.
* 이름  없이 메서드를 정의하는 것을 허용하는 언어들은 객체의 타입뿐만 아니라 메서드의 타입을 정의할 수 있게 허용한다.
* 그럼 메서드에 대한 타입을 정의할 수 있다면 함수 타입의 서브타입을 정의할 수 있을까?
* 객체의 서브타입이 슈퍼타입을 대체할 수 있는 것처럼 서브타입 메서드가 슈퍼타입 메서드를 대체할 수 있을까? 대답은 그렇다이다.
* 앞에서 파라미터 타입이 반공변성을 가지고 리턴 타입이 공변성을 가질 경우 메서드가 오버라이딩 가능했다고 했던 것을 기억하자.
* 서브 타입이 슈퍼 타입을 치환할 수 있다는 것은 계약에 의한 설계에서 정의한 계약 규칙과 가변성 규칙을 준수한다는 것을 의미한다.