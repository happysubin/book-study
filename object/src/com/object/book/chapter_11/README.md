# Chapter 11. 합성과 유연한 설계

* 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.
* 상속 관계는 is-a 관계라고 부르고 합성 관계는 has-a 관계라고 부른다.
* 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.
* 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 더 안정적인 코드를 얻을 수 있게 된다.
* 상속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다.
* 물론 상속보다 합성을 이용하는 것이 구현 관점에서 번거로울 수는 있지만, 변경에 유연하게 대처할 수 있는 설계가 보통 정답이다.
* 객체 합성이 클래스 상속보다 더 좋은 방법이다.
* 상속과 합성은 재사용의 대상이 다르다.
* 상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.
* 따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다.
* 다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있다는 것이다.

## part 1. 상속을 합성으로 변경하기

* 10장에서 상속을 남용 했을 때의 3가지 문제를 살펴보았다.
  1. 불필요한 인터페이스 상속 문제
  2. 메서드 오버라이딩의 오작동 문제
  3. 부모 클래스와 자식 클래스의 동시 수정 문제
* 합성을 사용하면 위 3가지 문제를 해결 할 수 있다.
* 상속을 합성으로 바꾸는 법은 매우 단순한데 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.
* 불필요한 인터페이스 상속 문제 예시인 java.util.Properties와 java.util.Stack의 상속 구조를 합성으로 해결하는 과정을 보여줌. p.348
* 메서드 오버라이딩의 오작용 문제 예시인 InstrumentedHashSet의 상속 구조를 합성으로 해결하는 과정을 보여줌. 그 과정에서 자바의 인터페이스도 등장했다.
* 여기에서 포워딩이란 기법이 등장하는데 기존 클래스의 인터페이스를 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 유용한 기법이라고 한다.
* 대부분의 경우 구현에 대한 결합보다는 인터페이스에 대한 결합이 더 좋다. (구체 클래스 결합보다는 인터페이스 결합이 좋다)
* 인터페이스에 의존하면 설계가 유연해진다.

## part 2. 상속으로 인한 조합의 폭발적인 증가

* 상속에서는 아래 두 가지 문제가 발생할 수 있다.
  * 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
  * 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.
* 합성을 사용하면 상속으로 인해 발생하는 클래스의 증가와 중복 코드 문제를 간단하게 해결할 수 있다.
* 10장에서 휴대폰 시스템에 새로운 요구사항을 추가해 예제를 확장한다.
* 지금부터는 핸드폰 요금제가 기본 정책과 부가 정책을 조합해서 구성된다.
* 예를 들어 기본 정책은 일반 요금제, 심야 할인 요금제가 있고 부가 정책은 세금 정책과 기본 요금 할인 정책 등이 있다.
* 기본 정책은 통화량을 기반으로 요금을 계산한다.
* 부가 정책은 다음과 같은 특성을 가진다.
  * 기본 정책의 계산 결과에 적용되며, 선택 적으로 적용할 수 있고, 조합이 가능하며, 부가 정책은 임의의 순서로 적용이 가능하다.
* 그럼 현재의 기본 정책과 부가 정책을 조합해서 만들 수 있는 경우의 수는 10가지나 된다.. 정책  조합의 수가 너무 많다.
* 따라서 설계는 이런 다양한 조합을 수용할 수 있도록 유연해야 한다.

### 상속을 이용해 구현하기

* 상속을 이용해 기본 정책을 구현했다.
* 기본 정책에 세금 정책을 조합했다. 이 방식은 부모 클래스에 추상 메서드를 만들고 자식 클래스에서 이를 오버라이딩 했다.
* TaxableNightlyDiscountPhone과 TaxableRegularPhone 사이에 코드를 중복했다. 부모 클래스의 이름을 제외하고는 코드가 동일하다.
* 대부분의 객체지향 언어는 단일 상속만 지원하므로 상속으로 인해 발생하는 중복 코드 문제를 해결하기가 쉽지 않다.
* 상속 구조를 바탕으로 하면 기본정책과 부가 정책의 조합에 따라 만들 클래스가 정말 너무 많다..
* 새로운 정책을 추가하기 위해서는 불필요하게 많은 수의 클래스를 상속 계층 안에 추가해야 한다. 즉 새로운 정책을 추가하기 어렵다.
* 새로운 기본 정책을 추가하려면 그에 따른 조합 가능한 정책의 수만큼 새로운 클래스를 추가해야 한다. p.367 
* 이처럼 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가하는 경우를 가리켜 클래스 폭발 문제 또는 조합의 폭발 문제라고 부른다.
* 클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생하는 문제다.
* 컴파일 타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에 자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것이다.
* 클래스 폭발 문제는 새로운 기능을 추가할 때뿐만 아니라 기능을 수정할 때도 문제가 된다.
* 만약 세금 정책을 수정하면 세금 정책과 관련된 모든 클래스를 찾아 동일한 방식으로 수정해야 한다.
* 이 클래스 중에서 하나라도 누력한다면 세금이 부가되지 않는 버그가 발생하고 말 것이다.
* 이 문제를 해결하려면 결국 상속을 포기해야 한다.
* (모든 경우의 클래스를 모두 코드로 남기지는 않음. 클래스 폭발 문제에 대해 확실하게 알아두자.)
* 클래스 폭발 문제의 핵심은 클래스가 늘어난다는 것이 아니라 클래스가 늘어날수록 중복 코드도 함께 기하급수적으로 늘어난다는 것이 문제다.

## part 3. 합성 관계로 변경하기

* 상속과 달리 합성은 런타임에 동적으로 변경할 수 있다.
* 합성을 사용하면 컴파일타임 의존성과 런타임 의존성을 다르게 만들 수 있다.
* 클래스 폭발 문제를 해결하기 위해 합성을 사용하는 이유는 런타임에 객체 사이의 의존성을 자유롭게 변경할 수 있기 때문이다.
* 합성을 사용하면 구현 시점에 정책들의 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있게 된다.
* 상속이 조합의 결과를 개별 클래스 안으로 밀어 넣는 방법이라면 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법을 사용하는 것이라고 할 수 있다.

### 기본 정책 합성하기

* 가장 먼저 해야 할 일은 각 정책을 별도의 클래스로 구현하는 것이다.
* 핸드폰이라는 개념으로부터 요금 계산 방법이라는 개념을 분리하자.
* 코드 실습을 진행.
* Phone은 컴파일타임 의존성을 구체적인 런타임 의존성으로 대체하기 위해 생성자를 통해 RatePolicy의 인스턴스에 대한 의존성을 주입받는다.
* 부가 정책을 합성 관계로 적용하는 예제를 보여줌. (p.373)
* 확실히 실습을 통해 보니꺄 합성을 통해 작성해야할 코드의 양이 엄청나게 줄어들었다.
* 제일 중요한 것은 요구사항을 변경할 때 오직 하나의 클래스만 수정해도 된다는 것이다.
* 세금 정책을 변경하기 위해서는 합성의 경우 세금 정책을 변경하기 위해 여러 클래스를 수정해야 했는데, 합성의 경우에는 TaxablePolicy 클래스만 수정하면 된다. 단임 책임 원칙을 준수하고 있는 것이다.

### 객체 합성이 클래스 상속보다 더 좋은 방법이다.

* 상속은 부모 클래스의 세부적인 구현에 자식 클래스를 강하게 결합시키기 때문에 코드의 진화를 방해한다.
* 코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 합성을 이용하는 것이다.
* 상속이 구현을 재사용하는 데 비해 합성은 객체의 인터페이스를 재사용한다.
* 그럼 상속은 언제 사용해야 바람직한 것일까?
* 먼저 상속을 구현 상속과 인터페이스 상속의 두 가지로 나눠야 한다는 사실을 이해해야 한다.
* 그리고 이번 장에서 살펴본 상속에 대한 모든 단점들은 구현 상속에 국한된다. (13장에서 이에 대해 다룬다고 한다.)
* 상속과 합성의 특성을 모두 보유하고 있는 독특한 코드 재사용 방법이 있는데 믹스인이라고 한다.

## part 4. 믹스인

* 구체적인 코드를 재사용하면서도 낮은 결합도를 유지할 수 있는 방법은 재사용에 적합한 추상화를 도입하는 것이다.
* 믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리킨다.
* 합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.
* 믹스인이 상속과 비슷해보이지만 다르다.
* 상속의 진정한 목적은 자식 클래스를 부모 클래스의 동일한 개념적인 범주로 묶어 is-a 관계로 만들기 위한 것이다.
* 반면 믹스인은 말 그대로 코드를 다른 코드 안에 섞어 넣기 위한 방법이다.
* 그러나 상속이 클래스와 클래스 사이의 관계를 고정시키는데 비해 믹스인은 유연하게 관계를 재구성할 수 있다.
* 방법이 무엇이든 코드를 다른 코드 안에 유연하게 섞어 넣을 수 있다면 그것은 믹스인이다.
* 스칼라 언어로 실습을 진행했다. trait이라는 기능을 사용.
* super를 사용하지 말라는 내용을 앞에 장에서 보았는데, 믹스인의 경우는 super 참조가 컴파일 시점에 결정되는 것이 아니라 동적인 시점에 결정된다고 한다.
* 상속은 정적이지만 믹스인은 동적이다.
* 믹스인 내용은 p.379부터
* 믹스인은 추상 서브클래스라고도 부른다.
* 믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있다.
* 믹스인의 이러한 특징을 쌓을 수 있는 변경이라고 부른다.
