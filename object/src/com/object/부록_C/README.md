# 부록 C. 동적인 협력, 정적인 코드

* 프로그래머가 객체지향 프로그램을 작성하기 위해서는 두 가지 모델을 동시에 마음속에 그려야 한다는 것을 의미한다.
* 하나는 프로그램 실행 구조를 표현하는 움직이는 모델이고 또 다른 하나는 코드의 구조를 담는 고정된 모델이다.
* 전자를 동적 모델이라고 부르고 후자를 정적 모델이라고 부른다.

### 도메인 모델

* 도메인이란 사용자가 프로그램을 사용하는 대상 영역을 가리킨다.
* 모델이란 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.
* 도메인 모델이란 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.
* 객체지향 분석 설계에서 제안하는 지침 중 하나는 소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축하는 것이다.
* 이 지침을 따르면 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬운 소프트웨어를 만들 수 있다.
* 중요한 것은 도메인 모델을 작성하는 것이 목표가 아니라 출발점이다.
* 도메인 모델은 소프트웨어를 만드는 데 필요한 개념의 이름과 의미, 그리고 관계에 대한 히트를 제공하는 역할로 끝나야 한다.
* 불행은 도메인 안의 개념이 제공하는 틀에 맞춰서 소프트웨어를 구축해야 한다고 생각할 때부터 시작된다.
* 도메인 모델이 클래스 다이어그램과 같은 정적 모델에 기반해야 한다는 오해 역시 잘못된 코드 구조를 낳는 원인이 된다.
* 도메인 모델이 클래스 다이어그램과 같은 정적인 형태로 표현돼야 한다는 것 역시 오해다.
* 도메인 모델은 여러분의 도메인에 대한 지식을 표현하고 코드의 구조에 대한 힌트를 제공할 수 있다면 어떤 형태로 표현하더라도 상관이 없다.
* 객체 사이의 협력이 도드라지게 보여주는 개념적인 표현 역시 도메인 모델이 될 수 있다.
* 우리에게 중요한 것은 소프트웨어의 기능과 객체의 책임이다.
* 코드의 구조를 이끄는 것은 도메인 안에 정립된 개념의 분류 체계가 아니라 객체들의 협력이다.
* 도메인 안의 개념들을 기반으로 출발하되 객체들의 협력이 도메인 모델에 맞지 않다면 필요한 몇 가지 개념만 남기고 도메인 모델을 과감히 수정하라.
* 도메인 모델에 지나치게 집착하거나 도메인 모델의 초기 구조를 맹목적으로 따르는 코드를 작성하고 있다면 변경하기 어려운 소프트웨어가 만들어질 확률이 높다.

### 몬스터 설계하기

* 초기 도메인 모델은 코드를 작성할 수 있는 훌륭한 출발점을 제공한다.
* 몬스터 예제 코드를 살펴봄.
* 상속 대신 합성을 사용하라는 설계 지침을 보여주는 예제 코드다.
* 설계의 의도라는 측면에서 살펴본다면 중복을 제거하고, 유연성을 향상시키기 위해 합성을 사용했던 핸드폰 요금 시스템의 경우와는 다르다.
* 여기서 합성을 사용한 이유는 몬스터 타입이 추가될 때마다 새 클래스를 추가하고 싶지 않기 때문이다.
* 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방법을 TYPE OBJECT 패턴이라고 한다. Breed의 인스턴스가 Monster의 타입을 구현하는 것이다.

### 행동과 변경을 고려한 도메인 모델

* 우리는 도메인 모델을 먼저 만들고 만들어진 도메인 모델에 표현된 개념과 관계를 기반으로 협력에 필요한 객체의 후보를 도출하고 구현 클래스의 이름과 관계를 설계한다.
* 초기의 도메인 모델은 그저 작업ㅇ르 시작하기 위한 거친 아이디어 덩어리다.
* 초기에 고안한 도메인 모델은 좋은 출발점이 될 수는 있지만 객체의 행동과 변경이라는 요소를 고려하면 빠르게 그 가치가 떨어진다.
* 구현하거나 변경하기 더 쉬운 모델이 떠올랐다면 과감하게 초기 아이디어를 버려라.
* 객체지향의 핵심은 객체 사이의 협력이며 설계는 변경을 위한 것이다. 따라서 행동과 변경을 고려하지 않은 채 도메인 모델을 그대로 따르는 설계는 코드의 유지 보수를 방해할 뿐이다.
* 도메인 모델이 단순히 정적 모델의 형태를 띨 필요가 없으며 도메인 모델의 구조가 코드와 다를 필요가 없다는 것이다.
* 도메인 모델은 코드를 위한 것이다.
* 도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야 하지만 최종 모습은 객체의 행동과 변경에 기반해야 하며 코드의 구조를 반영해야 한다.


