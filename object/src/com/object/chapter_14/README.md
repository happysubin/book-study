# Chapter 13. 서브클래싱과 서브타이핑

* 객체는 협력을 위해 존재하며, 협력은 객체가 존재하는 이유와 문맥을 제공한다.
* 잘 설계된 애플리케이션은 이해하기 쉽고, 수정이 용이하며, 재사용 가능한 협력의 모임이다.
* 객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것이다.
* 객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다.
* 재사용을 위해서는 객체들의 협력 방식을 일관성있게 만들어야 한다.
* 특정한 문제를 유사한 방법으로 해결하고 있다는 사실을 알면 문제를 이해하는 것만으로도 코드의 구조를 예상할 수 있게 된다.
* 객체들의 협력이 전체적으로 일관성 있는 유사한 패턴을 따른다면 시스템을 이해하고 확장하기 위해 요구되는 정신적인 부담을 크게 줄일 수 있다.
* 일관성 있는 협력 패턴을 적용하면 코드가 이해하기 쉽고 직관적이며 유연해진다는 것이 이번장의 주제다.

## part 1. 핸드폰 과금 시스템 변경하기

* 11장에서 구현한 핸드폰 과금 시스템의 요금 정책을 수정.
* 기본 정책이 4가지로 늘어남. 고정요금, 시간대별, 요일별, 구간별. p.472 그림 14.1에서 경우의 수를 나타냄.
* 고정요금 방식 구현.
* 시간대별 방식 구현. 시간대별 방식의 통화 요금을 계산하기 위해서는 통화의 시작 시간과 종료 시간뿐만 아니라 시작 일자와 종료일자도 고려해야 한다.
* 시간대별 방식을 구현하는 데 있어 핵심은 규칙에 따라 통화 시간을 분할하는 방법을 결정하는 것이다.
  1. 통화 기간을 일자별로 분리한다. (기간을 처리하는 전문가는 DATETIMEINTERVAL)
  2. 일자별로 분리된 기간을 다시 시간대별 규칙에 따라 분리한 후 각 기간에 대해 요금을 계산한다. (이에 대한 전문가는 TimeOfDayDiscountPolicy 클래스)
* 요일별 방식도 구현함. 요일별 방식을 구성하는 규칙을 구현해야 한다.
* 구간별 방식도 구현함.
* 현재 제일 큰 문제는 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다.
* 이 클래스들은 기본 정책을 구현한다는 공통의 목적을 공유하지만 정책을 구현하는 방식은 완전히 다르다.
* 다시 말해서 개념적으로는 연관이 있어도 구현 방식에 있어서는 완전히 제각각이다.
* 유사한 기능을 서로 다른 방식으로 구현해서는 안된다. 유사한 기능은 유사한 방식으로 구현해야 한다.
* 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이므로 유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것이다.
* 
