# Chapter 11. 합성과 유연한 설계

* 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일 타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.
* 상속 관계는 is-a 관계라고 부르고 합성 관계는 has-a 관계라고 부른다.
* 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.
* 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 더 안정적인 코드를 얻을 수 있게 된다.
* 상속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다.
* 물론 상속보다 합성을 이용하는 것이 구현 관점에서 번거로울 수는 있지만, 변경에 유연하게 대처할 수 있는 설계가 보통 정답이다.
* 객체 합성이 클래스 상속보다 더 좋은 방법이다.
* 상속과 합성은 재사용의 대상이 다르다.
* 상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.
* 따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다.
* 다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있다는 것이다.

## part 1. 상속을 합성으로 변경하기

* 10장에서 상속을 남용 했을 때의 3가지 문제를 살펴보았다.
  1. 불필요한 인터페이스 상속 문제
  2. 메서드 오버라이딩의 오작동 문제
  3. 부모 클래스와 자식 클래스의 동시 수정 문제
* 합성을 사용하면 위 3가지 문제를 해결 할 수 있다.
* 상속을 합성으로 바꾸는 법은 매우 단순한데 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.
* 불필요한 인터페이스 상속 문제 예시인 java.util.Properties와 java.util.Stack의 상속 구조를 합성으로 해결하는 과정을 보여줌. p.348
* 메서드 오버라이딩의 오작용 문제 예시인 InstrumentedHashSet의 상속 구조를 합성으로 해결하는 과정을 보여줌. 그 과정에서 자바의 인터페이스도 등장했다.
* 여기에서 포워딩이란 기법이 등장하는데 기존 클래스의 인터페이스를 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 유용한 기법이라고 한다.
* 대부분의 경우 구현에 대한 결합보다는 인터페이스에 대한 결합이 더 좋다. (구체 클래스 결합보다는 인터페이스 결합이 좋다)
* 인터페이스에 의존하면 설계가 유연해진다.

## part 2. 상속으로 인한 조합의 폭발적인 증가

* 상속에서는 아래 두 가지 문제가 발생할 수 있다.
  * 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
  * 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.
* 합성을 사용하면 상속으로 인해 발생하는 클래스의 증가와 중복 코드 문제를 간단하게 해결할 수 있다.
* 10장에서 휴대폰 시스템에 새로운 요구사항을 추가해 예제를 확장한다.
* 지금부터는 핸드폰 요금제가 기본 정책과 부가 정책을 조합해서 구성된다.
* 예를 들어 기본 정책은 일반 요금제, 심야 할인 요금제가 있고 부가 정책은 세금 정책과 기본 요금 할인 정책 등이 있다.
* 기본 정책은 통화량을 기반으로 요금을 계산한다.
* 부가 정책은 다음과 같은 특성을 가진다.
  * 기본 정책의 계산 결과에 적용되며, 선택 적으로 적용할 수 있고, 조합이 가능하며, 부가 정책은 임의의 순서로 적용이 가능하다.
* 그럼 현재의 기본 정책과 부가 정책을 조합해서 만들 수 있는 경우의 수는 10가지나 된다.. 정책  조합의 수가 너무 많다.
* 따라서 설계는 이런 다양한 조합을 수용할 수 있도록 유연해야 한다.

### 상속을 이용해 구현하기

* 상속을 이용해 기본 정책을 구현했다.
* 기본 정책에 세금 정책을 조합했다. 이 방식은 부모 클래스에 추상 메서드를 만들고 자식 클래스에서 이를 오버라이딩 했다.
* TaxableNightlyDiscountPhone과 TaxableRegularPhone 사이에 코드를 중복했다. 부모 클래스의 이름을 제외하고는 코드가 동일하다.
* 대부분의 객체지향 언어는 단일 상속만 지원하므로 상속으로 인해 발생하는 중복 코드 문제를 해결하기가 쉽지 않다.
* 상속 구조를 바탕으로 하면 기본정책과 부가 정책의 조합에 따라 만들 클래스가 정말 너무 많다..
* 새로운 정책을 추가하기 위해서는 불필요하게 많은 수의 클래스를 상속 계층 안에 추가해야 한다. 즉 새로운 정책을 추가하기 어렵다.
* 새로운 기본 정책을 추가하려면 그에 따른 조합 가능한 정책의 수만큼 새로운 클래스를 추가해야 한다. p.367 
* 이처럼 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가하는 경우를 가리켜 클래스 폭발 문제 또는 조합의 폭발 문제라고 부른다.
* 클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생하는 문제다.
* 컴파일 타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에 자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것이다.
* 클래스 폭발 문제는 새로운 기능을 추가할 때뿐만 아니라 기능을 수정할 때도 문제가 된다.
* 만약 세금 정책을 수정하면 세금 정책과 관련된 모든 클래스를 찾아 동일한 방식으로 수정해야 한다.
* 이 클래스 중에서 하나라도 누력한다면 세금이 부가되지 않는 버그가 발생하고 말 것이다.
* 이 문제를 해결하려면 결국 상속을 포기해야 한다.
* (모든 경우의 클래스를 모두 코드로 남기지는 않음. 클래스 폭발 문제에 대해 확실하게 알아두자.)
