# Chapter 6. 메시지와 인터페이스

* 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다.
* 더 정확하게 말하면 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다.
* 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것이다.
* 객체지향에서 제일 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지다.
* 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하자.

## part 1. 협력과 메시지
* 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
* 메시지는 객체 사이의 협력을 가능하게 하는 매개체다.
* 메시지를 매개로 하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성한다.
* 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다.
* 협력 안에서 메시지를 전송하는 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.
* 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
* 객체는 협력에 참여하는 동안 클라리언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.
* 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.
* 하나는 객체가 수신하는 메시지의 집합이고, 하나는 외부 객체에게 전송하는 메시지의 집합이다.
* 중요한 점은 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것이다.
* 그리고 두 객체 사이의 협력을 가능하게 해주는 매개체가 바로 메시지라는 것이다.

### 메시지와 메시지 전송
* 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
* 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송, 메시지 패싱이라고 부른다.
* 이때 메시지를 전송하는 객체를 메시지 전송자라고 부르고 메시지를 수신하는 객체를 메시지 수신자라고 부른다.
* 메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.
* isSatisfiedBy(screening) -> 메시지 (오퍼레이션 + 인자) 뭔가 추상 메서드 같기도..?
* condition.isSatisfiedBy(screening) -> 메시지 전송 (메시지 수신자 + 오퍼레이션 + 인자)

### 메시지와 메서드
* 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.
* 즉 메시지를 보내도(추상화를 이용한 추상클래스, 인터페이스의 추상 메서드 이용)해도 구체 클래스의 종류에 따라 실제로 실행되는 코드가 다른 것이다.
* 이처럼 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
* 중요한 것은 코드 상에서 동일한 이름의 변수(condition)에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것이다.
* 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점(런타임)에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
* 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.
* 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다.
* 메시지 수신자 역시 누가 메시지를 전송하는지 알 필요가 없다. 단지 메시지가 도착했다는 사실만 알면 된다.
* 그러면 메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.
* 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 끈을 통해 연결된다.

### 퍼블릭 인터페이스와 오퍼레이션
* 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
* 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다.
* 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.
* 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다. (추상 메서드 같기도 힘.)
* 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.
* 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다. (구체 클래스의 메서드 같다.)
* 인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화다. 메서드는 오퍼레이션에 대한 구현이다.
* 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
* 따라서 퍼블릭 인터페이스와 메시지 관점에서 보면 메서드 호출보다는 오퍼레이션 호출이라는 용어를 사용하는 것이 더 적절하다.

### 시그니처
* 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.
* 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다. 메서드는 이 시그니처에 구현을 더한 것이다.
* 일반적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행된다.
* 다형성을 활용하려면 하나의 오퍼레이션에 다양한 메서드를 구현하는 것이 좋다.
* 따라서 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.
* 자바에서는 메서드 시그니처는 메서드 명과 파라미터의 순서, 타입, 개수다.
* 중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다는 것이다.
* 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.

## part 2. 인터페이스와 설계 품질
* 결국 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.
* 꼭 필요한 것만 제공하고, 어떻게 수행하는지가 아닌 무엇을 하는지를 표현해야 한다.
* 협력의 문맥에 따라 메시지를 먼저 선택하고 메시지가 객체를 선택하게 하면 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.
* 이제는 퍼블릭 인터페이스의 품질에 영향을 미치는 몇가지 원칙과 기법에 대해 살펴보겠다.
  1. 디미터 법칙
  2. 묻지 말고 시켜라
  3. 의도를 드러내는 인터페이스
  4. 명령-쿼리 분리

### 디미터 법칙
* 4단원에서 데이터 중심 & 절차 지향적 코드로 작성한 ReservationAgency 클래스를 분석.
* 제일 큰 문제는 ReservationAgency 클래스가 Screening 클래스의 내부 구조와 너무 강하게 결합되어 있다.
* Screening 클래스에서 변경이 생기면 ReservationAgency 클래스에도 변경하는 부분이 많이 생긴다. 즉 변경에 대한 타격이 너무 크다.
* 이처럼 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙이다.
* 디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.
* 오직 하나의 도트 (.)만 사용하라는 말로 요약되기도 한다.
* 디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야 한다.
* 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.
* 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.
* 디미터 법칙을 위반하는 코드 == screening.getMovie().getDiscountConditions();
* 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다.
* 위와 같은 코드를 기차 충돌(train wreck)이라고 부른다.
* 기차 충돌은 내부 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
* 따라서 메시지 수신자의 캡슐화는 무너지고, 메시지 전송자가 메시지 수신자의 내부 구현에 강하게 결합된다.
* 디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조한다.
* 디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다.

### 묻지말고 시켜라
* ReservationAgency는 Screening 내부의 Movie에 접근하는 대신에 Screening에게 직접 요금을 계산하도록 요청했다.
* 요금을 계산하는 데 필요한 정보를 잘 알고 있는 객체에게 요금을 게산할 책임을 위임한 것이다.
* 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.
* 묻지 말고 시켜라는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.
* 묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.
* 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.
* 묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.
* 묻지 말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.
* 상태를 묻는 오퍼레이션 행동을 요청하는 오퍼레이션으로 대체해라.
* 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관이다.
* 인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지를 서술해야 한다.

### 의도를 드러내는 인터페이스
* 메서드 명명 두 가지 방법
  1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 명명. -> 결론만 말하면 이건 bad (메서드 수준에서 캡슐화 위반, 메서드에 대해 제대로 커뮤니케이션 X)
  2. 어떻게가 아니라 메서드가 무엇을 하는지를 나타내도록 명명. -> good.
* 어떻게 수행하는지는 메서드의 내부 구현을 설명한다.
* 협력을 설계하는 시작부터 메서드 내부 구현에 의해 고민하게 된다.
* 반면 무엇을 하는지를 드러내도록 메서드의 이름을 지으면 객체가 협력 안에서 수행해야 하는 책임에 대해 고민해야 한다.
* 이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들고 결과 적으로 협력하는 클라이언트의 의도에 따라 메서드의 이름을 짓게 된다.
* 메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.
* 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 얻게 되는 것이다.
* 의도를 드러내는 인터페이스를 한 마디로 요약하면 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것이다.

### 함께 모으기
* 1장에서 살펴본 절차지향적 Theater 코드를 살펴봄. 이는 디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스가 적용되지 않음.
* 결론적으로 말하면 Theater가 audience와 ticketSeller 내부에 포함된 객체에 직접 접근하므로 디미터 법칙을 위반한다.
* audience.getBag().minusAmount(ticket.getFee()); == 디미터 법칙 위반. 클라이언트 객체의 개발자가 audience 객체 내부의 구조를 다 알아야함.
* 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다.
* 기억해야할 객체의 내부 구조는 구현에 해당하는 것이다.
* 퍼블릭 인터페이스에 일방적인 게터를 포함시키는 순간 객체의 구현이 퍼블릭 인터페이스를 통해 외부로 새어나가 버리고 만다.
* 따라서 디미터 법칙을 위반한다는 것은 클라이언트에게 구현을 노출한다는 것을 의미하며, 그 결과 작은 요구사항 변경에도 쉽게 무너지는 불안정한 코드를 얻게 된다.
* 디미터 법칙과 묻지 말고 시켜라 원칙에 따라 코드를 리팩터링한 후에 Audience 스스로 자신의 상태를 스스로 제어하게 됐다는 점에 주목하라.
* Audience는 자신의 상태를 스스로 관리하고 결정하는 자율적인 존재가 된 것이다.
* 오퍼레이션의 이름은 협력이라는 문맥을 반영해야 한다. 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야 한다.
* 디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다.
* 묻지 말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.
* 의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러내야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있게 해준다.


## part 3. 원칙의 함정

* 설계를 적절하게 트ㅔ이드오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 가장 중요한 기준이라고 할 수 있다.
* 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라.
* 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.
* 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다.
* 기차 충돌처럼 보여도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면, 그것은 디미터 법칙을 준수 한 것이다.
* 묻지말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과로만 이어지지는 않는다.
* 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.
* 결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.
* 클래스는 하나의 변경 원인만을 가져야 한다.
  * PeriodCondition 클래스를 예시 코드로 보여주는데 이게 정말 좋았다. 메모..!!!
* 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달렸다.
* 객체는 내부를 숨겨야하지만, 자료 구조는 내부를 노출해야하기 때문이다.
* 객체에서 시키는 것이 항상 가능한 것은 아니다. 가끔씩은 물어야 한다.
* 소프트웨어 설계 법칙에 절대적인 법칙은 존재하지 않으며, 원칙을 맹신하지말자.
* 설계는 트레이드 오프의 산물이다. 경우에 따라 적절하게 생각하자.

## part 4. 명령-쿼리 분리 원칙
* 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴이라고 부른다.
* 루틴은 다시 프로시저와 함수로 구분할 수 있다.
* 프로시저와 함수는 부수효과와 반환값의 유무라는 측면에서 명확하게 구분된다.
* 프로시저는 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류다.
* 함수는 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류다.
  * 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  * 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
* 명령과 쿼리는 객체의 인터페이스 츣면에서 프로시저와 함수를 부르는 또 다른 이름이다.
* 객체의 상태를 수정하는 오퍼레이션을 명령이라 부르고 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.
* 명령 == 프로시저, 쿼리 == 함수
* 명령 - 쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.
* 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다. 따라서 명령과 쿼리를 분리하기 위해서는 다음의 두 가지 규칙을 준수해야 한다.
  * 객체의 상태를 변경하는 명령은 반환 값을 가질 수 없다.
  * 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
* 코드로 명령과 쿼리를 모두 실행하는 나쁜 코드 예제를 확인.
* 명령과 쿼리를 뒤 섞으면 실행 결과를 예측하기가 어려워질 수 있다.
* 예시 코드인 isSatisfied 메서드처럼 겉으로 보기에는 쿼리처럼 보이지만 내부적으로 부수효과를 가지는(명령) 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다.
* 명령과 쿼리를 엄격하게 분류하면 객체의 부수효과를 제어하기가 수월하다.
* 쿼리는 객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출하더라도 상관이 없다. 명령을 분리했기 때문.
* 명령과 쿼리를 분류함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다.
* 참조 투명성이란 "어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성"을 의미한다.
* 수학은 참조 투명성을 엄격하게 준수하는 가장 유명한 체계다.
  * 어떤 함수 f(n)이 존재할 때 n의 값으로 1을 대입하면 그 결과가 3이라고 가정하자,
  * f(1) + f(1) = 6
  * f(1) * 2 = 6
  * f(1) - 1 = 2
  * 이제 f(1)의 결 괏값인 3으로 바꿔보자 f(1)을 3으로 바꾸더라도 식의 결과는 변하지 않는다.
  * 3 + 3 = 6
  * 3 * 2 = 6
  * 3 - 1 = 2
  * 이것이 바로 참조 투명성이다.
* f(1)의 값을 항상 3이라고 말할 수 있는 이유는 f(1)의 값이 변하지 않기 때문이다. 불변성을 지닌 것이다.
* 어떤 값이 불변하다는 말은 부수효과가 발생하지 않는다는 말과 동일하다.
* 즉 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다. 여기에는 2가지 장점이 있다.
  * 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
  * 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
* 객체지향 패러다임이 객체의 상태 변경이라는 부수 효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.
* 하지만 명령-쿼리 분리 원칙을 사용하면 이 예외를 조금이나마 줄일 수 있다.
* 부수효과를 가지는 명령과 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누리는 것이다.

### 책임에 초점을 맞춰라.

* 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것이다.
* 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다.
* 그렇다면 디미터 법칙, 묻지 말고 시켜라, 의도를 드러내는 인터페이스, 명령과 쿼리 모든 원칙을 지키는 것이다.
* 모든 방식의 중심에는 객체가 수행할 책임이 위치한다.
* 훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.
* 책임 주도 설계에서는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하기 때문에 협력에 적합한 메시지를 결정할 수 있는 확률이 높아진다.
* 중요한 건 협력에 적합한 객체가 아니라 협력에 적합한 메시지다.