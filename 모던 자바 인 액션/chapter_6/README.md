# chapter 6. 스트림으로 데이터 수집

* 스트림의 중간 연산으 스트림 파이프 라인을 구성하며, 스트림의 요소를 __소비__ 하지 않는다.
* 반면 최종 연산은 스트림의 요소를 소비해서 최종 결과를 도출한다. 최종 연산은 파이프라인을 최적화하면서 계산 과정을 짧게 생략하기도 한다.
* collect 메서드는 다양한 요소 누적 방식을 인수로 받아서 스트림을 최종 결과로 도출하는 리듀싱 연산을 수행할 수 있음을 설명한다.
* 다양한 요소 누적 방식은 Collector 인터페이스에 정의되어 있다.

## section 6.1 컬렉터란 무엇인가?

* Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.
* 이전 5장에서 '각 요소를 리스트로 만들어라'를 의미하는 toList를 Collector 인터페이스의 구현으로 사용했다.
* groupingBy라는 메서드를 사용해 키와 밸류를 가지는 맵 객체를 만들수도 있다.

### 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터

* collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다.
* 구체적으로 설명해서 스트림에 collect를 호출하면 스트림의 요소에 (컬렉터로 파라미터화된) 리듀싱 연산이 수행된다.
* __Collector 인터페이스의 메서드를 어떻게 구현하느냐에 따라 스트림에 어떤 리듀싱 연산을 수행할지 결정된다.__
* Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다.
* 통화별로 트랜잭션을 그룹화하는 리듀싱 예제
  1. 스트림의 각 트랜잭션 탐색
  2. 트랜잭션의 통화 추출
  3. 통화/트랜잭션 쌍을 그룹화 맵으로 추가

### 6.1.2 미리 정의된 컬렉터

* Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.
  * 스트림 요소를 하나의 값으로 리듀스하고 요약.
  * 요소 그룹화.
  * 요소 분할.
* 이 3가지의 예제와 설명을 6장에서 살펴본다.

## section 6.2 리듀싱과 요약

* 5장 예제를 사용해서, Collector 팩토리 클래스로 만든 컬렉터 인스턴스로 어떤일을 할 수 있는지 예제로 살펴봄.
* 컬렉터 (Stream.collect 메서드의 인수)로 스트림의 항목을 컬렉션으로 재구성할 수 있다.
* 좀 더 일반적으로 말해 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다.
* 트리를 구성하는 다수준 맵, 메뉴의 칼로리 합계를 가리키는 단순한 정수 등 다양한 형식으로 결과가 도출될 수 있다.
* Collectors.counting() 메서드를 통해 요리 갯수를 구함.
* Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산함.
* 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용되는데 이러한 연산을 요약이라고 한다.
* Collectors 클래스는 Collectors.summingInt라는 특별한 요약 팩토리 메서드를 제공한다.
* summingInt, summingLong, summingDouble 메서드는 모두 같은 방식으로 동작.
* avaerageInt, averageLong, averageDouble 등으로 다양한 숫자 집합의 평균 계산도 가능하다.
* 컬렉터에 joining 팩토리 메서드를 이용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.
* 범용적인 연산을 가능하게 하는 것은 Collectors의 reducing 메서드다.
* 참고로 가변 컨테이너 관련 직업이면서 병렬성을 확보하려면 collect 메서드로 리듀싱 연산을 구현하는 것이 바람직하다고 한다.
* __실무에서는 문자열을 다룰 때 joining를 사용하는것이 좋다고 한다.__


## section 6.3 그룹화

* Collectors.groupBy를 사용하면 쉽게 메뉴를 그룹화할 수 있다.
* 그룹화된 요소 조작과 다수준 그룹화 예제를 살펴봄. * Collecotrs.groupingBy를 이용해서 항목을 다수준으로 그룹화 할 수 있다.
* 다 외우는건 불가능하고 직접 손으로 치면서 이런게 정도 있다고 알아두고 필요할 때 잘 찾아쓰면 될 것 같다.
* 물론 최대한 기억하고 원리를 기억하도록 노력하자.
* groupingBy로 진짜 SQL 마냥 데이터 뽑는거 보고 놀랐다. 이정도일 줄은..

## section 6.4 분할

* 분할은 분할 함수라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다.
* 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Boolean이다. 결과적으로 그룹화 맵은 최대 두 개의 그룹으로 분류된다.
* partitiongBy와 groupingBy는 굉장히 비슷한 것 같다. 소수 예제와 채식주의자 예제를 살펴봄.

## section 6.5 Collector 인터페이스

* Collector 인터페이스는 리듀싱 연산(즉 컬렉터)를 어떻게 구현할지 제공하는 메서드 집합으로 구성된다.

```
public interface Collector<T, A, R>{
  Supplier<A> supplier();
  BiConsumer<A, T> accumulator();
  Function<A, R> finisher();
  BinaryOperator<A> combiner();
  Set<Characteristics> characteristics();
}
```

* T는 수집될 스트림 항목의 제네릭 형식이다.
* A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다.
* R은 수집 연산 결과 객체의 형식이다. 대개 컬렉션 형식이다.

### 6.5.1 Collector 인터페이스의 메서드 살펴보기

* 우리가 제일 자주 사용하는 toList 메서드를 자세히 알아볼 것이다.
* 이제 Collector 인터페이스에 정의된 5가지 메서드에 대해 살펴보겠다.
* 네 개의 메서드는 collect 메서드에서 실행하는 함수를 반환하는 반면, characteristics 메서드는 collect 메서드가 어떤 최적화를 이용해서 리듀싱 연산을 수행할 것인지 결정하도록 돕는 힌트 특성 집합을 제공한다.

예를 들어 Stream<T>의 요소를 List<T>로 수집하는 ToListCollector<T>라는 클래스를 구현할 수 있따.

```
public class ToListCollector<T> implements Collector<T, List<T>, List<T>>
```

#### supplier 메서드: 새로운 컨테이너 만들기

* supplier 메서드는 빈 결과로 이루어진 supplier를 반환해야 한다.
* 즉, supplier 메서드는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다.
* ToListCollector처럼 누적자를 반환하는 컬렉터에서는 빈 누적자가 비어있는 스트림의 수집 과정의 결과가 될 수 있다.
* ToListCollector에서 supplier는 다음처럼 빈 리스트를 반환한다.

```
public Supplier<List<T>> supplier(){
  return () -> new ArrayList<T>(); 
}
```

#### accumulator 메서드: 결과 컨테이너에 요소 추가하기

* accumulator 메서드는 리듀싱 연산을 수행하는 함수를 반환한다.
* 스트림에서 n번째 요소를 탐색할 때 두 인수, 즉 누적자(스트림 첫 n-1개 항목을 수집한 상태)와 n번째 요소를 함수에 적용한다.
* 함수의 반환값은 void, 즉 요소를 탐색하면서 적용하는 함수에 의해 누적자 내부상태가 바뀌므로 누적자가 어떤 값일지 단정할 수 없다.
* ToListCollector에서 accumulator가 반환하는 함수는 이미 탐색한 항목을 포함하는 리스트에 현재 항목을 추가하는 연산을 수행한다.

```
public BiConsumer <List<T>, T> accumulator(){
  return (list, item) -> list.add(item);
}
```

#### finisher 메서드: 최종 변환값을 결과 컨테이너로 적용하기

* finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다.
* 때로는 ToListCollector에서 볼 수 있는 것처럼 누적자 객체가 이미 최종 결과인 상황도 있다.
* 이런 때는 변환 과정이 필요하지 않으므로 finisher 메서드는 항등 함수를 반환한다.

```
public Function<List<T>, List<T>> finisher(){
  return Function.identity();
}
```

* 지금까지 살펴본 세 가지 메서드로도 순차적 스트림 리듀싱 기능을 수행할 수 있다.
* 실제로는 collect 메서드가 동작하기 전에 다른 중간 연산과 파이프라인을 구성할 수 있게 해주는 게으른 특성 그리고 병렬 실행 등도 고려해야 하므로 스트림 리듀싱 기능 구현은 생각보다 복잡하다.

#### combiner 메셔드: 두 결과 컨테이너 병합

* 마지막으로 리듀싱 연산에서 사용할 함수를 반환하는 네 번째 메서드 combiner다.
* combiner는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다.
* toList의 combiner는 비교적 쉽게 구현할 수 있다. 
* 즉 스트림의 두 번째 서브 파트에서 수집한 항목 리스트를 첫 번째 서브파트 결과 리스트의 뒤에 추가하면 된다.

```
public BinaryOperator<List<T>> combiner(){
  return (list1, list2) -> {
    list1.addAll(list2);
    return list1;
  }
}
```

* 네 번째 메서드를 이용하면 스트림의 리듀싱을 병렬로 수행할 수 있다.
* 스트림의 리듀싱을 병렬로 수행할 때 자바 7의 포크/조인 프레임워크와 추후에 배울 Spliterator를 사용한다.
* 책에서 스트림의 병렬 리듀싱 수행 과정을 살펴봄.
  1. 스트림을 분할해야 하는지 정의하는 조건이 거짓으로 바뀌기 전까지 원래 스트림을 재귀적으로 분할한다.
  2. 모든 서브스트림의 각 요소에 리듀싱 연산을 순차적으로 적용해서 서브스트림을 병렬로 처리할 수 있다.
  3. 마지막에는 컬렉터의 combiner 메서드가 반환하는 함수로 모든 부분결과를 쌍으로 합친다. 즉, 분할된 모든 서브스트림의 결과를 합치면서 연산이 완료된다.

#### Characteristics 메서드

* Characteristics 메서드는 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다.
* Characteristics는 스트림을 병렬로 리듀스할 것인지 그리고 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트를 제공한다.
* Characteristics는 다음 세 항목을 포함하는 열거형이다.
  * UNORDERED: 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않는다.
  * CONCURRENT: 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있다. 컬렉터의 플래그에 UNORDERED를 함께 설정하지 않았다면 데이터 소스가 정렬되어 있지 않은(즉, 집합처럼 요소의 순서가 무의미한)상황에서만 병렬 리듀싱을 수행할 수 있다.
  * IDENTITY_FINISH: finisher 메서드가 반환하는 함수는 단순히 identity를 적용할 뿐이므로 이를 생략할 수 있다. 따라서 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있다. 또한 누적자 A를 결과 R로 안전하게 형변환할 수 있다.
* 지금까지 개발한 ToListCollector에서 스트림의 요소를 누적하는 데 사용한 리스트가 최종 결과 형식이므로 추가 변환이 필요 없다.
* 따라서 ToListCollector는 IDENTITY_FINISH다. 하지만 리스트의 순서는 상관이 없으므로 UNORDERED이다.
* 마지막으로 ToListCollector는 CONCURRENT다. 하지만 요소의 순서가 무의미한 데이터 소스여야 병렬로 실행할 수 있다.

## section 6.6 커스텀 컬렉터를 구현해서 성능 개선하기

* 커스텀 컬렉터로 n까지의 자연수를 소수와 비소수로 분할한다.
* 커스텀 컬렉터를 직접 개발해 성능을 더 개선하는 예제를 진행.

## section 6.7 마치며

* collect는 스트림의 요소를 요약 결과로 누적하는 다양한 방법(컬렉터라 불리는)인수로 갖는 최종 연산이다.
* 스트림의 요소를 하나의 값으로 리듀스하고 요약하는 컬렉터ㅃ뿐 아니라 최솟값, 최댓값, 평균값을 계산하는 컬렉터 등이 미리 정의되어 있다.
* 미리 정의된 컬렉터인 groupingBy로 스트림의 요소를 그룹화하거나, partitioningBy로 스트림의 요소를 분할할 수 있다.
* 컬렉터는 다수준의 그룹화, 분할, 리듀싱 연산에 적합하게 설계되어 있다.
* Collector 인터페이스에 정의된 메서드를 구현해서 커스텀 컬렉터를 개발할 수 있다.
