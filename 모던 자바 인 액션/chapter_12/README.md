# chapter 12. 새로운 날짜와 시간 API

## section 12.1 LocalDate, LocalTime, Instant, Duration, Period 클래스

### 12.1.1 LocalDate와 LocalTime 사용

* LocalDate 인스턴스는 시간을 제외한 날짜를 표현하는 불변 객체다.
* 특히 LocalDate 객체는 어떤 시간대 정보도 포함하지 않는다.
* 정적 팩토리 메서드 of로 LocalDate 인스턴스를 만들 수 있다.
* 팩토리 메서드 now는 시스템 시계의 정보를 이용해서 현재 날짜 정보를 만든다.
* 시간(13: 52 : 22 같은 시간)은 LocalTime 클래스로 표현할 수 있다.
* 오버로드 버전의 두 가지 정적 메서드로 of로 LocalTime 인스턴스를 만들 수 있다.
* 즉, 시간과 분을 인수로 받는 of 메서드와 시간과 분, 초를 인수로 받는 of 메서드가 있다.
* 날짜와 시간 문자열로 LocalDate와 LocalTime의 인스턴스를 만드는 방법도 있다.
* parse 정적 메서드를 사용할 수 있다. parse 메서드에는 DateTimeFormatter를 전달할 수도 있다.
* DateTimeFormatter의 인스턴스튼 날짜, 시간 객체의 형식을 지정한다.

### 12.1.2 날짜와 시간 조합

* LocalDateTime은 LocalDate와 LocalTime을 쌍으로 갖는 복합 클래스다. 날짜와 시간을 모두 표현한다.
* LocalDate와 LocalTime을 합쳐서 LocalDateTime 클래스 인스턴스를 만들수도 있고, LocalDateTime 인스턴스에서 LocalDate와 LocalTime 인스턴스를 추출할 수 있다.

### 12.1.3 Instant 클래스 : 기계의 날짜와 시간

* 사람은 보통 주, 날짜, 시간, 분으로 날짜와 시간을 계산한다.
* 하지만 기계에서는 이와 같은 단위로 시간을 표현하기는 어렵다.
* 기계의 관점에서는 연속된 시간에서 특정 지점을 하나의 큰 수로 표현하는 것이 가장 자연스러운 시간 표현 방법이다.
* java.time.Instant 클래스에서는 이와 같은 기계적인 관점에서 시간을 표현한다.
* 즉 Instant 클래스는 유닉스 에포크 시간을 기준으로 특정 지점까지의 시간을 초로 표현한다.
* 팩토리 메서드 ofEpochSecond에 초를 넘겨줘서 Instant 클래스 인스턴스를 만들 수 있다.
* 또한 오버로드된 ofEpochSecond 메서드 버전에서는 두 번째 인수를 이용해서 나노초 단위로 시간을 보정할 수 있다.
* LocalDate 등을 포함하여 사람이 읽을 수 있는 날짜 시간 클래스에서 그랬던 것처럼 Instant 클래스도 사람이 확인할 수 있도록 시간을 표시해주는 정적 팩토리 메서드 now를 제공한다.
* Instant는 기계 전용의 유틸리티다. 즉 초와 나노초 정보를 포함한다. 따라서 사람이 읽을 수 있는 시간 정보를 제공하지 않는다.

### 12.1.4 Duration과 Period 정의

* 지금까지 살펴본 모든 클래스는 Temporal 인터페이스를 구현한다. Temporal 인터페이스는 특정 시간을 모델링하는 객체의 값을 어떻게 읽고 조작할지 정의한다.
* 이번에는 두 시간 객체 사이의 지속시간 duration 클래스에 대해 알아본다.
* Duration 클래스의 정적 팩토리 메서드 between으로 두 시간 객체 사이의 지속 시간을 만들 수 있다.
* 두 개의 LocalTime, 두 개의 LocalDateTime, 또는 두 개의 Instant로 Duration을 만들 수 있다.
* LocalDateTime은 사람이 사용하도록, Instant는 기계가 사용하도록 만들어진 클래스로 두 인스턴스는 서로 혼합할 수 없다.
* 또한 Duration 클래스는 초와 나노초로 시간 단위를 표현하므로 between 메서드에서는 LocalDate를 사용할 수 없다.
* 년, 원, 일로 시간을 표현할 때는 Period 클래스를 사용한다.
* 즉 Period 클래스의 팩토리 메서드 between을 이용하면 두 LocalDate의 차이를 확인할 수 있다.
* Period, Duration도 다양한 정적 팩토리 메서드를 제공한다.

위에서 확인한 클래스는 모두 불변 클래스다.

## section 12.2 날짜 조정, 파싱, 포매팅

* withAttribute 메서드로 기존의 LocalDate의 속성을 바꾸면 새로운 객체를 반환한다. 
* 모든 메서드는 기존 객체를 바꾸지 않고 새로운 객체를 반환한다.

### 12.2.1 TemporalAdjusters 사용하기

* 복잡한 날짜 조정 기능이 필요한 순간에는 TemporalAdjuster를 with 메서드에 전달하는 것이 유용하다.
* 자바에서는 TemporalAdjusters 클래스에서 정의하는 정적 팩토리 메서드를 사용해 날짜와 다양한 기능을 사용할수 있다.
* p.399에 TemporalAdjusters 클래스에 정의된 팩토리 메서드 표가 있다.
* TemporalAdjuster 함수형 인터페이스를 이용하면 우리가 만든 람다, 익명 클래스, 구현 클래스를 사용해 좀 더 복잡한 날짜 조정 기능을 직관적으로 사용할 수 있다.

### 12.2.2 날짜와 시간 객체 출력과 파싱

* 날짜와 시간 관련 작업에서 포매팅과 파싱은 서로 떨어질 수 없는 관계다. 심지어 포매팅과 파싱 전용 패키지인 java.time.format이 새로 추가 되었다.
* 이 패키지에서 제일 중요한 클래스는 DateTimeForamtter이다.
* 정적 팩토리 메서드와 상수를 이용해서 손쉽게 포매터를 만들 수 있다.
* DateTimeFormatter는 다양한 상수를 정의하고 있고, 날짜나 시간을 특정 형식의 문자열로 만들 수 있다.
* 반대로 문자열을 파싱해서 날짜 객체를 만들 수도 있다. 이때는 parse 메서드를 사용하면 된다.
* 모든 DateTimeFormatter은 스레드에서 안전하게 사용할 수 있다.
* 또한 DateTimeForamtter 클래스는 특정 패턴으로 포매터를 만들 수 있는 정적 팩토리 메서드도 제공한다. ofPattern 메서드다.
* LocalDate format 메서드는 요청 형식의 패턴에 해당하는 문자열을 생성한다.
* 그리고 정적 메서드 parse는 같은 포매터를 적용해서 생성된 문자열을 파싱함으로써 다시 날짜를 생성한다.
* ofPattern 메서드도 Local로 포매터를 만들 수 있도록 오버로드된 메서드를 제공한다.
* DateTimeFormatterBuilder 클래스로 대소문자를 구분하는 파싱, 관대한 규칙을 적용하는 파싱, 패딩, 포매터의 선택사항등을 활용할 수 있다. 즉 더 세부적으로 포매터를 제어할 수 있다.

## section 12.3 다양한 시간대와 캘린터 활용 방법

* 기존의 java.util.TimeZone을 대체할 수 있는 java.time.ZoneId 클래스가 등장했다.
* 새로운 클래스를 이용하면서 서머타임 같은 복잡한 사항이 자동으로 처리된다. 
* ZoneId 클래스도 불변 클래스다.

### 12.3.1 시간대 사용하기

* 표준 시간이 같은 지역을 묶어서 시간대 규칙 집합을 정의한다.
* ZonRules 클래스에는 약 40개 정도의 시간대가 있다.
* ZoneId의 getRules()를 이용해서 해당 시간대의 규정을 획득할 수 있다. 지역 Id로 특정 ZonedId를 구분한다.
* 지역 Id는 지역/도시 형식으로 이루어지며 IANA Zone Database에서 제공하는 지역 집합 정보를 사용한다.
* ZoneId의 새로운 메서드인 toZoneId로 기존의 TimeZone 객체를 ZoneId 객체로 변환할 수 있다.
* ZoneId를 얻은 다음에는 LocalDate, LocalDateTime, Instant를 이용해서 ZonedDateTime 인스턴스로 변환할 수 있다.
* ZoneDateTIme은 지정한 시간대에 상대적인 시점을 표현한다.

### 12.3.2 UTC/Greenwich 기준의 고정 오프셋

* 때로는 UTC/GMT를 기준으로 시간대를 표현하기도 한다.
* ZoneOffset으로도 시간차를 표현할 수 있지만 서머타임을 제대로 처리할 수 없으므로 권장하는 방식은 아니다.

### 12.3.3 대안 캘린더 시스템 사용하기

* ISO-8601 캘린더 시스템은 실질적으로 전 세계에서 통용된다.
* 자바는 추가로 ThaiBuddhisDate, MinguoDate, JapaneseDate, HijrahDate 4개의 클래스가 각각의 캘린더 시스템을 대표한다.
* 위 4개의 클래스와 LocalDate 클래스는 ChronoLocalDate 인터페이스를 구현한다.
* ChronoLocalDate는 임의의 연대기에서 특정 날짜를 표현할 수 있는 기능을 제공하는 인터페이스다.a
* LocalDate를 이용해서 이들 4개의 클래스 중 하나의 인스턴스를 만들 수 있다.
* 특정 Local과 Locale에 대한 날짜 인스턴스로 캘린터 시스템을 만드는 방법도 있다.
* 그러나 날짜와 시간 API의 설계자는 LocalDate를 사용하라고 권고한다. 그냥 이걸 늘 사용한다고 기억하자.

## section 12.4 정리

* 자바 8 이전 버전에서 제공하는 기존의 java.util.Date 클래스와 관련 클래스에서는 여러 불일치점들과 가변성, 어설픈 오프셋, 기본 값, 잘못된 이름 결정 등의 설계 결함이 존재했다.
* 새로운 날짜와 시간 API에서 날짜와 시간 객체가 모두 불변이다.
* 새로운 API는 각각 사람과 기계가 편리하게 날짜와 시간 정보를 관리할 수 있도록 두 가지 표현 방식을 제공한다.
* 날짜와 시간 객체를 절대적인 방법과 상대적인 방법으로 처리할 수 있으며 기조 인스턴스를 변환하지 않도록 처리 결과로 새로운 인스턴스가 생성된다.
* TemporalAdjuster를 이용하면 단순히 값을 바꾸는 것 이상의 복잡한 동작을 수행할 수 있으며 자신만의 커스텀 날짜 변환 기능을 정의할 수 있다.
* 날짜와 시간 객체를 특정 포맷으로 출력하고 파싱하는 포매터를 정의할 수 있다. 패턴을 이용하거나 프로그램으로 포매터를 만들 수 있으며 포매터는 스레드 안전성을 보장한다.
* 특정 지역/장소에 상대적인 시간대 또는 UTC/GMT 기준의 오프셋을 이용해서 시간대를 정의할 수 있으며 이 시간대를 날짜와 시간 객체에 적용해서 지역화할 수 있다.
* ISO-8601 표준 시스템을 준수하지 않는 캘린터 시스템도 사용할 수 있다.