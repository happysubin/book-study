# chapter 15. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

병렬성이 아니라 동시성을 필요로 하는 상황 즉 조금씩 연관된 작업을 같은 CPU에서 동작하는 것 또는 애플리케이션을 생산성을 극대화할 수 있도록 코어를 바쁘게 유지하는 것이 목표라면,
원격 서비스나 데이터베이스 결과를 기다리는 스레드를 블록함으로 연산 자원을 낭비하는 일은 피해야 한다.
 
자바는 이런 환경에서 사용할 수 있는 두 가지 주요 도구를 제공한다.

1. 첫 번째 방안은 Future 인터페이스로 자바 8의 CompletableFuture 구현은 간단하고 효율적인 문제 해결사다.
2. 최근 자바 9에 추가된 발행 구독 프로토콜에 기반한 리액티브 프로그래밍 개념을 따르는 플로 API는 조금 더 정교한 프로그래밍 접근 방법을 제공한다.

동시성은 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성으로 실행이 서로 겹칠 수 있는 반면 병렬성은 병렬 실행을 하드웨어 수준에서 지원한다.

<br>

## section 15.1 동시성을 구현하는 자바 지원의 진화

* 처음에 자바는 Runnable과 Thread를 동기화된 클래스와 메서드를 이용해 잠갔다.
* 2004년 자바 5는 좀 더 표현력있는 동시성을 지원하는 특히 스레드 실행과 태스크 제출을 분리하는 ExecutorService 인터페이스, 높은 수준의 결과 즉, Runnalbe, Thread의 변형을 반환하는 Callable<T> and Future<T>, 제네릭 등을 지원 했다.
* ExecutorServices는 Runnable과 Callable 둘 다 실행할 수 있다.
* 이런 기능들 덕분에 다음 해부터 등장한 멀티코어 CPU에서 쉽게 병렬 프로그래밍을 구현할 수 있게 되었다.

자바는 Future를 조합하는 기능을 추가하면서 동시성을 강화했고, 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원한다.
 
API는 매쉬업 애플리케이션 즉, 다양한 웹 서비스를 이용하고 이들 정보를 실시간으로 조합해 사용자에게 제공하거나 추가 웹 서비스를 통해
제공하는 종류의 애플리케이션을 개발하는데 필수적인 기초 모델과 툴킷을 제공한다.
 
이 과정을 __리액티브 프로그래밍__ 이라 부르며 자바 9에서는 발행-구독 프로토콜로 이를 지원한다. 
CompletableFuture와 java.util.concurrent.Flow의 궁극적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다.

### 스레드와 높은 수준의 추상화

운영체제는 주기적으로 번갈아가며 각 프로세스
 
프로세스는 운영체제에 한 개 이상의 스레드 즉, 본인이 가진 프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로 태스크를 동시에 또는 협력적으로 실행할 수 있다.

멀티코어 설정(한 사용자 프로세스만 실행하는 한명의 사용자 노트북)에서는 스레드의 도움 없이 프로그램이 노트북의 컴퓨팅 파워를 모두 활용할 수 없다.
각 코어는 한 개 이상의 프로세스나 스레드에 할당될 수 있지만 프로그램이 스레드를 사용하지 않는다면 효율성을 고려해 여러 프로세서 코어 중 한 개만을 사용할 것이다.

7장에서 살펴본 것처럼 병렬 스트림 반복은 명시적으로 스레드를 사용하는 것에 비해 높은 수준의 개념이라는 사실을 알 수 있다.
다시 말해 스트림을 이용해 스레드 사용 패턴을 추상화할 수 있다.

* 스트림을 추상화하는 것은 디자인 패턴을 적용하는 것과 비슷하지만 대신 쓸모 없는 코드가 라이브러리 내부로 구현되면서 복잡성도 줄어든다는 장점이 더해진다.
* 자바 7의 RecursiveTask 지원 덕분에 포크/조인 스레드 추상화로 분할 그리고 정복 알고리즘을 병렬화하면서 멀티코어 머신에서 배열의 합을 효율적으로 계산하는 높은 수준의 방식을 제공한다.

### Executor와 스레드 풀

자바 5는 Executor 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 자바 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공했다.
 
* 자바 스레드는 직접 운영체제 스레드에 접근한다.
* 운영체제 스레드를 만들고 종료하려면 비싼 비용을 치러야 한다. 또한 운영체제 스레드의 숫자는 제한되어 있다.
* 운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방식으로 크래시될 수 있으므로 기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다.

보통 운영체제와 자바의 스레드 개수가 하드웨어 스레드 개수보다 많으므로 일부 운영체제 스레드가 블록되거나 자고 있는 상황에서 모든 하드웨어 스레드가 코드를 실행하도록 할당된 상황에 놓을 수 있다.
* 주어진 프로그램에서 사용할 최적의 자바 스레드 개수는 사용할 수 있는 하드웨어 코어의 개수에 따라 달라진다.
 
자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다.
프로그램은 newFixedThreadPool 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다.

```
ExecutorService newFixedThreadPool(int nThreads);
```

이 메서드는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다.

* 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행한다.
* 이들은 태스크 실행이 종료되면 이들 스레드를 풀로 반환한다.
* 이 방식의 장점은 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다.
* 큐의 크기 조정, 거부 정책, 태스크 종류에 따른 우선순위 등 다양한 설정을 할 수 있다.

프로그래머는 태스크(Runnable, Callable)를 제공하면 스레드가 이를 실행한다.

스레드 풀을 사용하면 두 가지를 주의해야 한다.

1. 잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다.
   * I/O를 기다리는 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만 아무 작업도 하지 않게 된다.
   * 처음 제출한 태스크가 기존 실행 중인 태스크가 나중의 태스크 제출을 기다리는 상황이라면 데드락에 걸릴 수 있다.
   * 핵심은 블록할 수 있는 태스크는 스레드 풀에 제출하지 말아야한다는 것이지만 이를 항상 지킬 수는 없다.
2. 플그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다.

### 스레드의 다른 추상화: 중첩되지 않은 메서드 호출

메서드 호출자에 기능을 제공하도록 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드를 비동기 메서드라고 한다.

이들 메서드를 사용할 때는 다음과 같은 위험이 따른다.

* 스레드 실행은 메서드를 호출한 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않도록 주의해야 한다.
* 기존 실행 중이던 스레드가 종료되지 않은 상황에서 자바의 main 메서드가 반환되면 어떻게 될까? 다음 두 가지 방법이 있는데, 어느 방법도 안전하지 못하다.
  * 애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼 때까지 기다린다.
  * 애플리케이션 종료를 방해하는 스레드를 강제종료시키고 애플리케이션을 종료한다.

자바 스레드는 setDaemon 메서드를 이용해 데몬 또는 비데몬으로 구분시킬 수 있다.

데몬 스레드는 애플리케이션이 종료될 때 강제 종료되므로 디스크의 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용하게 활용할 수 있는 반면, 
main 메서드는 모든 비데몬 스레드가 종료될 때까지 프로그램을 종료하지 않고 기다린다.

### 스레드에 무엇을 바라는가?

일반적으로 모든 하드웨어 스레드를 활용해 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉, 프로그램을 작은 태스크 단위로 구조화하는 것이 목표다.
그러나 태스크 변환 비용을 고려해 너무 작은 크기는 아니어야 한다.

<br>

## section 15.2 동시 API와 비동기 API

코드 실습을 진행했다.

1. 먼저 직접 스레드를 생성해서 태스크를 수행했다.
2. 다음으로는 ExecutorService로 스레드 풀을 설정하고 태스크를 수행했다.

이 두개의 문제점은 명시적인 submit 메서드 호출 같은 불필요한 코드로 오염되어있다는 것이다.
명시적 반복으로 병렬화를 수행하던 코드를 스트림을 이용해 내부 반복으로 바꾼 것처럼 비슷한 방법으로 이 문제를 해결해야 한다.
 
문제의 해결은 __비동기 API__라는 기능으로 API를 바꿔서 해결할 수 있다.


### Future 형식 API

첫 번째 대안은 Future를 이용하면 문제를 개선할 수 있다. 단순히 리턴 타입을 Future로 변경했다.

### 리액티브 형식 API

두 번째 대안은 콜백 형식의 프로그래밍을 이용하는 것이다.

* 처음에는 이상해 보인다. f가 값을 반환하지 않는데 어떻게 프로그램이 동작할까?
* __f에 추가 인수로 콜백(람다)을 전달해서 f의 바디에서는 return 문으로 결과를 반환하는 것이 아니라 결과가 준비되면 이를 람다로 호출하는 태스크를 만드는 것이 비결이다.__
* 다시말해 f는 바디를 실행하면서 태스크를 만든 다음 즉시 반환하므로 코드 형식이 예제처럼 바뀐다.

이제 결과가 달라졌다.

* f와 g의 호출 합계를 정확하게 출력하지 않고 상황에 따라 먼저 계산된 결과를 출력한다.
* 락을 사용하지 않으므로 값을 두 번 출력할 수 있을 뿐더러 때로는 +에 제공된 두 피연산자가 println이 호출되기 전에 업데이트될 수도 있다.
* 다음처럼 두 가지 방법으로 이를 보완할 수 있다.
    * if-then-else를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 println을 호출해 원하는 기능을 수행할 수 있다.
    * 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 Future를 이용하는 것이 더 적절하다.

리액티브 형식의 비동기 API는 자연스럽게 일련의 값(나중에 스트림으로 연결)을, Future 형식의 API는 일회성의 값을 처리하는 데 적합하다.

두 방식의 API를 사용하면 코드를 높은 수준의 코드 구조를 유지할 수 있고, 시간이 오래걸리는 메서드에 이들 API를 사용하면 효율성이 향상된다.

### 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주

스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막는다. 즉 자원을 소비하는 것이다. 이는 잠자는 스레드 뿐만 아니라 모든 블록 동작도 마찬가지다.
 
이상적으로는 절대 태스크에서 기다리는 일을 만들지 말거나 아니면 코드에서 예외를 일으키는 방법으로 이를 처리할 수 있다.
 
* 실습에서 코드 A와 B를 비교했다. A는 자는 스레드, B는 스케줄링
* 결론은 B가 더 좋은 코드다.
* A는 잠자는 스레드라서 귀중한 스레드 자원을 점유하는 반면, B는 다른 작업이 실행될 수 있도록 허용하기 때문이다.

태스크를 만들때는 이런 특징을 잘 활용해야 한다. 태스크가 실행되면 귀중한 자원을 점유하므로 태스크가 끝나서 자원을 해제하기 전까지 태스크를 계속 실행해야 한다.
태스크를 블록하는 것보다는 다음 작업을 태스크로 제출하고 현재 태스크는 종료하는 것이 바람직하다.

I/O 작업에도 이 원칙을 적용하는 것이 좋다. 고전적으로 읽기 작업을 기다리는 것이 아니라 블록하지 않는 '읽기 시작' 메서드를 호출하고 읽기 작업이 끝나면 이를 처리할 다음 태스크를 런타임 라이브러리에 스케줄하도록 요청하고 종료한다.
 
이런 디자인 패턴을 따르려면 읽기 어려운 코드가 많아지는 것처럼 보일 수 있다.
하지만 15.4과 16장에서 설명하는 자바 CompletableFuture 인터페이스는 이전에 살펴본 Future에 get()을 이용해 명시적으로 블록하지 않고 콤비네이터를 사용함으로 이런 형식의 코드를 런타임 라이브러리 내에 추상화한다.
 
마지막으로 스레드의 제한이 없다면 코드 A와 B는 같다. 스레드에 제한이 있고 저렴하지 않으므로 잠을 자거나 블록해야할 태스크가 있을 때 가능하면 B 형식이 좋다.

### 현실성 확인

자바의 개선된 동시성 API를 이용해 유익을 얻을 수 있는 상황을 찾아보고 모든 API를 비동기로 만드는 것을 따지지 말고 개선된 동시성 API를 사용해보는 것을 권장한다고 한다.

모든 것을 비동기로 하지 말라는 뜻이다.

### 비동기 API에서 예외는 어떻게 처리하는가?

Future나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의 실행 범위와는 관계가 없는 상황이 된다.
예상치 못한 일이 발생하면 예외를 발생시켜 다른 동작이 실행되어야 한다. 어떻게 이를 실현할까?

Future를 구현한 CompletableFuture에서는 런타임 get() 메서드에 예외를 처리할 수 있는 기능을 제공하며 예외에서 회복할 수 있도록 exceptionall() 같은 메서드도 제공한다.

리액티브 형식의 비동기 API에서는 return 대신 기존 콜백이 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야 한다.

콜백이 여러 개면 이를 따로 제공하는 것보다는 한 객체로 메서드를 감싸는 것이 좋다.

* 예를 들어 자바 9 플로 API에서는 여러 콜백을 한 객체를 감싼다.
* 값이 있을 때, 도중에 에러가 발생했을 때, 값을 다 소진했거나 에러가 발생해서 더 이상 처리할 데이터가 없을 때 각각의 콜백이 호출된다.

이런 호출을 메시지 또는 이벤트라고 부른다.
 
이런 이벤트를 API의 일부로 보자면 API는 이벤트 순서(채널 프로토콜)에는 전혀 개의치 않는다.


<br>

## section 15.3 박스와 채널 모델

동시성 모델을 가장 잘 설계하고 개념화하려면 그림이 필요하다. 우리는 이 기법을 박스와 채널 모델이라고 부르자.

![KakaoTalk_Photo_2023-10-23-18-13-42](https://github.com/happysubin/book-study/assets/76802855/92bdb4a5-bd08-43d5-8b24-9d000a4d46ba)

* 시스템에서 많은 작업이 동시에 실행되고 있지 않다면 이 방식도 잘 동작할 수 있다.
* 하지만 시스템이 커지고 각각의 많은 박스와 채널 다이어그램이 등장하고 각각의 박스는 내부적으로 자신만의 박스와 채널을 사용한다면 얘기가 달라진다.
* 많은 태스크가 get() 메서드를 호출해 Future가 끝나기를 기다리는 상태에 놓일 수도 있다.
* 결과적으로 하드웨어의 병렬성을 제대로 활용하지 못하거나 심지어 데드락에 걸릴 수 있다.

__자바 8에서는CompletableFuture와 콤비네이터를 이용해 문제를 해결한다.__

* 박스와 채널 모델을 이용해 생각과 코드를 구조화할 수 있다.
* 박스와 채널 모델로 대규모 시스템 구현의 추상화 수준을 높일 수 있다.
* 박스로 원하는 연산을 표현하면 계산을 손으로 코딩한 결과보다 더 효율적이다.
* 콤비네이터는 수학적 함수 뿐 아니라 Future와 리액티브 스트림 데이터에도 활용할 수 있다.
* 박스와 채널 모델은 병렬성을 직접 프로그래밍하는 관점을 콤비네이터를 이용해 내부적으로 작업을 처리하는 관점으로 바꿔준다.
* 마찬가지로 자바 8 스트림은 자료 구조를 반복해야 하는 코드를 내부적으로 작업을 처리하는 스트림 콤비네이터로 바꿔준다.

<br>

## section 15.4 CompletableFuture와 콤비네이터를 이용한 동시성

자바 8에서는 Future 인터페이스의 구현인 CompletableFuture를 이용해 Future를 조합할 수 있는 기능을 추가했다.

그럼 ComposableFuture가 아니라 CompletableFuture라고 부르는 이유는 뭘까?

* 일반적으로 Future는 실행해서 get()으로 결과를 얻을 수 있는 Callable로 만들어진다.
* 하지만 CompletableFuture는 실행할 코드 없이 Future를 만들 수 있도록 허용한다.
* 또한 complete() 메서드를 이용해 나중에 어떤 값을 이용해 다른 스레드가 이를 완료할 수 있고 get() 으로 값을 얻을 수 있도록 허용한다.

예제 코드는 f(x)의 실행이 끝나지 않거나 아니면 g(x)의 실행이 끝나지 않는 상황에서 get()을 기다려야하므로 프로세싱 자원을 낭비할 수 있다.

자바 8의 CompletableFuture를 이용하면 이 상황을 해결할 수 있다.

* CompletableFuture<T>에 thenCombine 메서드를 사용함으로 두 연산 결과를 더 효과적으로 더 할 수 있다.

```
CompletableFuture<V> thenCombine(CompletionStage<U> other, BiFunction<T, U, V> fn) 
```

위 메서드는 두 개의 CompletableFuture 값(T,U 결과 형식)을 받아 한 개의 새 값을 만든다.

* 처음 두 작업이 끝나면 두 결과 모두에 fn을 적용하고 블록하지 않은 상태로 결과 Future를 반환한다.

```java
public class CFCombine {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        int x = 1337;

        CompletableFuture<Integer> a = new CompletableFuture<>();
        CompletableFuture<Integer> b = new CompletableFuture<>();

        CompletableFuture<Integer> c = a.thenCombine(b, (y, z) -> y + z);

        executorService.submit(() -> a.complete(f(x)));
        executorService.submit(() -> b.complete(g(x)));

        System.out.println(c.get());
        executorService.shutdown();


    }

    private static Integer f(int x) {
        return x;
    }

    private static Integer g(int x) {
        return x;
    }
}

```

* thenCombine 행이 핵심이다.
* Future a와 Future b의 결과를 알지 못한 상태에서 thenCombine은 두 연산이 끝았을 때 스레드 풀에서 실행된 연산을 만든다.
* 결과를 추가하는 세 번째 연산 c는 다른 두 작업이 끝날 때까지는 스레드에서 실행되지 않는다. (먼저 시작해서 블록되지 않는 점이 특징)
* 따라서 기존의 두 가지 버전의 코드에서 발생했던 블록 문제가 어디서도 일어나지 않는다.

상황에 따라서는 get()을 기다리는 스레드가 큰 문제가 되지 않으므로 기존 자바 8의 Future를 이용한 방식도 해결 방법이 될 수 있다.
하지만 어떤 상황에서는 많은 수의 Future를 사용해야 한다.

이런 상황에서는 CompletableFuture와 콤비네이터를 이용해 get() 에서 블록하지 않을 수 있고 그렇게 함으로 병렬 실행의 효율성은 높이고 데드락은 피하는 최상의 해결책을 구현할 수 있다.

<br>

## section 15.5 발행-구독 그리고 리액티브 프로그래밍

Future와 CompletableFuture은 독립적 실행과 병렬성이라는 정식적 모델에 기반한다. 연산이 끝나면 get()으로 Future의 결과를 얻을 수 있다.
따라서 Future는 한 번만 실행해 결과를 제공한다.

반면 리액티브 프로그래밍은 시간이 흐르면서 여러 Future 같은 객체를 통해 여러 결과를 제공한다.

> 온도계 객체를 예시로 들어보자. 이 객체는 매 초마다 온도 값을 반복적으로 제공한다. 또 다른 예로 웹 서버 컴포넌트 응답을 기다리는 리스너 객체를 생각할 수 있다.
> 이 객체는 네트워크에 HTTP 요청이 발생하길 기다렸다가 이후에 결과 데이터를 생산한다.
> 그리고 다른 코드에서 온도 값 또는 네트워크 결과를 처리한다.
> 그리고 온도계와 리스너 객체는 다음 결과를 처리할 수 있도록 온도 결과나 다른 네트워크 요청을 기다린다.

눈 여겨봐야할 두 가지 사실이 있다.

* 이 두 예제에서 Future와 같은 동작이 모두 사용되었지만 한 예제에서는 한 번의 결과가 아니라 여러 변의 결과가 필요하다.
* 두 번째 예제에서 눈여겨봐야 할 또 다른 점은 모든 결과가 똑같이 중요한 반면 온도계 예제에서는 대부분의 사람에게 가장 최근의 온도만 중요하다.
* 이런 종류의 프로그래밍을 리액티브라 부르는 이유는 무엇일까?

이는 낮은 온도를 감지했을 때 이에 __반응__ 하는 부분이 존재하기 때문이다.

자바 9에서는 java.util.concurrent.Flow의 인터페이스에 발행-구독 모델을 적용해 리액티브 프로그래밍을 제공한다.
간단히 다음 처럼 세 가지로 플로 API를 정리할 수 있다.

* 구독자가 구독할 수 있는 발행자
* 이 연결을 구독이라고 한다.
* 이 연결을 이용해 메시지(이벤트)를 전송한다.

### 두 플로를 합치는 예제

예제는 code 폴더를 참고.

데이터가 발행자에서 구독자로 흐름에 착안해 개발자는 이를 업스트림 또는 다운스트림이라 부른다.
예제에서는 데이터 newValue는 업스트림 onNext() 메서드로 전달되고 notifyAllSubscribers() 호출을 통해 다운 스트림 onNext() 호출로 전달된다.

간단하지만 플로 인터페이스의 개념을 복잡하게 만든 두 가지 기능은 압력과 역압력이다.

* 처음에는 이 두기능이 별로 중요해 보이지 않을 수 있지만 스레드 활용에서 이들 기능은 필수다.
* 기존의 온도계 에제에서 온도계가 매초마다 온도를 보고했는데 기능이 업그레이드되면서 매밀리초마다 온도계를 보고한다고 가정하자.
* 우리 프로그램은 이렇게 빠른 속도로 발생하는 이벤트를 아무 문제 없이 처리할 수 있을까?
* 마찬가지로 모든 SMS 메시지를 폰으로 제공하는 발행자에 가입하는 상황을 생각해보자.
* 처음에 약간의 SMS 메시지가 있는 새폰에서는 가입이 잘 동작할 수 있지만 몇 년 후에는 매초마다 수천 개의 메시지가 onNext로 전달된다면 어떤일이 일어날까?

우리는 이런 상황을 압력이라고 부른다. 

* 공에 담긴 메시지를 포함하는 수직 파이프를 상상해보자.
* 이런 상황에서는 출구로 추가될 공의 숫자를 제한하는 역압력 같은 기법이 필요하다.
* 자바 9 플로 API에서는 발행자가 무한의 속도로 아이템을 방출하는 대신 요청했을 때만 다음 아이템을 보내도록 하는 request() 메서드를 제공한다.
* push가 아닌 pull 모델

### 역압력

* 현재는 Publisheer에서 Subscriber로 정보를 전달한다.
* 정보의 흐름 속도를 역압력으로 제어 즉 Subscriber에서 Publisher로 정보를 요청해야할 필요가 있을 수 있다.
* Publisher는 여러 Subscriber를 갖고 있으므로 역압력 요청이 한 연결에만 영향을 미쳐야 한다는 것이 문제가 될 수 있다.
* 자바 9 플로 API의 Subscriber 인터페이스는 네 번째 메서드를 포함한다.

```
void onSubscribe(Subscription subscription);
```

Publisher와 Subscriber 사이에 채널이 연결되면 첫 이벤트로 이 메서드가 호출된다.
Subscription 객체는 다음처럼 Subscriber와 Publisher와 통신할 수 있는 메서드를 포함한다.

```java
interface Subscription {
    void cancel();
    void request(long n);
}
```
콜백을 통한 역방향 소통효과에 주목하자
Publisher는 Subscription 객체를 만들어 Subscriber로 전달하면 Subscriber는 이를 이용해 Publisher 정보를 보낼 수 있다.

## 실제 역압력의 간단한 형태

Subscriber가 Publisher로부터 요청을 당긴다는 의미에서 __리액티브 당김 기반__ 이라 불린다.


<br>

## section 15.6 리액티브 시스템 vs 리액티브 프로그래밍

리액티브 시스템은 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 프로그램이다.
리액티브 시스템이 가져야할 공식적인 속성은 반응성, 회복성, 탄력성이다.

* 반응성은 리액티브 시스템이 큰 작업을 처리하느라 간단한 질의의 응답을 지연하지 않고 실시간으로 입력에 반응하는 것을 의미한다.
* 회복성은 한 컴포넌트의 실패로 전체 시스템이 실패하지 않음을 의미한다.
* 네트워크가 고장났어도 이와 관계가 없는 질의에는 아무 영향이 없어야하며 반응이 없는 컴포넌트를 향한 질의가 있다면 다른 대안 컴포넌트를 찾아야 한다.
* 탄력성은 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을 의미한다.

여러가지 방법으로 이런 속성을 구현할 수 있지만 java.util.concurrent.Flow 관련된 자바 인터페이스에서 제공하는 리액티브 프로그래밍 형식을 이용하는 것도 주요 방법 중 하나다.
이들 인터페이스 설계는 Reactie Manifesto의 네 번째이자 마지막 속성 즉 메시지 주도 속성을 반영한다.

메시지 주도 시스템은 박스와 채널 모델에 기반한 내부 API를 갖고 있는데 여기서 컴포넌트는 처리할 입력을 기다리고 결과를 다른 컴포넌트로 보내면서 시스템이 반응한다.

<br>

## section 15.7 마치며

* 자바의 동시성 지원은 계속 진화해 왔으며 앞으로도 그럴 것이다. 스레드 풀은 보통 유용하지만 블록되는 태스크가 많아지면 문제가 발생한다.
* 메서드를 비동기(결과를 처리하기 전에 반환)로 만들면 병렬성을 추가할 수 있으며 부수적으로 루프를 최적화한다.
* 박스와 채널 모델을 이용해 비동기 시스템을 시각화할 수 있다.
* 자바 8 CompletableFuture 클래스와 자바 9 플로 API 모두 박스와 채널 다이어그램으로 표현할 수 있다.
* CompletableFuture 클래스는 한 번의 비동기 연산을 표현한다. 콤비네이터로 비동기 연산을 조합함으로 Future를 이용할 때 발생했던 기존의 블로킹 문제를 해결할 수 있다.
* 플로 API는 발행-구독 프로토콜, 역압력을 이용하면 자바의 리액티브 프로그래밍의 기초를 제공한다.
* 리액티브 프로그래밍을 이용해 리액티브 시스템을 구현할 수 있다.

