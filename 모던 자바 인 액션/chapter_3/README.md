# chapter 3. 람다 표현식

## section 3.1 람다란 무엇인가?

* 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다.
* 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다. 람다의 특징을 하나씩 자세히 살펴보자.

### 람다의 특징

* 익명
  * 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
* 함수
  * 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.
* 전달
  * 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
* 간결성
  * 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.
 

* __람다라는 용어는 람다 미전북학 학계에서 개발한 시스템에서 유래했다.__
* 람다 표현식이 왜 중요할까? 2장에서 확인한 것처럼 코드를 전달하는 과정에서 자질구레한 코드가 많이 생긴다.
* 다행히 람다로 이 문제를 해결할 수 있다.
* 즉, 람다를 이용해서 간결한 방식으로 코드를 전달할 수 있다. 2장에서 살펴본 것처럼 동작 파라미터 형식의 코드를 더 쉽게 구현할 수 있다.

### 람다 표현식

```
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
   //람다 파라미터      화살표              람다 바디
```

* 람다는 람다 파라미터, 화살표, 람다 바디로 구성된다.
* 이제 람다 문법에 올바른 람다 표현식을 찾아보자.

```
1. () -> {}
2. () -> "Raoul"
3. () -> { return "Mario"; }
4. (Integer i) -> return "Alan" + 1;
5. (String s) -> {"Iron Man";}

1. 파라미터가 없으며 void를 반환하는 표현식이다. 이는 public void run() {}처럼 바디가 없는 메서드와 같다.
2. 파라미터가 없으며 문자열을 반환하는 표현식이다.
3. 파라미터가 없으며 (명시적으로 return 문을 이용해서) 문자열을 반환하는 형식이다.
4. return 흐름 제어문이다. (Integer i) -> { return "Alan" + i; } 처럼 되어야 올바른 람다 표현식이다.
5. "Iron Man"은 구문(Statement)이 아니라 표현식(expression)이다. (String s) -> "Iron Man" 처럼 되어야 올바른 람다 표현식이다. 또는 (String s) -> { return "Iron Man";} 처럼 명시적으로 return 문을 사용해야 한다.
```

## section 3.2 어디에, 어떻게 람다를 사용할까?

* 람다는 함수형 인터페이스라는 문맥에서 람다 표현식을 사용할 수 있다.
* 저번 2장에서 함수형 인터페이스 Predicate<T>를 기대하는 filter 메서드의 두 번째 인수로 람다 표현식을 전달했다.

### 3.2.1 함수형 인터페이스

* 저번장에서 배운 Predicate<T>가 바로 함수형 인터페이스다.
* Predicate<T>는 오직 하나의 추상 메서드만 지정하기 때문이다.
* __함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다__
* 함수형 인터페이스는 어디에 사용할 수 있을까? -> 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다.
* __그러므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급한다(기술적으로 따지만 함수형 인터페이스를 구현한 클래스의 인스턴스)할 수 있다.__

### 3.2.2 함수 디스크립터

* 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
* __람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.__
* 람다 표현식은 변수에 할당하거나 함수형 인터페이스를 인수로 받는 메서드로 전달할 수 있으며, 함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다는 사실을 기억하자.
* 왜 함수형 인터페이스를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있을까? 라는 질문은 추후에 다뤄보겠다.

## section 3.3 람다 활용: 실행 어라운드 패턴

* 자원처리에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다.
* 설정과 정리 과정은 대부분 비슷하며, 즉 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖는다.
* 이런 코드를 실행 어라운드 패턴이라고 부른다. 이를 예제로 살펴봄.

1. 동작 파라미터화를 기억하라.
2. 함수형 인터페이스를 이용해서 동작을 전달.
3. 동작을 실행.
4. 람다를 전달.

## section 3.4 함수형 인터페이스 사용

* Predicate, Consumer, Function과 같은 자바 API 함수형 인터페이스를 살펴봄.
* 스트림과 같이 사용한 forEach는 Consumer 함수형 인터페이스가 사용된다.
* 스트림과  같이 자주 사용한 map 메서드는 Function 함수형 인터페이스와 함께 사용된다.

## section 3.5 형식 검사, 형식 추론, 제약

### 3.5.1 형식 검사

* 람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있다.
* __어떤 콘텍스트(예를 들면 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등)에서 기대되는 람다 표현식의 형식을 대상 형식이라고 부른다.__
* 람다 표현식을 사용할 때 실제 어떤일이 일어나는지 보여주는 예제를 확인해보자.

```
List<Apple> heavierThan150g =
filter(inventory, (Apple apple) -> apple.getWeight() > 150);
```
다음과 같은 순서로 형식 확인 과정이 이루어진다.

1. 람다가 사용될 콘텍스트는 무엇인가? filter 메서드의 선언을 확인한다.
2. filter 메서드는 두 번째 파라미터로 Predicate<Apple> 형식(대상 형식)을 기대한다.
3. Predicate<Apple>은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. test 메서드는 Apple을 받아 boolean을 반환하는 함수 디스크립터를 묘사한다.
5. filter 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

* 위 예제에서 람다 표현식은 Apple을 인수로 받아 boolean을 반환하므로 유효한 코드다.
* 람다 표현식이 예외를 던질 수 있다면 추상 메서드도 같은 예외를 던질 수 있도록 throws로 선언해야 한다.

### 3.5.2 같은 람다, 다른 함수형 인터페이스

* 대상 형식이라는 특징 때문에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다.
* 즉 하나의 람다 표현식을 다양한 함수형 인터페이스에 사용할 수 있다.

### 참고

* 자바 7에서도 다이아몬드 연산자로 콘텍스트에 따른 제네릭 형식을 추론할 수 있다.
* 주어진 클래스 인스턴스 표현식을 두 개 이상의 다양한 콘텍스트에 사용할 수 있다. 이때 인스턴스 표현식의 형식 인수는 콘텍스트에 의해 추론된다.

```
List<String> listOfStrings = new ArrayList<>();
List<Integer> listOfIntegers = new ArrayList<>();
```

### 3.5.3 형식 추론

* 자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)을 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다.
* 즉, 대상 형식을 이용해서 함수 디스크립터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다.
* 결과적으로 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 람다 문법에서 이를 생략할 수 있다. 
* __즉, 자바 컴파일러는 다음처럼 람다 파라미터 형식을 추론할 수 있다.__

```
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

위 두 가지 방법 중에서 어떤 방법이 좋은 지 정해진 규칙은 없다. 개발자 스스로 어떤 코드가 가독성을 향상시킬 수 있는지 결정해야 한다.

### 3.5.4 지역 변수 사용

* 지금까지 살펴본 모든 람다 표현식은 인수를 자신의 바디 안에서만 사용했다.
* __하지만 람다 표현식에서는 익명 함수가 하는 것처럼 자유 변수를 활용할 수 있다.__
* __이와 같은 동작을 람다 캡처링이라고 부른다.__
* 아래는 람다 캡처링 예제다.

```
Runnable r = () -> System.out.println("Hello World");
```

* 하지만 자유 변수에도 약간의 제약이 임ㅆ는데, 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처 할 수 있다.
* 하지만 그러려면 지역 변수는 명시적으로 final로 선언되어 있어야 하거나 실질적으로 final로 선언된 변수와 똑같이 사용되어야 한다.
* __즉, 람다 표현식은 한 번만 할당할 수 있는 지역 변수를 캡처할 수 있다.__
* 다음 예제는 portNumber에 값을 두 번 할당하므로 컴파일할 수 없는 코드다.

```
int num = 3333;
Runnable r = () -> System.out.println(num);
num = 123123;
```

* 왜 이런 제약이 있을까? 인스턴스 변수는 힙에 저장. 지역 변수는 스택에 위치.
* 람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있다.
* 따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다.
* 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴 것이다.

## section 3.6 메서드 참조

* 메서드 참조는 특정 메서드만을 호출하는 람다의 축약형이라고 생각할 수 있다.
* 메서드 참조는 메서드명 앞에 구분자(::)를 붙이는 방식으로 메서드 참조를 활용할 수 있다.
* 실제로 메서드를 호출하는 것은 아니므로 괄호는 필요 없음을 기억하자. 
* 아래는 메서드 참조의 예시다.

```
(Apple) --> apple.getWeight(); //람다 표현식
Apple::getWeightl; //메서드 참조
```

* 메서드 참조는 세 가지 유형으로 구분할 수 있다.

1. 정적 메서드 참조 (Integer.parseInt()를 Integer::parseInt)
2. 다양한 형식의 인스턴스 메서드 참조 ( (String s) -> s.toUpperCase()를 String::toUpperCase로 표현)
3. 기존 객체의 인스턴스 메서드 참조 (expensiveTransaction.getValue()를 expensiveTransaction::getValue)

아래는 세 가지 종류의 람다 표현식을 메서드 참조로 바꾸는 방법이다.
```
(args) -> ClassName.staticMethod(args)
ClassName::staticMethod

(arg0, rest) -> arg0.instanceMethod(res)
ClassNmae::instanceMethod

(args) -> expr.instanceMethod(args)
expr::instanceMethod

아래 코드는 다른 예시.
str.sort((s1, s2) -> s1.compareToIgnoreCase(s2));
str.sort(String::compareToIgnoreCase);
```

* 컴파일러는 람다 표현식의 형식을 검사하던 방식과 비슷한 과정으로 메서드 참조가 주어진 함수형 인터페이스와 호환하는지 확인한다.
* 즉, 메서드 참조는 콘텍스트의 형식과 일치해야 한다.

### 3.6.2 생성자 참조

* ClassName::new처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.
* 이것은 정적 메서드의 참조를 만드는 방법과 비슷하다.
* 예를 들어 인수가 없는 생성자, 즉 Supplier의 () -> Apple과 같은 시그니처를 갖는 생성자가 있다고 생각하자.

```
Supplier<Apple> c1 = Apple::new;
Apple a1 = c1.get();

위 코드는 아래 코드와 동일하다.
Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();

=======
Function<Integer, Apple> c2 = Apple::new;
Apple a2 = c2.apply(110);

위 코드는 아래 코드와 동일하다.
Function<Integer, Apple> c2 = (weight) -> new Apple(weight);
Apple a2 = c2.apply(110);
```

## section 3.7 람다, 메서드 참조 활용하기

* 사과 문제를 구현 클래스 -> 익명 클래스 -> 람다 -> 메서드 참조까지 리팩토링을 진행.


## section 3.8 람다 표현식을 조합할 수 있는 유용한 메서드

* 디폴트 메서드는 추상 메서드가 아니므로 함수형 인터페이스의 정의에서 벗어나지 않는다. 이를 활용해 람다 표현식을 조합할 수 있다.
* Comparator 조합, Comparator 연결을 살펴봄.
* Predicate 조합, Function 조합을 살펴봄.

## section 3.9 비슷한 수학적 개념

* 적분 예시를 살펴봄.

## section 3.10 정리

* 람다 표현식은 익명 함수의 일종이다. 이름은 없지만, 파라미터 리스트, 바디, 반환 형식을 가지며 예외를 던질 수 있다.
* 람다 표현식으로 간결한 코드를 구현할 수 있다.
* 함수형 인터페이스는 하나의 추상 메서드만을 정의하는 인터페이스다.
* 함수형 인터페이스를 기대하는 곳에서만 람다 표현식을 사용할 수 있다.
* 람다 표현식을 이용해서 함수형 인터페이스의 추상 메서드를 즉석으로 제공할 수 있으며, 람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급된다.
* 자바 API에서는 다양한 함수형 인터페이스를 제공한다.
* 자바 8은 제네릭 함수형 인터페이스와 관련한 박싱 동작을 피할 수 있는 기본형 특화 인터페이스도 제공한다.
* 실행 어라운드 패턴을 람다와 활용하며 유연성과 재사용성을 추가로 얻을 수 있다. (DB나 네트워크 연결이 생각나는 부분)
* 람다 표현식의 기대 형식을 대상 형식이라고 한다.
* 메서드 참조를 이용하면 기존의 메서드 구현을 재사용하고 직접 전달할 수 있다.
* 다양한 자바 API 함수형 인터페이스는 람다 표현식을 조합할 수 있는 다양한 디폴트 메서드를 제공한다.