# chapter 7. 병렬 데이터 처리와 성능

* 자바 7은 더 쉽게 병렬화를 수행하면서 에러를 최소화할 수 있도록 포크/조인 프레임워크 기능을 제공한다.
* 이번에는 스트림으로 데이터 컬렉션 관련 동작을 얼마나 쉽게 병렬로 실행할 수 있는지 알아본다.
* 스트림을 이용하면 순차 스트림을 병렬 스트림으로 자연스럽게 바꿀 수 있다.

## section 7.1 병렬 스트림

* 컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다.
* 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
* 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다. 

### 7.1.1 순차 스트림을 병렬 스트림으로 변환하기

* 순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산(숫자 합계 게산)이 병렬로 처리된다.
* p. 244 이미지에서 병렬 리듀싱 연산 예시를 보여줌.
* 사실 순차 스트림에 parallel을 호출해도 스트림 자체에는 아무런 변화도 일어나지 않는다.
* 내부적으로 parallel을 호출하면 이후 연산이 병렬로 수행해야 함을 의미하는 불리언 플래그가 설정된다.
* 병렬 스트림은 내부적으로 ForkJoinPool을 사용한다. 기본적으로 ForkJoinPool은 프로세서 수에 상응하는 스레드를 갖는다. p.245

### 7.1.2 스트림 성능 측정

* JMH 자바 마이크로벤치마크 하니스라는 라이브러리를 이용해 성능을 측정한다.
* 전통적인 for 루프를 사용해 반복하는 방법이 더 저수준으로 동작할 뿐만 아니라 특히 기본값을 박싱하거나 언박싱할 필요가 없으므로 더 빠를 것이라고 예상.
* 결론은 순차적 스트림을 사용하는 버전에 비해 거의 4배가 빠르다.(책에서는). 필자의 경우는 더 큰 차이가 났다.
* 병렬 버전이 순차 버전에 비해 더 느린 실망스러운 결과가 나왔다. 이 결과를 어떻게 설명할까? 2가지 문제가 있었다.
  * 반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야 한다.
  * 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다.
* 이전 연산의 결과에 따라 다음 함수의 입력이 달라지기 때문에 iterate 연산을 청크로 분할하기가 어렵다. p.249 그림.
* 리듀싱 과정을 시작하는 시점에 전체 숫자 리스트가 준비되지 않았으므로 스트림을 병렬로 처리하 수 있도록 청크로 분할할 수 없다.
* 스트림이 병렬로 처리되도록 지시했고 각각의 합계가 달느 스레드에서 수행되었지만 결국 순차처리 방식과 크게 다른 점이 없으므로 스레드를 할당하는 오버헤드만 증가한 것이다.
* 이처럼 병렬 프로그래밍은 까다로운 부분이 있어서 정확한 이해가 필요하다.

#### 더 특화된 메서드 사용

* LongStream.rangeClosed는 기본형 long을 직접 사용하므로 박싱과 언박싱 오버헤드가 사라진다. 이를 사용함.
* 또한 rangeClosed는 쉽게 청크로 분할할 수 있는 숫자 범위를 생산한다. iterate 대신 이 메서드를 사용.
* 드디어 순차 실행보다 빠른 성능을 갖는 병렬 리듀싱을 만들었다. 필자는 단순 반복보다 4배는 빨라졌음
* 올바른 자료 구조를 선택해야 병렬 실행도 최적의 성능을 발휘할 수 있다.
* 결국 함수형 프로그래밍을 올바로 사용하면 반복적으로 코드를 실행하는 방법에 비해 최신 멀티 코어 CPU가 제공하는 병렬 실행의 힘을 단순하게 직접적으로 얻을 수 있다.
* 병렬화는 공짜가 아니다. 병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고, 이들 결과를 하나의 값으로 합쳐야 한다.
* 멀티 코어 데이터 이동은 생각보다 비싸다. 따라서 코어 간에 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는 것이 바람직하다.
* 그리고 스트림을 병렬화해서 코드 실행 속도를 빠르게 하고 싶으면 항상 병렬화를 올바르게 사용하고 있는지 확인해야 한다. 

### 7.1.3 병렬 스트림의 올바른 사용법

* 병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어난다.
* n까지의 자연수를 더하면서 공유된 누적자를 바꾸는 프로그램 코드를 살펴봄.
* 순차 실행을 실행할 수 있도록 구현되어 있으므로 병렬로 실행하면 대참사가 일어난다. 
* 즉 여러 쓰레드에서 공유 변수(total)에 접근해서 문제가 발생하는 것이다.
* 해당 예제처럼 병렬 스트림을 사용했을 때 이상한 결과에 당황하지 않으려면 상태 공유에 따른 부작용을 피해야 한다.
* 병렬 스트림과 병렬 계산에서는 공유된 가변 상태를 피해야 한다.

### 7.1.4 병렬 스트림 효과적으로 사용하기

* 확신이 서지 않으면 직접 측정하라. 순차 스트림을 병렬 스트림으로 쉽게 바꿀 수 있다. 하지만 병렬 스트림으로 무조건 바꾸는 것이 능사가 아니다. 언제나 병렬 스트림이 순차 스트림보다 빠른 것은 아니다. 또 병렬 스트림의 수행 과정은 투명하지 않을 때가 많다. 따라서 순차 스트림과 병렬 스트림 중 어떤 것이 좋을지 모르겠다면 적절한 벤치마크로 직접 성능을 측정하는 것이 바람직하다.
* 박싱을 주의하자. 자동 박싱과 언박싱은 성능을 크게 저하시키는 요소다. 자바 8은 박싱 동작을 피할 수 있도록 기본형 특화 스트림(IntStream, LongStream, DoubleStream)을 제공한다. 되도록이면 기본형 특화 스트림을 사용하자.
* 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. limit, findFirst처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치뤄야 한다.
* 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하자. 처리해야 할 요소수가 N이고 하나의 요소를 처리하는데 드는 비용을 Q라고 하면 전체 스트림 파이프라인 처리 비용을 N*Q로 예상할 수 있다. Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 암시한다.
* 소량의 데이터에서는 병렬 스트림이 도움이 되지 않는다.
* 스트림을 구성하는 자료구조가 적절한지 확인하자.
* 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다. 예를 들어 SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있으므로 효과적으로 스트림을 병렬 처리할 수 있다. 반면 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없게 된다.
* 최종 연산의 병합과정 비용을 살펴보자. 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다.
* 마지막으로 병렬 스트림이 수행되는 내부 인프라구조도 살펴봐야 한다.(포크/조인 프레임워크)

## section 7.2 포크/조인 프레임워크

* 포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.
* 포크/조인 프레임워크에서는 서브태스크를 스레드 풀의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현한다.

### 7.2.1 RecursiveTask 활용

* 스레드 풀을 이용하려면 RecursiveTask<R>의 서브 클래스를 만들어야 한다.
* R은 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때는 RecursiveAction 형식이다. RecursiveTask를 정의하려면 compute를 구현해야 한다.
* 대부분의 compute 메서드 구현은 다음과 같은 의사코드 형식을 유지한다.
```
if(태스크가 충분히 작거나 더 잇아 분할할 수 없으면){
 순차적으로 태스크 계산
} else{
 태스크를 두 서브 태스크로 분할
 태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출
 모든 서브태스크의 연산이 완료될 때까지 기다림
 각 서브태스크의 결과를 합침
}
```

* 이 알고리즘은 분할 후 정복 알고리즘의 병렬화 버전이다.
* 일반적으로 애플리케이션에서는 둘 이상의 ForkJoinPool을 사용하지 않는다. 싱글톤 패턴으로 사용함.
* Runtime.availableProcessors의 반환값으로 풀에 사용할 스레드 수를 결정할 수 있다. 
* 실제 프로세서 외에 하이퍼스레딩과 관련된 가상 프로세서도 개수에 포함된다.

#### ForkJoinSumCalculator 실행

* ForkJoinSumCalculator를 ForkJoinPool로 전달하면 풀의 스레드가 ForkJinSumCalculator의 compute 메서드를 실행하면서 작업을 수행한다.
* p259 이미지로 과정을 더 자세히 보여준다.

### 7.2.2 포크/조인 프레임워크를 제대로 사용하는 방법

1. join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킨다. 따라서 두 서브태스크가 모두 시작된 다음에 join을 호출해야 한다. 그렇지 않으면 각각의 서브태스크가 다른 태스크가 끝나길 기다리는 일이 발생하며 원래 순차 알고리즘보다 느리고 복잡한 프로그램이 되어버릴 수 있다.
2. RecursiveTask 내에서는 ForkJoinPool의 invoke 메서드를 사용하지 말아야 한다. 대신 compute나 fork 메서드를 호출할 수 있다. 순차 코드에서 병렬 계산을 시작할 때만 invoke를 사용한다.
3. 서브태스크에 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다. 왼쪽 작업과 오른쪽 작업 모두에 fork 메서드를 호출하는 것이 자연스러울 것 같지만 한쪽 작업에는 fork를 호출하는 것보다는 compute를 호출하는 것이 효율적이다. 그러면 두 서브 태스크의 한 태스크에는 같은 스레드를 재사용할 수 있으므로 풀에서 불필요한 태스크를 할당하는 오버헤드를 줄일 수 있다.
4. 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅이 어렵다. 보통 스택 트레이스로 문제가 일어난 과정을 쉽게 확인할 수 있는데, 포크/조인 프레임워크에서는 fork라 불리는 다른 스레드에서 compute를 호출하므로 스택 트레이스가 도움이 되지 않는다.
5. 병렬 스트림에서 살펴본 것처럼 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 것이라는 생각은 버려야 한다.

### 7.2.3 작업 훔치기

* 코어 개수와 관계없이 적절한 크기로 분할된 많은 태스크를 포킹하는 것이 바람직하다.
* 이론적으로는 코어 개수만큼 병렬화된 태스크로 작업 부하를 분할하면 모든 CPU 코어에서 태스크를 실행할 것이고 크기가 같은 각각의 태스크는 같은 시간에 종료될 것이라 생각할 수 있다.
* 하지만 이 예제보다 복잡한 시나리오가 사용되는 현실에서는 각각의 서브태스크의 작업 완료 시간이 크게 달라질 수 있다.
* 분할 기법이 효율적이지 않았기 때문일 수도 있고 아니면 예기치 않게 디스크 접근 속도가 저하되었거나 외부 서비스와 협력하는 과정에서 지연이 생길 수 있기 때문이다.
* __포크/조인 프레임워크에서는 작업 훔치기라는 기법으로 이 문제를 해결한다.__
* 작업 훔치기 기법에서는 ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다.
* 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 차조하면서 작업이 끝날 때마다 큐의 헤읃에서 다른 태스크를 가져와서 작업을 처리한다.
* 이때 한 스레드는 다른 스레드보다 자신에게 할당된 테스크를 더 빨리 처리할 수 있다.
* 이때 할일이 없어진 스레드는 유휴 상태로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업ㅇ르 훔쳐온다.
* 모든 태스크가 작업을 끝낼 때까지, 즉 모든 큐가 빌 때까지 이 과정을 반복한다.
* 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업 부하를 비슷한 수준으로 유지할 수 있다.
* 풀에 있는 작업자 스레드의 태스크를 재분배하고 균형을 맞출 때 작업 훔치기 알고리즘을 사용한다. p.262에서 이 과정을 이미지로 보여준다.
* 7장 앞부분에서 분할 로직을 개발하지 않고도 병렬 스트림을 이용할 수 있었다. 즉 자동으로 스트림을 분할해주는 기능이 있다는 것이다.
* 자동으로 스트림을 분할하는 기법은 Spliterator이다.

## section 7.3 Spliterator 인터페이스

* 자바 8은 Spliterator라는 인터페이스를 제공한다.
* Iterator처럼 Spliterator는 소스의 요소 탐색 기능을 제공한다는 점은 같지만 Spliterator은 병렬 작업에 특화되어 있다.
* 자바8은 컬렉션 프레임워크에 포함된 모든 자료구조에서 사용할 수 있는 디폴트 Spliterator 구현을 제공한다.
* 컬렉션은 spliterator라는 메서드를 제공하는 Spliterator 인터페이스를 구현한다.
* Spliterator 인터페이스는 여러 메서드를 정의한다.

```
public interface Spliterator<T>{
  boolean tryAdvance(Consumer<? super T> action);
  Spliterator<T> trySplit();
  long estimateSize();
  int characteristics();
}
```

* 여기서 T는 Spliterator에서 탐색하는 요소의 형식을 가리킨다.
* tryAdvance는 Spliterator의 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환한다.
* 반면 trySplit 메서드는 Spliterator의 일부 요소를 분할해서 두 번째 Spliterator를 생성하는 메서드다.
* Spliterator에서는 estimateSize 메서드로 탐색해야 할 요소 수 정보를 제공할 수 있다.
* 특히 탐색해야 할 요소 수가 정확하진 않더라도 제공된 값을 이용해서 더 쉽고 공평하게 Spliterator를 분할할 수 있다.

###  7.3.1 분할 과정

* 스트림을 여러 스트림으로 분할하는 과정은 재귀적으로 일어난다.
* 첫 번째 Spliterator에서 trySplit을 호출하면 두 번째 Spliterator가 생성된다.
* 두 개의 Spliterator에 trySplit을 다시 호출하면 네 개의 Spliterator가 생성된다.
* 이처럼 trySplit의 값이 null이 될 때까지 이 과정을 반복한다. p.264에서 이 과정을 이미지로 자세히 보여준다.


#### Spliterator 특성

* Spliterator는 Characteristics라는 추상 메서드도 정의한다. Characteristics 메서드는 Spliterator 자체의 특성 집합을 포함하는 int를 반환한다.
* Spliterator를 이용하는 프로그램은 이들 특성을 참고해서 Spliterator를 더 잘 제어하고 최적화할 수 있다.
* 특성은 아래 표와 같다.

| 특성        | 의미                                                                |
|-----------|-------------------------------------------------------------------|
| ORDERED   | 리스트처럼 요소에 정해진 순서가 있으므로 Spliterator는 요소를 탐색하고 분할할 때 이 순서에 유의해야 한다. |
| DISTINCT  | x, y 두 요소를 방문했을 때 x.equals(y)는 항상 false를 반환한다.                    |
| SORTED    | 탐색된 요소는 미리 정의된 정렬 순서를 따른다.                                        |
| SIZED     | 크기가 알려진 소스로 Spliterator를 생성했으므로 estimatedSize()는 정확한 값을 반환한다.     |
| IMMUTABLE | 이 Spliterator의 소스는 불변이다. 즉 요소를 탐색하는 동안 요소를 추가하거나, 삭제하거나, 고칠 수 없다. |
| CONCURRENT | 동기화 없이 Spliterator의 소스를 여러 스레드에서 동시에 고칠 수 있다.                     |
| SUBSIZED  | 이 Spliterator의 소스를 여러 스레드에서 동시에 고칠 수 있다.                          |
| NON-NULL  | 탐색하는 모든 요소는 null이 아니다.                                            |

### 7.3.2 커스텀 Spliterator 구현하기

* Spliterator를 구현하는 예제를 진행. 문자열의 단어 수를 구하는 단순한 메서드.
* 단순 반복문을 사용해 구현.
* 함수형으로 메서드를 재구현. 반복문, 단순 순차 함수형 메서드는 같은 결과가 나옴.
* 병렬 스트림으로 처음 처리했을 때 위의 값과 다른 값이 나왔다.
* 무엇이 문제인가? 원래 문자열을 임의의 위치에서 둘로 나누다보니 예상치 못하게 하나의 단어를 둘로 계산하는 상황이 발생할 수 있다.
* 즉 순차 스트림을 병렬 스트리으로 바꿀 때 스트림 분할 위치에 따라 잘못된 결과가 나올 수 있다.
* 이 문제를 해결하려면 문자열을 임의의 위치에서 분할하지 않고 단어가 끝나는 위치에서만 분할하는 방법으로 이 문제를 해결해야 한다.
* 그러려면 단어 끝에서 문자열을 분할하는 문자 Spliterator가 필요하다. 이를 구현함.
* 최종적으로 구현하면 올바른 결과가 나옴.
* 특히 Spliterator는 첫 번째 탐색 시점, 첫 번째 분할 시점, 첫 번째 예상 크기 요청 시점에 요소의 소스를 바인딩할 수 있다. 이와 같은 늦은 동작을 바인딩 Sopliterator라고 부른다.

#### 구현한 WordCounterSpliterator 메서드 정리

tryAdvance

* tryAdvance 메서드는 문자열에서 현재 인덱스에 해당하는 문자를 Consumer에 제공한 다음에 인덱스를 증가시킨다.
* 인수로 전달된 Consumer는 스트림을 탐색하면서 적용해야 하는 함수 집합이 작업을 처리할 수 있도록 소비한 문다를 전달하는 자바의 내부 클래스다.
* 예제에서는 스트림을 탐색하면서 하나의 리듀싱 함수, 즉 WordCounter의 accumulate 메서드만 적용한다.
* tryAdvance 메서드는 새로운 커서 위치가 전체 문자열 길이보다 작으면 참을 반환하며 이는 반복 탐색해야 할 문자가 남아있음을 의미한다.

trySplit

* trySplit은 반복될 자료구조를 분할하는 로직을 포함하므로 제일 중요하다.
* RecursiveTask의 compute 메서드에서 했던 것처럼 우선 분할 동작을 중단할 한계를 설정해야 한다.
* 여기서는 아주 작은 한계값을 사용했지만 실전 애플리케이션에서는 너무 많은 태스크를 만들지 않도록 더 높은 한계 값을 설정해야 한다.
* 분할 과정에서 남은 문자 수가 한계값 이하면 null을 반환. 즉 분할을 중지하도록 지시.
* 반대로 분할이 필요한 상황에는 파싱해야 할 문자열 청크의 중간 위치를 기준으로 분할하도록 지시한다.
* 이때 단어 중간을 분할하지 않도록 빈 문자가 나올때까지 분할 위치를 이동시킨다.
* 분할 위치를 찾았으면 새로운 Spliterator를 만든다. 새로 만든 Spliterator는 현재 위치부터 분할된 위치까지의 문자를 탐색한다.

estimatedSize

* 탐색할 요소의 개수는 Spliterator가 파싱할 문자열 전체 길이와 현재 반복 중인 위치의 차다.

characteristic

* characteristic 메서드는 프레임워크에 Spliterator가 ORDERED, SIZED, SUBSIZED, NONNULL, IMMUTABLE 등의 특성임을 알려준다.

## section 7.4 정리

* 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리할 수 있다.
* 간단하게 스트림을 병렬로 처리할 수 있지만 항상 병렬 처리가 빠른 것은 아니다. 늘 성능 측정을 해야 한다.
* 병렬 스트림으로 데이터 집합을 병렬 실행할 때 특히 처리해야 할 데이터가 아주 많거나 각 요소를 처리하는데 오랜 시간이 걸릴 때 성능을 높일 수 있다.
* 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.
* 포크/조인 프레임워크에서는 병렬화할 수 있는 태스크를 작은 태스크로 분할한 다음에 분할된 태스크를 각각의 스레드로 실행하며 서브태스크 각각의 결과를 합쳐서 최종 결과를 생산한다.
* Spliterator는 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화할 것인지 정의한다.