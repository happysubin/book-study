# chapter 8. 컬렉션 API 개선하기

## section 8.1 컬렉션 팩토리

* Arrays.asList() 팩토리 메서드를 이용해 만든 리스트는 고정 크기 리스트다. 
* 요소를 추가하거나 삭제하면 UnsupportedOperationException이 발생한다.
* 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현되었으므로 이와 같은 일이 발생하는 것이다.
* 컬렉션을 만드는 새로운 방법을 살펴본다.

### 8.1.1 리스트 팩토리

* List.of 팩토리 메서드를 이용해서 간단하게 리스트를 만들 수 있다.
* 마찬가지로 요소를 add하면 UnsupportedOperationException이 발생.
* set 메서드로도 추가할 수 없다. 
* 컬렉션이 의도치 않게 변하는 것을 막는다. 그러나 요소 자체가 변하는 것은 막을 수 없다.
* 데이터 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 사용하기 간편한 팩토리 메서드를 사용하면 된다.

### 8.1.2 집합 팩토리

* Set.of 메서드를 통해 바꿀 수 없는 집합을 만들 수 있다. 중복 된 값을 넣으면 예외를 던진다.
* 마찬가지로 add 메서드를 통해 요소를 추가할 수 없다. 

### 8.1.3 맵 팩토리

* Map.of 팩토리 메서드에 키와 값을 번갈아 제공하는 방법으로 맵을 만들 수 있다.
* 열 개 이하의 키와 값 쌍을 가진 작은 맵을 만들 때는 위 메서드가 유용하다.
* 그이상의 맵에서는 Map.Entry<K, V> 인수를 받으며 가변 인수로 구현된 Map.ofEntries 팩토리 메서드를 이용하는 것이 좋다.

## section 8.2 리스트와 집합 처리

* 자바 8에서는 List, Set 인터페이스에 다음과 같은 메서드를 추가했다.
* removeIf: 프레디케이트를 만족하는 요소를 제거한다. List, Set을 구현하거나 그 구현을 상속받은 모든 클래스에서 이용할 수 있다.
* replaceCall: 리스트에서 이용할 수 있는 기능으로 UnaryOperator 함수를 이용해서 요소를 바꾼다.
* sort: List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.
* __이들 메서드는 호출한 컬렉션 자체를 바꾼다. 새로운 결과를 만드는 스트림 동작과 달리 이들 메서드는 기존 컬렉션을 바꾼다.__
* 컬렉션을 바꾸는 동작은 에러를 유발하며 복잡함을 더한다. 자바 8에 removeIf와 replaceAll를 추가한 이유가 바로 이것이다.

### 8.2.1 removeIf 메서드

* 예시 코드를 살펴봄. for-each 루프는 iterator 객체를 사용함.
* 두 개의 개별 객체가 컬렉션을 관리한다.
* Iterator 객체: next 메서드와 hasNext 메서드로 소스를 질의.
* Collection 객체 자체: remove를 호출해 요소를 삭제한다.
* 결과적으로 반복자의 상태는 컬렉션의 상태와 서로 동기화되지 않는다.
* 첫 번째 해결책으로는 iterator 객체를 명시적으로 삭제하는 것이다.
* 두 번재 해결책은 removeIf 메서드를 사용한 것이다.

### 8.2.2 replaceAll 메서드

* List 인터페이스의 replaceAll 메서드를 이용해 리스트의 각 요소를 새로운 요소로 바꿀 수 있다.
* 기존의 stream으로 해당 기능을 구현하면 스트림을 기반으로 map 메서드를 사용해 새로운 콜렉션을 리턴해야 했다.

## section 8.3 맵 처리

### 8.3.1 forEach 메서드

* 자바 8부터는 Map 인터페이스는 BiConsumer를 인수로 받는 forEach 메서드를 지원하므로 코드를 편하게 구현할 수 있다.

### 8.3.2 정렬 메서드

* 아래 두 개의 새로운 유틸리티를 이용해 맵의 항목을 값 또는 키를 기준으로 정렬 할 수 있다.
* Entry.comparingByValue
* Entry.comparingByKey

### 8.3.3 getOrDefault 메서드

* 기존에는 찾으려는 키가 존재하지 않으면 널이 반환되므로 널 포인터 예외를 방지하기 위해 요청 결과가 널인지 체크했다.
* getOrDefault 메서드로 이 문제를 쉽게 해결할 수 있다.
* 이 메서드는 첫 번재 인수로 키를, 두 번재 인수로 기본 값을 받으며 맵에 키가 존재하지 않으면 두 번째 인수로 받은 기본 값을 반환한다.

### 8.3.4 계산 패턴

* 맵에 키가 존재하는지 여부에 따라 어떤 동작을 실행하고 결과를 저장해야하는 상황에서 많이 사용하는 메서드에 대해 알아봄.
* computeIfAbsent: 제공된 키에 해당하는 값이 없으면(값이 없거나 널), 키를 이용해 새 값을 계산하고 맵에 추가한다.
* computeIfPresent: 제공된 키가 존재하면 새 값을 계산하고 맵에 추가한다.
* compute: 제공된 키로 새 값을 계산하고 맵에 저장한다.
* 정보를 캐시할 때 computeIfAbsent 메서드를 사용할 수 있다.


### 8.3.5 삭제 패턴

* remove 메서드를 사용해 편하게 삭제.

### 8.3.6 교체 패턴

* 맵의 항목을 바꾸는 데 사용할 수 있는 두 개의 메서드가 맵에 추가됨.
* replaceAll: BiFunction을 적용한 결과로 각 항목의 값을 교체한다. 이 메서드는 이전에 살펴본 List의 replaceAll과 비슷한 동작을 수행한다.
* Replace: 키가 존재하면 맵의 값을 바꾼다. 키가 특정 값으로 매핑되었을 때만 값을 교체하는 오버로드 버전도 있다.

### 8.3.7 합침

* putAll 메서드를 이용해 두 개의 맵을 합침. 물론 중복된 키가 없어야 한다.
* 값을 좀 더 유연하게 합쳐야 한다면 새로운 merge 메서드를 사용할 수 있다.
* 이 메서드는 중복 키를 어떻게 합칠지 결정하는 BiFunction을 인수로 받는다.

## section 8.4 개선된 ConcurrentHashMap

* ConcurrentHashMap 클래스는 동시성 친화적이며 최신 기술을 반영한 HashMap 버전이다.
* ConcurrentHashMap은 내부 자료구조의 특정 부분만 잠궈 동시 추가, 갱신 작업을 허용한다.
* 따라서 동기화된 HashTable 버전에 비해 읽기 쓰기 연산이 월등하다.

### 8.4.1 리듀스와 검색

* forEach: 각 (키, 값) 쌍에 주어진 액션을 실행
* reduce: 모든 (키, 값) 쌍을 제공된 리듀스 함수를 이용해 결과로 합침
* search: 널이 아닌 값을 반환할 때까지 각 (키, 값) 쌍에 함수를 적용
* 다음처럼 키에 함수 받기, 값, Map.Entry, (키, 값) 인수를 이용한 네 가지 연산 형태를 지원한다.
* 키, 값으로 연산 (forEach, reduce, search)
* 키로 연산 (forEachKey, reduceKeys, searchKeys)
* 값으로 연산 (forEachValue, reduceValues, searchValues)
* Map.Entry 객체로 연산 (forEachEntry, reduceEntries, searchEntries)
* 이들 연산은 ConcurrentHashMap의 상태를 잠그지 않고 연산을 수행한다는 점을 주목하자.
* 따라서 이들 연산에 제공한 함수는 게산이 진행되는 동안 바뀔 수 있는 객체, 값, 순서 등에 의존하지 않아야 한다./\
* 또한 이들 연산에 병렬성 기준 값을 적용해야 한다. 맵의 크기가 주어진 기준값보다 작으면 순차적으로 연산을 실행한다.
* 기준값을 1로 지정하면 공통 스레드 풀을 이용해 병렬성을 극대화 한다.

### 8.4.2 계수

* ConcurrentHashMap 클래스는 맵의 매핑 개수를 반환하는 mappingCount 메서드를 제공한다.
* 기존의 size 메서드 대신 새 코드에서는 int를 반환하는 mappingCount 메서드를 사용하는 것이 좋다.
* 그래야 매핑의 개수가 int의 범위를 넘어서는 이후의 상황을 대처할 수 있기 때문이다.

### 8.4.3 집합 뷰

* ConcurrentHashMap 클래스는 ConcurrentHashMap을 집합 뷰로 반환하는 keySet이라는 새 메서드를 제공한다.
* 맵을 바꾸면 집합도 바뀌고 반대로 집합을 바꾸면 맵도 영향을 받는다.
* newKeySet이라는 새 메서드를 이용해 ConcurrentHashMap으로 유지되는 집합을 만들 수도 있다.

## section 8.5 정리

* 자바 9는 적의 원소를 포함하며 바꿀 수 없는 리스트, 집합, 맵을 쉽게 만들 수 있도록 of 시리즈의 다양한 컬렉션 팩토리를 지원한다.
* 이들 컬렉션 팩토리가 반환한 객체는 만들어진 다음 바꿀 수 없다.
* List 인터페이스는 removeIf, replaceAll, sort 세 가지 디폴트 메서드를 지원한다.
* Set 인터페이스는 removeIf 디폴트 메서드를 지원한다.
* Map 인터페이스는 자주 사용하는 패턴과 버그를 방지할 수 있도록 다양한 디폴트 메서드를 지원한다.
* ConcurrentHashMap은 Map에서 상속 받은 새 디폴트 메서드를 지원함과 동시에 스레드 안정성도 제공한다.
