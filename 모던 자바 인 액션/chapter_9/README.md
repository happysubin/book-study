# chapter 9. 리팩터링, 테스팅, 디버깅

## section 9.1 가독성과 유연성을 개선하는 리팩터링

* 람다 표현식은 익명 클래스보다  코드를 좀 더 간결하게 만든다.
* 인수로 전달하려는 메서드가 이미 있을 때는 메서드 참조를 이용해서 람다보다 더 간결한 코드를 구현할 수 있다.
* 람다 표현식을 이용한 코드는 다양한 요구사항 변화에 대응할 수 있도록 동작을 파라미터화한다.
* 지금까지 배운 람다, 메서드 참조, 스트림 기능을 사용해 리팩터링을 진행하자.

### 9.1.1 코드 가독성 개선

* 일반적으로 코드 가독성이 좋다는 것은 '어떤 코드를 다른 사람도 쉽게 이해할 수 있음'을 의미한다.
* 코드 가독성을 높이려면, 문서화를 잘하고, 표준 코딩 규칙을 준수하는 등의 노력을 기울여야 한다.
* 익명 클래스를 람다 표현식으로 리팩ㅌ터링, 람다 표현식을 메서드 참조로 리팩터링, 명령형 데이터 처리를 스트림으로 리팩터링 예제를 진행한다.

### 9.1.2 익명 클래스를 람다 표현식으로 리팩터링하기

* 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 갖는다.
* 익명 클래스에서 this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 가리킨다.
* 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다, 하지만 람다 표현식으로는 변수를 가릴 수 없다.
* 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있다.
* 익명 클래스는 인스턴스화 할 때 명시적으로 형식이 정해지는 반면 람다의 형식은 콘텍스트에 따라 달라진다.
* 따라서 명시적 형변환을 이용해야한다.

### 9.1.3 람다 표현식을 메서드 참조로 리팩터링하기

* 리듀싱 연산은 메서드 참조화 함께 사용할 수 있는 내장 헬퍼 메서드를 다양하게 제공한다.
* 람다 표현식을 메서드 참조로 교체하는 예제를 살펴봄.

### 9.1.4 명령형 데이터 처리를 스트림으로 리팩터링하기

* 이론적으로는 반복자를 이용한 기존의 모든 컬렉션 처리 코드를 스트림 API로 바꿔야 한다.
* 스트림 API는 데이터 처리 파이프라인의 의도를 더 명확하게 보여준다.
* 스트림은 쇼트서킷과 게으름이라는 강력한 최적화뿐 아니라 멀티코어 아키텍처를 활용할 수 있는 지름길을 제공한다.

### 9.1.5 코드 유연성 개선

* 람다 표현식을 이용하면 동작 파라미터화를 쉽게 구현할 수 있다.
* 즉 람다를 전달해서 다양한 동작을 표현할 수 있다.
* 따라서 변화하는 요구사항에 대응할 수 있는 코드를 구현할 수 있다.
* 예를들어 프레디케이트로 다양한 필터링 기능을 구현하거나 비교자로 다양한 비교 기능을 만들 수 있다.

#### 함수형 인터페이스 적용

* 람다 표현식을 이용하려면 함수형 인터페이스가 필요하다.
* 따라서 함수형 인터페이스를 코드에 추가해야 한다.
* 이번에는 조건부 연기 실행과 실행 어라운드, 즉 두 가지 자주 사용하는 패턴으로 람다 표현식 리팩터링을 살펴본다.

#### 조건부 연기 실행

* 실제 작업을 처리하는 코드 내부에 제어 흐름문이 복잡하게 얽힌 코드를 흔히 볼 수 있다.
* 흔히 보안 검사나 로깅 관련 코드가 이처럼 사용된다.

```
if(logger.isLoggable(Level.FINER)){
    logger.finer("logging" + generateDiagnostic());
}
```

* 위 코드는 2가지 문제가 있다.
* logger의 상태가 isLoggable이라는 메서드에 의해 클라이언트 코드로 노출된다.
* 메시지를 로깅할 때마다 logger 객체의 상태를 매번 확인해야 할까? 이들은 코드를 어지럽힐 뿐이다.
* 다음처럼 메시지를 로깅하기 전에 logger 객체가 적절한 수준으로 설정되었는지 내부적으로 확인하는 log 메서드를 사용하는 것이 바람직하다.

``` 
logger.log(Level.FINER, "Problem: " + generateDiagnostic());
```

* 덕분에 불필요한 if문을 제거할 수 있으며 logger의 상태를 노출할 필요도 없으므로 위 코드가 더 바람직한 구현이다.
* 그러다 모든 문제가 해결된 것이 아니다.
* 즉 인수로 전달된 메시지 수준에서 logger가 활성되어 있지 않더라도 항상 로깅 메시지를 평가하게 된다.
* 람다를 이용하면 이 문제를 쉽게 해결할 수 있다.
* 특정 조건에서만 메시지가 생성될 수 있도록 메시지 생성 과정을 연기할 수 있어야 한다.
* 자바 8 API 설계자는 이와 같은 logger 문제를 해결할 수 있도록 Supplier를 인수로 갖는 오버로드된 log 메서드를 제공했다.
* 다음은 새로 추가된 log 메서드의 시그니처다.

```
public void log(Level level, Supplier<String> msgSupplier); 
```

* 아래처럼 log 메서드를 호출할 수 있다.

```
logger.log(Level.FINER, () -> "Problem: " + generateDiagnostic());
```

* 이 기법으로는 어떤 문제를 해결할 수 있을까?
* 만일 클라이언트 코드에서 객체 상태를 자주 확인하거나, 객체의 일부 메서드를 호출하는 상황이라면 내부적으로 객체의 상태를 확인한 다음에 메서드를 호출하도록 새로운 메서드를 구현하는 것이 좋다.
* 그러면 코드 가독성이 좋아질 뿐 아니라 캡슐화도 강화된다. 즉 객체 상태가 클라이언트 코드로 노출되지 않는다.

#### 실행 어라운드

* 3장에서 진행한 실행 어라운드 패턴을 살펴봄.

## section 9.2 람다로 객체지향 디자인 패턴 리팩토링하기

* 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리 패턴을 살펴본다.

### 9.2.1 전략

* 전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법이다.
* 함수형 인터페이스를 사용한 람다 표현식으로 전략 패턴을 구현. 즉 구현 클래스를 작성하지 않고도, 람다 표현식으로 동작 파라미터화를 유도함.

### 9.2.2 템플릿 메서드

* 템플릿 메서드 패턴은 필자가 이해하기로는 중복 코드를 추상 클래스 메서드에 구현하고 바뀔 가능성이 있는 코드는 추상 메서드를 구현한 구체 클래스에 코드로 넣는 것.
* 람다를 사용하면 동작 파라미터로 넘겨서 상속한 클래스를 만들지 않아도 된다.

### 9.2.3 옵저버

* 어떤 이벤트가 발생했을 때 한 객체가 다른 객체 리스트에 자동으로 알림을 보내야 하는 상황에서 옵저버 디자인 패턴을 많이 사용한다.
* 버튼 같은 GUI 컴포넌트에 옵저버를 설정할 수 있다.
* 사용자가 버튼을 누르면 옵저버에 알림이 전달되고 정해진 동작이 수행된다.
* 옵저버는 함수형 인터페이스다. 따라서 인터페이스를 구현한 구현 클래스 객체를 인자로 넣는게 아니라 람다식을 넣는다.
* 실행해야할 동적이 간단하면 람다 표현식으로 불필요한 코드를 제거하는 것이 바람직하다.
* 하지만 옵저버가 상태를 가지며, 여러 메서드를 정의하는 등 복잡하다면 람다 표현식보다는 기존의 클래스 구현 방식을 고수해야 한다.

### 9.2.4 의무 체인

* 작업 처리 객체의 체인(동작 체인 등)을 만들 때는 의무 체인 패턴을 사용한다.
* 한 객체가 어던 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달하는 식이다.
* 일반적으로 다음으로 처리할 객체 정보를 유지하는 필드를 포함하는 작업 처리 추상 클래스로 의무 체인 패턴을 구성한다.
* 작업 처리 객체가 자신의 작업을 끝냈으면 다음 작업 처리 객체로 결과를 전달한다.

### 9.2.5 팩토리

* 팩토리 메서드 패턴의 장점은 생성자와 설정을 외부로 노출하지 않음으로써 클라이언트가 단순하게 상품을 생상할 수 있다는 것이다.
* 생성자도 메서드 참조 처럼 접근할 수 있다.
* 팩토리 메서드 createProduct가 상품 생성자로 여러 인수를 전달하는 상황에서는 특별한 함수 인터페이스를 적용해야 한다.

## section 9.3 람다 테스팅

* 일반적으로 좋은 소프트웨어 공학자라면 프로그램이 의도대로 동작하는지 확인할 수 있는 단위 테스팅을 진행한다.

### 9.3.1 보이는 람다 표현식의 동작 테스팅

* 람다는 결국 익명이므로 테스트 이름을 호출할 수 없다.
* 따라서 필요하다면 람다를 필드에 저장해서 재사용할 수 있으며 람다의 로직을 테스트할 수 있다.
* 메서드를 호출하는 것처럼 람다를 사용할 수 있다.
* 람다 표현식은 함수형 인터페이스의 인스턴스를 생성한다는 사실을 기억하자.
* 따라서 생성된 인스턴스의 동작으로 람다 표현식을 테스트할 수 있다.

### 9.3.2 람다를 사용하는 메서드의 동작에 집중하라

* 람다의 목표는 정해진 동작을 다른 메서드에서 사용할 수 있도록 하나의 조각으로 캡슐화하는 것이다.
* 그러려면 세부 구현을 포함하는 람다 표현식을 공개하지 말아야 한다.
* 람다 표현식을 사용하는 메서드의 동작을 테스트함으로써 람다를 공개하지 않으면서도 람다 표현식을 검증할 수 있다.
* eqauls를 적절하게 오버라이딩해서 비교한다.

### 9.3.3 복잡한 람다를 개별 메서드로 분할하기

* 람다 표현식을 메서드 참조로 바꾸자. 그러면 일반 메서드를 테스트하듯이 람다 표현식을 테스트 할 수 있다.

### 9.3.3 고차원 함수 테스팅

* 함수를 인수로 받거나 다른 함수를 반환하는 메서드를 고차원 함수라고 한다. 이 경우에는 사용하기 더 어렵다.
* 메서드가 람다를 인수로 받는 다면 다른 람다로 메서드의 동작을 테스트할 수 있다.
* 테스트해야할 메서드가 다른 함수를 반환한다면 어떻게 해야 할까?
* 이때는 Comparator에서 살펴본 것처럼 함수형 인터페이스의 인스턴스로 간주하고 함수의 동작을 테스트할 수 있다.

## section 9.4 정리

* 디버깅할 때 개발자는 다음 두 가지를 가장 먼저 확인해야 한다.
* 스택 트레이스, 로깅이다.

### 9.4.1 스택 트레이스 확인

* 예를 들어 예외 발생으로 프로그램 실행이 갑자기 중단되었다면 먼저 어디에서 멈췄고 어떻게 멈추게 되었는지 살펴봐야 한다.
* 바로 스택 프레임에서 이 정보를 얻을 수 있다.
* 프로그램이 메서드를 호출할 때마다 프로그램에서의 호출 위치, 호출할 때의 인수 값, 호출된 메서드의 지역 변수 등을 포함한 호출 정보가 생성되며 이들 정보는 스택 프레임에 저장된다.
* 따라서 프로그램이 멈췄다면 프로그램이 어떻게 멈추게 되었는지 프레임별로 보여주는 스택 트레이스를 얻을 수 있다.
* 즉, 문제가 지점에 이르게 된 메서드 호출 리스트를 얻을 수 있다.
* 메서드 호출 리스트를 통해 문제가 어떻게 발생했는지 이해할 수 있다.

#### 람다와 스택 트레이스

* 람다 표현식은 이름이 없기 때문에 조금 복잡한 트레이스가 생성된다.

```
Exception in thread "main" java.lang.NullPointerException
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195)
	at java.base/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497)
	at chapter_9.Point.main(Point.java:64)
```

### 9.4.2 정보 로깅

* peek이라는 스트림 연산을 활용하면 각 요소를 소비한 것처럼 동작을 실행한다. 그러나 실제로 스트림의 요소를 소비하지 않는다.
* peek은 자신이 확인한 요소를 파이프라인의 다음 연산으로 그대로 전달한다.

## section 9.5 정리

* 람다 표현식으로 가독성이 좋고 더 유연한 코드를 만들 수 있다.
* 익명 클래스는 람다 표현식으로 바꾸는 것이 좋다. 하지만 이때 this, 변수 섀도 등 미묘하게 의미상 다른 내용이 있음을 주의하자.
* 메서드 참조로 람다 표현식보다 더 가독성이 좋은 코드를 구현할 수 있다.
* 반복적으로 컬렉션을 처리하는 루틴은 스트림 API로 대체할 수 있을지 고려하는 것이 좋다.
* 람다 표현식으로, 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리 등의 객체지향 디자인 패턴에서 발생하는 불필요한 코드를 제거할 수 있다.
* 람다 표현식도 단위 테스트를 수행할 수 있다. 하지만 람다 표현식 자체를 테스트하는 것 보다는 람다 표현식이 사용되는 메서드의 동작을 테스트하는 것이 바람직하다.
* 복잡한 람다 표현식은 일반 메서드로 재구현할 수 있다.
* 람다 표현식을 사용하면 스택 트레이스를 이해하기 어려워진다.
* 스트림 파이프라인에서 요소를 처리할 때 peek 메서드로 중간 값을 확인할 수 있다.