# chapter 2. 동작 파라미터화 코드 전달하기

* 동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.
* 동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다.
* 이 코드 블록은 나중에 프로그램에서 호출한다. 즉 코드 블록의 실행은 나중으로 미뤄진다.
* 예를 들어 나중에 실행될 메서드의 인수로 코드 블록을 전달할 수 있다.
* 결론적으로 코드 블록에 따라 메서드의 동작이 파라미터화된다. 
* 예를 들어 컬렉션을 처리할 때 다음과 같으 메서드를 구현한다고 가정하자.
  * 리스트의 모든 요소에 대해서 '어떤 동작'을 수행할 수 있음.
  * 리스트 관련 작업을 끝낸 다음에 '어떤 다른 동작'을 수행할 수 있음.
  * 에러가 발생하면 '정해진 어떤 다른 동작'을 수행할 수 있음.
* 동작 파라미터화로 이처럼 다양한 기능을 수행할 수 있다.

## section 2.1 변화하는 요구사항에 대응하기

* 기존의 농장 재고목록 애플리케이션에 리스트에서 녹색 사과만 필터링하는 기능을 추가하는 예시를 살펴봄.

### 2.1.1 첫 번째 요구사항. 녹색사과 필터링

* 초록 사과만 검증하는 로직이다.
* 만약 빨간 사과도 필터링 하고 싶다는 요구사항이 추가되면 어떨까? 현재 코드에서는 빨간 사과를 필터링 하는 추가적인 메서드를 만들어야한다.
* __거의 비슷한 코드가 반복 존재한다면 코드를 추상화하자.__

### 2.1.2 두 번째 시도: 색을 파라미터화

* 어떻게 해야 filterGreenApples의 코드를 반복 사용하지 않고 filterRedApples를 구현할 수 있을까?
* 색을 파라미터화 할 수 있도록 메서드에 파라미터를 추가하면 변화하는 요구사항에 좀 더 유연하게 대응하는 코드를 만들 수 있다.
* 무게를 처리하는 메서드에도 무게 정보 파라미터를 추가해 유연하게 요구사항을 만족했다.
* 위 코드도 좋은 예시지만, 코드를 자세히 보면 목록을 검색하고, 각 사과에 필터링 조건을 적용하는 부분의 코드가 색 필터링 코드와 대부분 중복된다.
* 이는 소프트웨어 공학의 DRY(같은 것을 반복하지마라) 원칙을 어기는 것이다.
* 탐색 과정을 고쳐서 성능을 개선하려면, 한 줄이 아니라 메서드 전체 구현을 고쳐야 한다. 즉 엔지니어링적으로 비싼 대가릴 치뤄야 하는 것이다.

### 2.1.3 세 번째 시도: 가능한 모든 속성으로 필터링

* 모든 조건일 조건문으로 검사한다. 형편없는 코드다. 요구사항이 바뀌면 유연하게 대응할 수 없다.
* 지금까지는 문자열, 정수, 불리언 등의 값으로 filterApples 메서드를 파라미터화 했다.
* 이제 동작 파라미터화를 이용해서 유연성을 얻을 것이다.

## section 2.2 동작 파라미터화

* *참 또는 거짓을 반환하는 함수를 프레디케이트(Predicate)라고 한다. 선택 조건을 결정하는 인터페이스를 정의했다.
* ApplePredicate는 사과 선택 전략을 캡슐화한다. 전략 패턴이 보인다.
* ApplePredicate는 filterApples에서 ApplePredicate 객체를 받아 애플의 조건을 검사하도록 메서드를 고치자.
* __이렇게 동작 파라미터화, 즉 메서드가 다양한 동작(전략)을 받아서 내부적으로 다양한 동작을 수행할 수 있다.__

### 2.2.1 네 번째 시도 : 추상적 조건으로 필터링

* 이제 필요한 대로 다양한 ApplePredicate를 만들어서 filterApples 메서드로 전달할 수 있다. 너무나도 유연해진 것이다.
* __우리가 전달한 ApplePredicate 객체에 의해 filterApples 메서드의 동작이 결정된다.__
* __즉 우리가 filterApples 메서드의 동작을 파라미터화한 것이다.__
* 메서드는 객체만 인수로 받으므로 test 메서드를 ApplePredicate 객체로 감싸서 전달해야 한다.
* 컬렉션 탐색 로직과 각 항목에 적용할 동작을 분리할 수 있다는 것이 동작 파라미터화의 강점이다.
* 퀴즈를 진행함. 지금까지 동작을 추상화해서 변화하는 요구사항에 대응할 수 있는 코드를 구현하는 방법을 살펴봄.
* 하지만 여러 클래스를 구현해서 인스턴스화하는 과정이 번거로움. 이 부분을 개선해보자.

## section 2.3 복잡한 과정 간소화

* 현재 filterApples 메서드로 새로운 동작을 전달하려면 ApplePredicate 인터페이스를 구현하는 여러 클래스를 정의한 다음 다음에 인스턴스화해야 한다. 상당히 번거롭고 시간 낭비다.
* __자바는 클래스의 선언과 인스턴스화를 동시에 수행할 수 있도록 익명 클래스라는 기법을 제공한다.__

### 2.3.1 익명 클래스

* __익명 클래스는 자바의 지역 클래스와 비슷한 개념이다.
* 익명 클래스는 말 그대로 이름이 없는 클래스다.
* 익명 클래스를 이용하면 클래스 선언과 인스턴스를 동시에 할 수 있다. 즉, 즉석에서 필요한 구현을 만들어서 사용할 수 있다.

## section 2.3.2 다섯 번째 시도: 익명 클래스 사용

* 익명 클래스를 사용해서 ApplePredicate를 구현하는 객체를 만들어서 filterApples 메서드에 파라미터로 적용.
* 익명 클래스도 단점이 있다. 코드에서 너무 많은 공간을 차지함. 또한 많은 프로그래머가 익명 클래스 사용에 익숙하지 않다.
* 코드의 장황함은 나쁜 특성이다. 한눈에 이해할 수 있는 코드가 좋은 코드다.
* 동작 파라미터화를 이용하면 요구사항 변화에 더 유연하게 대응할 수 있으므로 모든 프로그래머가 동작 파라미터화를 사용하도록 권장한다.

## section 2.3.3 여섯 번째 시도: 람다 표현식 사용

* 자바 8 람다 표현식을 이용해서 코드를 초 단순화 시켰다. 람다를 사용해 복잡성 문제를 해결했다.

## section 2.3.4 일곱 번째 시도: 리스트 형식으로 추상화

* 제네릭을 사용해 리스트 형식으로 추상화했다.
* 이제 어떤 객체(바나나, 오렌지, 정수, 문자열) 리스트에 필터 메서드를 적용할 수 있다.

## section 2.4 실전 예제

1. Comparator로 정렬하기
2. Runnable로 코드 블록 실행하기
3. Callable을 결과로 반환하기
4. GUI 이벤트 처리하기

위 와 같은 예제를 진행함

## 2.5 마치며

* 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
* 동작 파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며 나중에 엔지니어링 비용을 줄일 수 있다.
* 코드 전달 기법을 이용하면 동작을 메서드의 인수로 전달할 수 있다. 하지만 자바 8 이전에는 코드를 지저분하게 구현해야 했다.
* 익명 클래스로도 어느 정도 코드를 깔끔하게 만들 수 있지만 자바 8에서는 인터페이스를 상속받아 여러 클래스를 구현해야 하는 수고를 없앨 수 있는 방법을 제공한다.
* 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화할 수 있다.
* 동작 파라미터화를 할 수 있는 건 실습에서 진행한 클래스, 익명 클래스, 람다가 있다.


