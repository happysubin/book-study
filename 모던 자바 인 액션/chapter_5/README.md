# chapter 5. 스트림 활용

## section 5.1 필터링

* filter 메서드는 프레디케이트(불리언을 반환하는 함수)를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.
* 스트림은 고유 요소로 이루어진 스트림을 반환하는 distinct 메서드도 지원한다. 고유 여부는 객체의 hashCode, equals로 결정된다.

## section 5.2 스트림 슬라이싱

* 자바 9는 스트림의 요소를 선택하거나 스킵하는 다양한 방법을 제공한다. 프레디케이트를 이용하는 방법, 스트림의 처음 몇 개의 요소를 무시하는 방법, 특정 크기로 스트림을 줄이는 방법 등 다양한 방법을 이용해 효율적으로 이런 작업을 수행할 수 있다.
* 프레디케이트를 이용한 슬라이싱: 자바 9은 스트림의 요소를 효과적으로 선택할 수 있도록 takeWhile, dropWhile 두 가지 새로운 메서드를 지원한다.
* takeWhile은 처음으로 참이 되는 지점까지 진행한 요소를 제외하고는 버린다. takewhile을 사용하면 무한 스트림을 포함한 모든 스트림에 프레디케이트를 적용해 스트림을 슬라이스 할 수 있다.
* dropWhile는 takeWhile과 정반대의 작업을 수행한다. dropWhile은 프레디케이트가 처음으로 거짓이 되는 지점까지 발견한 요소를 버린다. 프레디케이트가 거짓이 되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다. dropWhile은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다.
* 스트림은 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 limit(n) 메서드를 지원한다.
* 스트림은 처음 n개 요소를 제외한 스트림을 반환하는 skip(n) 메서드를 지원한다. n개 이하의 요소를 포함하는 스트림에 skip(n)을 호출하면 빈 스트림이 반환된다.


## section 5.3 매핑

* 스트림은 함수를 인수로 받는 map 메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다.
* 문자열을 받아 스트림을 만드는 Arrays.stream() 메서드가 있다.
* flatMap을 사용하면 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다. 즉 하나의 평면화된 스트림을 반환한다. 
* flatMap 메서드는 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 한다.

## section 5.4 검색과 매칭

### 매칭

* 스트림 API는 allMatch, noneMatch, findFirst, findAny 등 다양한 유틸리티 메서드를 제공한다.
* 프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인할 때 anyMatch 메서드를 이용한다.
* allMatch 메서드는 anyMatch와 달리 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지 검사한다.
* noneMatch는 allMatch와 반대 연산을 수행한다. 즉, noneMatch는 주어진 프레디케이트와 일치하는 요소가 없는지 확인한다
* anyMatch, allMatch, noneMatch 세 메서드는 스트림 쇼트서킷 기법을 사용한다. &&, || 연산자와 동일하다.

### 쇼트서킷 기법

* 때로는 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있다.
* 예를 들어 여러 and 연산으로 연결된 커다란 불리언 표현식을 평가한다고 가정하자.
* 표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다.
* 이러한 상황을 쇼트 서킷이라고 한다. allMatch, findFirst 등의 연산은 모든 스트림의 요소를 처리하지 않고도 결과를 반환할 수 있다.
* 원하는 요소를 찾았으면 즉시 결과를 반환할 수 있다.
* 마찬가지로 스트림의 모든 요소를 처리할 필요 없이 주어진 크기의 스트림을 생성하는 limit도 쇼트 연산이다.
* 특히 무한한 요소를 가진 스트림을 유한한 크기로 줄일 수 있는 유용한 연산이다.

### 검색

* findAny 메서드는 현재 스트림에서 임의의 요소를 반환한다.
* findAny 메서드를 다른 스트림연산과 연결해서 사용할 수 있다.
* 스트림 파이프라인은 내부적으로 단일 과정으로 실행할 수 있도록 최적화된다.
* 즉, 쇼트서킷을 이용해서 결과를 찾는 즉시 실행을 종료한다. 
* 정렬된 연속 데이터로부터 첫 번째 요소를 찾을때는 findFirst 메서드를 사용하면 된다.
* findFirst와 findAny 메서드가 모두 필요할까? 
* 이유는 바로 병렬성 때문이다. 병렬 실행에서는 첫 번째 요소를 찾기 어렵다. 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 findAny를 사용한다.

## section 5.5 리듀싱

* 리듀스 연산을 이용해서 '메뉴의 모든 칼로리의 합계를 구하시오', '메뉴에서 칼로리가 가장 높은 요리는?' 같이 스트림 요소를 조합해서 더 복잡한 질의를 표현하는 방법을 설명한다.
* 이러한 질의를 수행하려면 Integer 같은 결과가 나올 때까지 스트림의 모든 요소를 반복적으로 처리해야 한다. 
* 이런 질의를 리듀싱(모든 스트림 요소를 처리해서 값으로 도출하는)이라고 한다.
* 함수형 프로그래밍 언어 용어로는 이 과정이 마치 종이(우리의 스트림)를 작은 조각이 될 때까지 반복해야 접는 것과 비슷하다는 의미로 폴드라고 부른다.
* p.171에서 reduce 메서드 동작과 병렬화 설명을 살펴봄.
* 맵과 리듀스를 연결하는 기법을 맴 리듀스 패턴이라고 하며, 쉽게 병렬화하는 특징 덕분에 구글이 웹 검색에 적용하면서 유명해졌다.

## section 5.6 실전 연습

* 알파벳순으로 이름을 정렬하는 부분이 인상깊었다.

## section 5.7 숫자형 스트림

* 스트림 API 숫자 스트림을 효율적으로 처리할 수 있도록 기본형 특화 스트림을 제공한다.
* 스트림을 특화 스트림으로 변환할 때는 mapToInt, mapToDouble, mapToLong 세 가지 메서드를 가장 많이 사용한다.
* 이들 메서드는 map과 정확히 같은 기능을 수행하지만 Stream<T> 대신 특화된 스트림을 반환한다.
* boxed 메서드를 사용해 숫자 스트림을 객체(Integer) 스트림으로 변환하는 코드를 살펴봤다.
* OptionalInt, OptionalDouble, OptionalLong와 같은 세 가지 기본형 특화 스트림 버전 Optional도 제공한다.
* 자바 8에서는 IntStream과 LongStream에서는 range와 rangeClosed라는 두 가지 정적 메서드를 제공한다.
* 두 메서드 모두 첫 번째 인수로 시작값을, 두 번째 인수로 종료값을 갖는다.
* range 메서드는 시작값과 종료값이 결과에 포함되지 않는 반면 rangeClosed는 시작값과 종료값이 결과에 포함된다는 점이 다르다.
* 피타고라스 예제도 살펴보았다.

## section 5.8 스트림 만들기

* 값으로 스트림 만들기. Stream.of를 사용
* null이 될 수 있는 객체로 스트림 만들기 System.getProperty, Stream.ofBullable을 사용
* 배열로 스트림 만들기. Arrays.stream 사용
* 파일로 스트림 만들기. 
* 함수로 무한 스트림 만들기
  * 먼저 iterate 메서드를 사용했다.
  * iterate는 요청할 때마다 값ㅇ르 생산할 수 있으며 끝이 없으므로 무한 스트림을 만든다.
  * 이러한 스트림을 언바운드 스트림이라고 표현한다.
  * 자바 9의 iterate 메서드는 프레디케이트를 지원한다. iterate는 takeWhile과도 함께 자주 사용한다.
* generate 메서드 사용
  * generate도 무한 스트림을 생성할 수 있다. 하지만 생산된 각 값을 연속적으로 계산하지는 않는다.
  * generate는 Supplier<T>를 인수로 받아서 새로운 값을 생성한다.
  * 상태를 갖는 발행자를 피해야한다고 한다. 발행자는 Supplier를 말한다. 병렬코드에서 발행자에 상태가 있으면 안전하지 않다는 것이다. 이는 추후에 7장에서 더 살펴본다.
  * 병렬 코드는 여러 곳에서 사용하는 코드인데 상태가 있으면 스레드가 상태를 동시에 여러개 참조하므로 데이터 정합성에 문제가 있을 것 같다는게 본인의 생각.
* 스트림을 병렬로 처리하면서 올바른 결과를 얻으려면 불변 상태 기법을 고수해야 한다. 이것도 추후 7장에서 다룬다.

## section 5.9 정리

* 스트림 API를 이용하면 복잡한 데이터 처리 질의를 표현할 수 있다.
* filter, distinct, takeWhile, dropWhile, skip, limit 메서드로 스트림을 필터링하거나 자를 수 있다.
* 소스가 정렬되어 있다는 사실을 알고 있을 때 takeWhile과 dropWhile 메서드를 효과적으로 사용할 수 있다.
* map, flatMap 메서드로 스트림의 요소를 추출하거나 변환할 수 있다.
* findFirst, findAny 메서드로 스트림의 요소를 검색할 수 있다. allMatch, noneMatch, anyMatch 메서드를 이용해서 주어진 프레디케이트와 일치하는 요소를 스트림에서 검색할 수 있다.
* 이들 메서드는 쇼트 서킷, 즉 결과를 찾는 즉시 반환하며, 전체 스트림을 처리하지 않는다.
* reduce 메서드로 스트림의 모든 요소를 반복 조합하며 값을 도출할 수 있다.
* filter, map 등은 상태를 저장하지 않는 상태 없는 연산이다. reduce 같은 연산은 값을 계산하는 데 필요한 상태를 저장한다.
* sorted, distinct 등의 메서드는 새로운 스트림을 반환하기에 앞서 스트림의 모든 요소를 버퍼에 저장해야 한다. 이런 메서드를 상태 있는 연산이라고 부른다.
* IntStream, DoubleStream, LongStream은 기본형 특화 스트림이다. 이들 연산은 각각의 기본형에 맞게 특화되어 있다.
* 컬렉션 뿐만 아니라 값, 배열, 파일, iterate와 generate 같은 메서드로도 스트림을 만들 수 있다.
* 무한한 개수의 요소를 가진 스트림을 무한 스트림이라고 한다.