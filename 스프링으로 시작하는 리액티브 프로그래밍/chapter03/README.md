
# chapter 03. Blocking I/O와 Non-Blocking I/O

운영체제 측면에서의 I/O는 일반적으로 컴퓨터 시스템이 외부의 입출력 장치들과 데이터를 주고 받는 것을 의미하며, 
I/O 작업의 대표적인 예로 디스크에 저장된 프로그램 실행파일을 읽어 들여 메모리에 올리는 것을 들 수 있다.

웹 애플리케이션 측면에서 제일 대표적인 I/O는 DB I/O가 있다.
그리고 다른 애플리케이션과 통신하는 네트워크 I/O가 존재한다.

### 3.1 Blocking I/O

* A API 서버에서 B 서버로 요청을 보내면 A 서버에서 실행된 스레드(요청 스레드)는 차단되어 B API 서버의 스레드(작업 스레드)가 처리를 끝내고 응답을 반환하기 전까지 대기한다.
* 이렇게 하나의 스레드가 I/O에 의해서 차단되어 대기하는 것을 Blocking I/O 라고 한다.

Blocking I/O 방식의 문제점을 보완하기 위해서 멀티스레딩 기법으로 추가 스레드를 할당해 차단된 그 시간을 효율적으로 사용할 수 있다.
그러나 몇 가지 문제점이 존재한다.

* 컨텍스트 스위칭으로 인한 스레드 전환 비용이 발생한다.
  * 프로세스의 정보를 PCB에 저장, reload하는 시간동안에는 CPU가 다른 작업을 하지 못하고 대기한다.
  * 당연히 컨텍스트 스위칭이 많으면 많을 수록 CPU의 전체 대기 시간은 길어지므로 성능이 저하된다.
  * 스레드간에도 스레드 컨텍스트 스위칭이 발생하는데, 비교적 PCB보다 적은 비용으로 TCB를 다룬다.
* 과다한 메모리 사용으로 오버헤드가 발생할 수 있다.
  * 일반적으로 서블릿 기반 자바 웹 애플리케이션은 요청당 하나의 스레드를 할당한다.
  * 각각의 스레드 내부에서 다른 작업을 처리하기 위해 스레드를 추가로 할당하면, 메모리 사용량이 늘어날 가능성이 있다.
* 스레드 풀에서 응답 지연이 발생할 수 있다.
  * 대량의 요청이 발생하게 되어 스레드 풀에 사용 가능한 유휴 스레드가 없을 경우, 사용 가능한 스레드가 확보되기 전까지 응답 지연이 발생한다.

### 3.2 Non-Blocking I/O

Non-Blocking I/O는  Blocking I/O와 반대로 스레드가 차단되지 않는다.

A 서버에서 B 서버로 요청을 보내면 Non-Blocking는 요청 스레드가 차단되지 않는다.
스레드가 차단되지 않으므로 하나의 스레드로 많은 수의 요청을 처리할 수 있다.

즉, Blocking I/O 방식보다 더 적은 수의 스레드를 사용하기 때문에 Blocking I/O에서 멀티 스레딩 기법을 사용할 때 발생한 문제점들이 생기지 않습니다.
따라서 CPU 대기 시간 및 사용량에 있어서도 대단히 효율적이다.

하지만 Blocking I/O 방식보다 뛰어난 성능을 보이는 Non-Blocking I/O 방식에도 단점이 존재한다.

* CPU를 많이 사용하는 작업이 포함된 경우에는 성능에 악영향을 준다.
* 사용자의 요청에서 응답까지의 전체 과정에 Blocking I/O 요소가 포함된 경우에는 Non-Blocking의 이점을 발휘하기 힘들다.

### 3.3 Spring Framework에서의 Blocking I/O와 Non-Blocking I/O

* 서블릿 기반은 Blocking으로 인해 25초 정도 걸림.
* Non-Blocking은 5.5초 정도 걸림.

참고로 웹플럭스 코드에서 Mono 역시 Publisher이므로 subscribe()를 호출해서 전달받은 데이터를 처리한다.

### 3.4 Non-Blocking I/O 방식의 통신이 적합한 시스템

Spring WebFlux를 도입하려면 다음과 같은 내용을 고려해야 한다,

* 학습 난이도가 높다.
* 리액티브 프로그래밍 경험이 있는 개발 인력을 확보하는 것이 과연 쉬운가

아래와 같은 애플리케이션에 WebFlux를 도입하는 것이 좋다.

* 대량의 요청 트래픽이 발생하는 시스템
* 컴포넌트간에 네트워크 호출이 많은 MSA 시스템
* 스트리밍 또는 실시간 시스템
