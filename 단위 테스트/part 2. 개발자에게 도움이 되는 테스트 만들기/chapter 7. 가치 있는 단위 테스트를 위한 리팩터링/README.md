# Chapter 7. 가치 있는 단위 테스트를 위한 리팩터링

함수형 애플리케이션을 사용할 수 없는 애플리케이션을 포함해 더 넓은 범위의 애플리케이션에 대한 방식으로 일반화한다.

## Section 1. 리팩터링할 코드 식별하기

### 코드의 네 가지 유형

이 절에서는 이 장의 나머지 부분을 위한 기초가 되는 네 가지 코드 유형을 설명한다.
모든 제품 코드는 2차원으로 분류할 수 있다.

* 복잡도 또는 도메인 유의성
* 협력자 수

코드 복잡도는 코드 내 의사 결정(분기) 지점 수로 정의한다. 이 숫자가 클수록 복잡도는 더 높아진다.
 
도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는지를 나타낸다.
일반적으로 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관성이 있으므로 도메인 유의성이 높다.
반면에 유틸리티 코드는 그런 연관성이 없다.
 
복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이롭다.
해당 테스트가 회귀 방지에 뛰어나기 때문이다. 도메인 코드는 복잡할 필요가 없으며, 복잡한 코드는 도메인 유의성이 나타나지 않아도 테스트할 만하다.
예를 들어 주문 가격 계산 메서드에 조간 문이 없다면 순환 복잡도는 1이다. 그러나 이런 메서드는 비즈니스에 중요한 기능이므로 테스트하는 것이 중요하다.
 
두 번째 차원은 클래스 또는 메서드가 가진 협력자 수다.
협력자는 가변 의존성이거나 프로세스 외부 의존성이다. 협력자가 많은 코드는 테스트 비용이 많이 든다.
테스트 크기에 따라 달라지는 유지 보수성 지표 때문이다. 협력자를 예상되는 조건으로 두고 상태나 상호 작용을 확인하게끔 코드를 작성해야 한다.
협력자가 많을수록 테스트도 커진다.

 
협력자의 유형도 중요하다. 도메인 모델이라면 프로세스 외부 협력자를 사용하면 안 된다. 테스트에서 목 체계가 복잡하기 때문에 유지비가 더 든다.
또한 리팩터링 내성을 잘 지키려면 아주 신중하게 목을 사용해야 하는데, 애플리케이션 경계를 넘는 상호 작용을 검증하는 데만 사용해야 한다.
프로세스 외부 의존성을 가진 모든 통신은 도메인 계층 외부의 클래스에 위임하는 것이 좋다. 그러면 도메인 클래스는 프로세스 내부 의존성에서만 동작하게 된다.
 
코드 복잡도, 도메인 유의성, 협력자 수의 조합으로 네 가지 코드 유형을 볼 수 있다.

* 도메인 모델과 알고리즘
* 간단한 코드
* 컨트롤러 : 도메인 클래스와 외부 애플리케이션 같은 다른 구성 요소의 작업을 조정한다.
* 지나치게 복잡한 코드: 이런 코드는 두 가지 지표 모두 높다. 협력자가 많으며 복잡하거나 중요하다. 예시로 덩치 큰 컨트롤러가 있다.

__도메인 모델과 알고리즘__ 을 단위 테스트하면 노력 대비 가장 이롭다. 즉 매우 가치 있고 저렴하다.
간단한 코드는 테스트할  필요가 없다.
컨트롤러의 경우, 포괄적인 통합 테스트의 일부로서 간단히 테스트해야 한다.
 
가장 문제가 되는 코드 유형은 지나치게 복잡한 코드다. 이런 코드는 많은 사람이 단위 테스트로 어려움을 겪는 주요 원인 중 하나다.
때때로 실제 구현이 까다로울 수 있지만, 지나치게 복잡한 코드를 알고리즘과 컨트롤러라는 두 부분으로 나누는 것이 일반적이다.

> 코드가 더 중요해지거나 복잡할수록 협력자는 더 적어야 한다.

지나치게 복잡한 코드를 피하고 도메인 모델과 알고리즘만 단위 테스트하는 것이 매우 가치 있고 유지보수가 쉬운 테스트 스위트로 가는 길이다.
하지만 이 방법으로도 테스트 커버리지를 100% 달성할 수 없으며, 이를 목표로 해서도 안 된다.
목표는 각각의 테스트가 프로젝틀 가치를 높이는 테스트 스위트다. 다른 모든 테스트를 리팩터링하거나 제거하자. 테스트 스위트의 크기를 부풀리지 말자.

> 좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다.

물론 지나치게 복잡한 코드를 제거하는 것은 쉬운일이 아니다. 이제 도움이 되는 기법을 살펴보자.

### 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

지나치게 복잡한 코드를 쪼개려면, __험블 객체 패턴__ 을 써야 한다.
 
코드가 프레임워크 의존성에 결합돼 있으면 테스트가 어렵다. 예를 들어, 비동기 또는 멀티스레드 실행, 사용자 인터페이스, 프로세스 외부 의존성과의 통신 등이 있다.
테스트 대상 코드의 로직을 테스트하려면, 테스트가 가능한 부분을 추출해야 한다.
결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 __험블 래퍼__ 가 된다.
이 험블 래퍼가 테스트하기 어려운 의존성과 새로 추출된 구성 요소를 붙이지만, 자체적인 로직이 거의 없거나 전혀 없으므로 테스트할 필요가 없다.
 
### 본인 생각
그냥 인터페이스를 도입하거나 중간 객체를 도입해서 의존성 결합을 약하게 만드는 것과 똑같은 방법인 것 같다.
 
험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙을 지키는 것이다. 
이 책임 중 하나로 늘 비즈니스 로직이 있는데, 이 패턴을 적용하면 비즈니스 로직을 거의 모든 것과 분리할 수 있다.
특정 상황을 예로 든다면 비즈니스 로직과 오케스트레이션을 분리하는 경우다. 
이렇게 분리를 진행하면 테스트 용이성이 좋아지고, 코드 복잡도를 해결하며, 장기적으로 프로젝트 성장에도 중요한 역할을 한다.
 
작가는 항상 테스트 가능한 설계가 어떻게 테스트를 용이하게 할 뿐만 아니라 유지 보수도 쉽게 해주는지를 흥미롭게 생각한다고 한다. 

## Section 2. 가치 있는 단위 테스트를 위한 리팩터링하기

샘플 프로젝트로 사용자 등록을 처리하는 CRM을 구현한다. 현재 시스템은 사용자 이메일 변경이라는 단 하나의 유스케이스만 지원한다.
 
이 연산에는 세 가지 비즈니스 규칙이 있다.

* 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇지 않으면 고객으로 간주한다.
* 시스템으 회사의 직원 수를 추적해야 한다. 사용자 유형이 직원에서 고객으로, 또는 그 반대로 변경되면 이 숫자도 변경해야 한다.
* 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야 한다.

맨 처음 초기 코드는 지나치게 복잡한 코드로 분류된다. 
도메인 클래스가 스스로 데이터베이스를 검색하고 다시 저장하는 이러한 방식을 __활성 레코드__ 패턴이라고 한다.

### 1단계: 암시적 의존성을 명시적으로 만들기

* 데이터베이스와 메시지 버스에 대한 인터페이스를 두고, 이 인터페이스를 User에 주입한 후 테스트에서 목으로 처리한다.
* 사실 결론은 도메인 모델은 프로세스 외부 협력자에게 의존하지 않는 것이 최고다.

### 2단계: 애플리케이션 서비스 계층 도입

* 도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러로 책임을 옮겨야 한다.

### 3단계: 애플리케이션 서비스 복잡도 낮추기

### 4단계: 새로운 Company 클래스 소개

결론을 말하면 설계가 잘 된 코드에서 깔끔한 테스트를 진행할 수 있다. 테스트를 쉽게 짤 수 있는 코드가 좋은 코드라고 생각한다.

## Section 3. 최적의 단위 테스트 커버리지 분석

1. 도메인 계층과 유틸리티 코드는 철저하게 테스트한다.
2. 복잡도가 낮고 협력자가 거의 없는 코드(ex 생성자)는 노력을 들일 필요가 없다.
3. 도메인적으로 의미가 있을 때 전제 조건(검증 조건)은 반드시 테스트해야 한다.

## Section 4. 컨트롤러에서 조건부 로직 처리

조건부 로직을 처리하면서 동시에 프로세스 외부 협력자 없이 도메인 계층을 유지 보수하는 것은 까다롭고 절충이 있기 마련이다. 이에 관해서 살펴본다.
 
비즈니스 로직과 오케스트레이션의 분리는 다음과 같이 비즈니스 연산이 세 단계로 있을 때 가장 효과적이다.

* 저장소에서 데이터 검색
* 비즈니스 로직 실행
* 데이터를 다시 저장소에 저장

그러나 비즈니스 연산 중에 프로세스 외부 의존성을 참조해야 하는 경우가 종종 존재한다.
이런 상황에서는 다음과 같이 세 가지 방법이 있다.

* 어쨋든 외부에 대한 모든 읽기와 쓰기를 외부로 밀어낸다. 단점은 성능이 저하된다. 필요 없는 경우에도 컨트롤러가 프로세스 외부 의존성을 호출한다.
* 도메인 모델에 프로세스 외부 의존성을 주입하고 비즈니스 로직이 해당 의존성을 호출할 시점을 직접 결정할 수 있게 한다.
* 의사 결정 프로세스 단계를 더 세분화하고, 각 단계별로 컨트롤러를 실행하도록 한다.

문제는 다 세 가지 특성의 균형을 맞추는 것이다.

* 도메인 모델 테스트 유의성: 도메인 클래스의 협력자 수와 유형에 따른 함수
* 컨트롤러 단순성: 의사 결정(분기) 지점이 있는지에 따라 다름
* 성능: 프로세스 외부 의존성에 대한 호출 수로 정의

위에서 언급한 방법은 세 가지 특성 중 두 가지 특성만 갖는다.

* 외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기: 컨트롤러를 계속 단순하게 하고 프로세스 외부 의존성과 도메인 모델을 분리하지만, 성능이 저하된다.
* 도메인 모델에 프로세스 외부 의존성 주입하기: 성능을 유지하면서 컨트롤러를 단순하게 하지만, 도메인 모델의 테스트 유의성이 떨어진다.
* 의사 결정 프로세스 단계를 더 세분화하기: 성능과 도메인 모델 테스트 유의성에 도움을 주지만, 컨트롤러가 단순하지 않다. 이렇나 세부 단계를 관리하려면 컨트롤러에 의사 결정 지점이 있어야 한다.

![KakaoTalk_Photo_2023-05-13-17-18-06](https://github.com/happysubin/book-study/assets/76802855/33126c0f-9cc4-4d44-b5aa-00be1febc7ed)


결론을 말하면 3번째 방법을 늘 고려해야 한다. 이 방식을 쓰면 컨트롤러를 더 복잡하게 만들기 때문에 지나치게 복잡한 사분면에 더 가까워지게 된다.
그러나 이 문제를 완화할 수 있는 방법이 있다.

### CanExecute/Execute 패턴 사용

컨트롤러 복잡도가 커지는 것을 완화하는 첫 번째 방법은 CanExecute/Execute 패턴을 사용해 비즈니스 로직이 도메인 모델에서 컨트롤러로 유출되는 것을 방지하는 것이다.
 
예제에서는 의사 결정 프로세스를 두 부분으로 나누었다.

* 이메일 변경 진행 여부(컨트롤러에서 수행)
* 변경 시 해야 할 일 (User에서 수행)

이러면 도메인 모델의 캡슐화가 떨어지므로, 이런 파편화를 방지하기 위해 User에 새 메서드(canChange)를 만든다.
그리고 이 메서드가 잘 실행되는 것을 이메일 변경의 전제 조건으로 한다고 한다.
이러면 컨트롤러는 더 이상 이메일 변경 프로세스를 알 필요가 없다고 하고, 전제 조건이 추가돼도 먼저 확인하지 않으면 이메일을 변경할 수 없도록 보장한다고 한다.
 
Validation과 관련된 객체를 뽑아서 validation을 다 진행하고, 로직을 수행하는 느낌..? 

> validation 도메인 검증 로직을 전부 진행하고, CUD를 진행하는 느낌이다.


이 패턴을 사용하면 도메인 계층의 모든 결정을 통합할 수 있다.

### 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적

도메인 모델을 현재 상태로 만든 단계를 빼기 어려울 때가 있다.
그러나 애플리케이션에서 정확히 무슨 일이 일어나는지 외부 시스템에 알려야 하기 때문에 이러한 단계들을 아는 것이 중요할지도 모른다.
컨트롤러에 이러한 책임도 있으면 더 복잡해진다. 
이를 피하려면, 도메인 모델에서 중요한 변경 사항을 추적하고 비즈니스 연산이 완료된 후 해당 변경 사항을 프로세스 외부 의존성 호출로 변환한다.
__도메인 이벤트__ 로 이러한 추적을 구현할 수 있다.

> 도메인 이벤트는 종종 시스템에서 발생하는 중요한 변경 사항을 외부 애플리케이션에 알리는 데 사용된다.

도메인 이벤트는 이미 일어난 일들을 나타내기 때문에 항상 과거 시제로 명명해야 한다. 
도메인 이벤트는 값이다. 둘 다 불변이고, 서로 바꿔서 쓸 수 있다.
 
도메인 이벤트를 적용하면서 로직이 수행되어야만, 이벤트 버스를 사용할 수 있음을 보장했다.
도메인 이벤트는 컨트롤러에서 의사 결정 책임을 제거하고 해당 책임을 도메인 모델에 적용함으로써 외부 시스템과의 통신에 대한 단위 테스트를 간결하게 한다.
컨트롤러를 검증하고 프로세스 외부 의존성을 목으로 대체하는 대신, 단위 테스트에서 직접 이벤트 생성을 테스트할 수 있다.

## Section 5. 결론

이 장의 주제는 외부 시스템에 대한 애플리케이션의 사이드 이펙트를 추상화하는 것이 었다.

* 비즈니스 연산이 끝날 때까지 이러한 사이드 이펙트를 메모리에 둬서 추상화하고, 프로세스 외부 의존성 없이 단순한 단위 테스트로 테스트할 수 있다.
* 도메인 이벤트는 메시지 버스에서 메시지에 기반한 추상화에 해당한다.
* 도메인 클래스의 변경 사항은 데이터베이스의 향후 수정사항에 대한 추상화다.

> 추상화할 것을 테스트하기보다 추상화를 테스트하는 것이 더 쉽다.
> 도메인 이벤트는 프로세스 외부 의존성 호출 위의 추상화에 해당한다.
> 도메인 클래스 변경은 데이터 저장소의 향후 수정에 대한 추상화에 해당한다.

도메인 이벤트와 CanExecute/Execute 패턴을 사용해 도메인 모델에 모든 의사 결정을 잘 담을 수 있었지만, 항상 그렇게 할 수는 없다.
비즈니스 로직 파편화가 불가피한 상황들이 있다. 
예를 들어 도메인 모델에 프로세스 외부 의존성을 두지 않고서는 컨트롤러 외부에서 이메일 고유성을 검증할 방법이 없다.
또 다른 예는 비즈니스 연산 과정을 변경해야 하는 프로세스 외부 의존성의 실패다. 
이런 로직을 컨트롤러에 넣고 통합 테스트로 처리해야 한다.
그러나 잠재적인 파편화가 있떠라도 비즈니스 로직을 오케스트레이션에서 분리하는 것은 많은 가치가 있다.
이렇게 분리하면 단위 테스트 프로세스가 크게 간소화되기 때문이다.
 
외부 계층의 관점에서 각 계층을 테스트하고, 해당 계층이 기저 계층과 어떻게 통신하는지는 무시하라.
이러한 계층을 하나씩 벗겨가면서 관점을 바구게 된다.
이전에 구현 세부사항이었던 것이 이제는 식별할 수 있는 동작이 되며, 이는 또 다른 테스트로 다루게 된다.





