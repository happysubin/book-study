# Chapter 6. 단위 테스트 스타일

## Section 1. 단위 테스트의 세 가지 스타일

단위 테스트는 다음과 같이 3가지 테스트 스타일이 있다.

1. 출력 기반
2. 상태 기반
3. 통신 기반

출력 기반 스타일의 테스트가 가장 품질이 좋고, 상태 기반 테스트는 두 번째로 좋은 선택이며, 통신 기반 테스트는 간헐적으로 사용해야 한다.
안타깝지만 출력 기반 테스트 스타일은 아무데서나 사용할 수 없으며, 순수 함수 방식으로 작성된 코드에만 적용된다.
그러나 출력 기반 테스트 형식으로 변환하는 데 도움이 되는 기법이 있다. 이를 위해 함수형 프로그래밍 원칙을 사용해 기반 코드가 함수형 아키텍처를 지향하게끔 재구성해야 한다.

### 출력 기반 테스트 정의

출력 기반 스타일은, 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식이다.
이러한 단위 테스트 스타일은 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.
출력 기반 단위 테스트 스타일은 함수형이라고도 한다. 

### 상태 기반 스타일 정의

상태 기반 스타일은 작업이 완료된 후 시스템 상태를 확인하는 것이다.
이 테스트 스타일에서 상태라는 용어는 SUT나 협력자 중 하나, 또는 DB나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다 .

### 통신 기반 스타일 정의

통신 기반 스타일은 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

> 단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 런던파는 이와 반대로 선택한다. 두 분파는 모두 출력 기반 테스트를 사용한다.

## Section 2. 단위 테스트 스타일 비교

### 회귀 방지와 피드백 속도 지표로 스타일 비교하기

회귀(버그) 방지 지표는 아래 세 가지 특성으로 결정된다.

1. 테스트 중에 실행되는 코드의 양
2. 코드의 복잡도
3. 도메인 유의성

1번은 스타일마다 크게 차이가 없다. 2번은 통신 기반 스타일에 예외가 있다. 남용하면 작은 코드 조각을 검증하고 다른 것은 모두 목을 사용하는 등 피상적인 테스트가 될 수 있다.
하지만 이는 통신 기반 테스트의 결정적인 특징이 아니라 기술을 남용하는 극단적인 예시다.
테스트 스타일과 테스트 피드백 속도에는 상관관계가 거의 없다.

### 리팩터링 내성 지표로 스타일 비교하기

출력 기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다.

상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다. 이러한 테스트는 테스트 대상 메서드 외에도 클래스 상태와 함께 작동한다.
확률적으로 말하면, 테스트와 제품 코드 간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성이 커진다.
상태 기반 테스트는 큰 API 노출 영역에 의존하므로, 구현 세부 사항과 결합할 가능성도 더 높다.
 
통신 기반 테스트가 허위 경보에 가장 취약하다. 테스트 대역으로 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽다.
이는 항상 스텁과 상호 작용하는 경우다. 이러한 상호 작용을 확인해서는 안 된다. 
__애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮다.__ 
리팩터링 내성을 잘 지키려면 통신 기반 테스트를 사용할 때 신중해야 한다.

### 유지 보수성 지표로 스타일 비교하기

유지 보수성은 단위 테스트의 유지비를 측정하며, 다음 두 가지 특성으로 정의한다.

* 테스트를 이해하기 얼마나 어려운가
* 테스트를 실행하기 얼마나 어려운가

테스트가 크면, 필요할 때 파악하기도 변경하기도 어려우므로 유지 보수가 쉽지 않다.
마찬가지로 하나 이상의 프로세스 외부 의존성과 직접 작동하는 테스트는 운영하는데 시간이 필요하므로 유지 보수가 어렵다.

* 출력 기반 테스트가 가장 유지 보수하기 용이하다.
* 상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지보수가 쉽지 않다.
* 통신 기반 테스트는 유지 보수성 지표에서 출력 기반 테스트와 상태 기반 테스트보다 점수가 낮다.

### 스타일 결론

세 가지 스타일 모두가 회귀 방지와 피드백 속도 지표에서는 점수과 같다. 따라서 리팩터링 내성, 유지비를 비교해보자.

|      | 출력 기반 | 상태 기반 | 통신 기반 |
|------|-------|-------|-------|
| 리팩터링 내성을 지키기 위해 필요한 노력 | 낮음    | 중간    | 높음    |
| 유지비  | 낮음    | 중간    | 높음    |

결론은 항상 다른 것보다 출력 기반 테스트를 선호하라는 것이다.
그러나 이것은 어려운 일이다. 출력 기반 스타일은 함수형으로 작성된 코드에만 적용할 수 있고, 대부분의 객체지향 프로그래밍 언어에는 해당하지 않는다.
 
그래도 테스트를 출력 기반 스타일로 변경하는 기법이 있다. 더 살펴보자.

## Section 3. 함수형 아키텍처 이해

__함수형 프로그래밍은 수학적함수를 사용한 프로그래밍이다.__
수학적 함수는 숨은 입출력이 없는 함수다. 수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성되는 메서드 시그니처에 명시해야 한다.
수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다.
 
입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지 보수하기 쉬우므로 테스트하기가 매우 쉽다.
출력 기반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수뿐이다. 이는 유지 보수성이 뛰어나고 거짓 양성 빈도가 낮다.
반면에 숨은 입출력은 코드를 테스트하기 힘들게 한다. 
 
숨은 입출력의 유형은 다음과 같다.

* 사이드 이펙트
  * 메서드 시그니처에 표시되지 않은 출력이다. 디스크의 파일을 업데이트, 클래스 인스턴스 상태 변경 등의 사이트 이펙트를 발생시킨다.
* 예외
* 내외부 상태에 대한 참조
  * LocalDate.now()와 같이 정적 속성을 사용해 현재 날짜와 시간을 가져오는 메서드가 있을 수도 있다.

### 함수형 아키텍처란?

사실 사이드 이펙트는 사용자 정보 업데이트, 장바구니에 새로운 주문 추가 등 모든 애플리케이션이 만들어내는 것이다.

> 함수형 프로그래밍의 목표는 사이드 이펙트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는 것이다.

이 두 가지 책임은 각각만 보더라도 충분히 복잡하다. 모두 고려하면 복잡도가 배가되고 장기적으로 코드의 유지 보수성을 방해한다.
 
함수형 아키텍처는 바로 이곳에 적용된다. 사이드 이펙트를 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 사이드 이펙트와 분리한다.
다음 두 가지 코드 유형을 구분해서 비즈니스 로직과 사이드 이펙트를 분리할 수 있다.

* 결정을 내리는 코드: 이 코드는 사이드 이펙트가 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
* 해당 결정에 따라 작용하는 코드: 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.

결정을 내리는 코드는 종종 함수형 코어라고도 한다. 해당 결정에 따라 작용하는 코드는 가변 셸이다.
함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.

* 가변 셸은 모든 입력을 수집한다.
* 함수형 코어는 결정을 생성한다.
* 셸은 결정을 사이드 이펙트로 변환한다.

이 두 게층을 계속 잘 분리하려면, 가변 셸이 의사 결정을 추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는지 확인해야 한다.
출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셸을 훪씬 더 적은 수의 통합 테스트에 맡기는 것이다.

## Section 4. 함수형 아키텍처와 출력 기반 테스트로의 전환

샘플 애플리케이션을 함수형 아키텍처로 리팩터링한다. 두 가지 리팩터링 단계를 볼 수 있다.

* 프로세스 외부 의존성에서 목으로 변경
* 목에서 함수형 아키텍처로 변경

리팩터링 과정 정리

1. 처음에는 모든 프로세스가 AuditManager 내부에서 수행되었다. 정렬, 파일 시스템 시스템 관리 등
2. 빠른 테스트를 위해 파일 시스템 분리를 위해 목을 사용했다. 즉 파일 관리를 맞는 역할의 인터페이스를 만들고 이를 목 객체를 만들어서 주입하고 테스트를 진행했다.
3. AuditManager가 파일 시스템에서 분리되므로, 공유 의존성이 사라지고 테스트를 서로 독립적으로 실행할 수 있다.
4. 파일 시스템과의 통신과 이러한 통신의 사이드 이펙트(파일 변경)는 애플리케이션의 식별할 수 있는 동작이므로 목을 사용하기에 타당한 유스케이스다.
5. 인터페이스 뒤로 사이드 이펙트를 숨기고 해당 인터페이스를 AuditManager에 주입하는 대신, 사이드 이펙트를 클래스 외부로 완전히 이동할 수 있다.
6. 그러면 AuditManager는 파일에 수행할 작업을 둘러싼 결정만 책임지게 된다. 새로운 클래스인 Persister는 그 결정에 따라 파일 시스템에 업데이트를 작용한다.
7. 마무리하면서 AuditManager와 Persister를 붙이려면 육각형 아키텍처 분류 체계상 애플리케이션 서비스라는 또 다른 클래스가 필요하다.

이제 한번 목 버전과 출력 기반 테스트를 비교해보자.

|         | 초기 버전 | 목 사용 | 출력 기반 |
|---------|-------|------|-------|
| 회귀 방지   | 좋음    | 좋음   | 좋음    |
| 리팩터링 내성 | 좋음    | 좋음   | 좋음    |
| 빠른 피드백  | 나쁨    | 좋음   | 좋음    |
| 유지 보수성  | 나쁨    | 중간   | 좋음    |


## Section 6. 함수형 아키텍처의 단점 이해하기

### 함수형 아키텍처 적용 가능성

예제의 감사 시스템은 결정을 내리기 전에 입력을 모두 미리 수집할 수 있으므로 함수형 아키텍처가 잘 작동했다.
그러나 종종 실행 흐름이 간단하지 않다. 의사 결정 절차와 중간 결과에 따라 프로세스 외부 의존성에서 추가 데이터를 질의할 수도 있다.

### 성능 단점

함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 간의 절충이다.
성능 영향이 그다지 눈에 띄지 않는 일부 시스템에서는 함수형 아키텍처를 사용해 유지 보수성을 향상시키는 편이 낫다.
다른 경우라면, 반대로 선택하자.

### 코드베이스 크기 증가

함수형 아키텍처는 함수형 코어와 가변 셸 사이를 명확하게 분리해야 한다. 궁극적으로 코드 복잡도가 낮아지고 유지보수성이 향상되지만, 초기에 코딩이 더 필요하다.
시스템의 복잡도와 중요성을 고려해 함수형 아키텍처를 전략적으로 사용하라. 특히 함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지말자.
 

잘 안와닿아서 그런가..? 그냥 목을 사용하는게 더 빠르고 편해보인다. 함수형은 제약도 많고, 복잡해보이는...

