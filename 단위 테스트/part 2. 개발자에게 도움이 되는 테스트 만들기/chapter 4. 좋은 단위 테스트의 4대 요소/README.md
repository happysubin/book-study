# Chapter 4. 좋은 단위 테스트의 4대 요소

앞에서 다음과 같이 좋은 단위 테스트 스위트의 특성을 살펴봤다.

* 개발  주기에 통합돼 있다. 실제로 사용하는 테스트에만 가치가 있다.
* 코드베이스의 가장 중요한 부분만을 대상으로 한다. 애플리케이션의 핵심을 다른 것과 구별하는 것이 중요하다.
* 최소한의 유지비로 최대 가치를 끌어낸다.
* 가치 있는 테스트 식별
* 가치 있는 테스트 작성

## Section 1. 좋은 단위 테스트의 4대 요소 살펴보기

1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

### 첫 번째 요소: 회귀 방지

회귀는 소프트웨어 버그다. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우다.
이러한 회귀는 귀찮지만 최악의 상황은 아니다. 최악인 것은 개발할 기능이 많을수록, 새로운 릴리스에서 하나라도 고장 날 가능성이 높다는 점이다.
코드베이스가 커질수록 잠재적인 버그에 더 많이 노출된다. 그렇기 때문에 회귀에 대해 효과적인 보호를 개발하는 것이 중요하다.
 
회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야 한다.

* 테스트 중에 실행되는 코드의 양
* 코드 복잡도
* 코드의 도메인 유의성

일반적으로 실행된느 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
또한 코드의 양뿐만 아니라 복잡도와 도메인 유의성도 중요하다. 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트(변화없이 여러 군데에서 반복되는 코드)보다 훨씬 더 중요하다.
비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 때문이다.
게다가 우리의 코드 외에 작성하지 않은 코드(라이브러리, 프레임워크 등)도 중요하다.
최상의 보호를 위해서는 테스트가 해당 라이브러리, 프레임워크, 외부 시스템을 테스트 범주에 포함시켜서 소프트웨어가 이러한 의존성에 대해 검증이 올바른지 확인한다.

> 회귀 방지를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.

### 두 번째 요소: 리팩터링 내성

좋은 단위 테스트의 두 번째 특성은 리팩터링 내성이다. 이는 테스트를 빨간색으로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.
 
하나의 상황을 가정해보자.
 
새로운 기능을 개발했고 모든 것이 잘 동작한다. 기능이 제 역할을 하며, 모든 테스트가 통과한다. 
리팩터링을 진행했고, 모든 것이 좋아보이는데 문제가 발생했다. 바로 테스트가 실패하는 것이다.

* 리팩터링으로 무엇이 고장났는지 살펴봤지만, 고장난 곳이 없었다.
* 기능은 예전과 같이 완벽하게 동작한다.
* 문제는 기반 코드를 수정하면 테스트가 빨간색으로 바뀌게끔 작성됐다는 것이다. 

이러한 상황을 __거짓 양성__ 이라고 한다. 실제로 기능이 의도한 대로 작동하지만 테스트는 실패를 나타내는 결과다.
이러한 거짓 양성은 일반적으로 코드를 리팩터링할 때, 즉 구현을 수정하지만 식별할 수 있는 동작은 유지할 때 발생한다.
따라서 좋은 단위 테스트의 한 가지 특성으로 이름 붙이자면 '리팩터링 내성'이라 할 수 있다.
 
리팩터링 내성 지표에서 테스트 점수가 얼마나 잘 나오는지 평가하려면 테스트에서 얼마나 많이 겆시 양성이 발생하는지 살펴봐야 좋다. 
 
왜 그렇게 거짓 양성을 신경쓸까? __전체 테스트 스위트에 치명적인 영향을 줄 수 있기 때문이다.__
테스트가 지속 가능한 성장을 하게 하는 메커니즘은 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가할 수 있는 것이다. 
여기에는 두 가지 장점이 있다.

* 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다. 이러한 조기 경고 덕분에 결함이 있는 코드가 운영 환경에 배포되기 훨씬 전에 문제를 해결할 수 있다. 운영 환경이었으면 문제를 처리하는데 훨씬 더 많은 노력이 필요했을 것이다.
* 코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다. 이러한 확신이 없으면 리팩터링을 하는 데 주저하게 되고 코드베이스가 나빠질 가능성이 훨씬 높아진다.

거짓 양성은 이 두 가지 이점을 모두 방해한다.

* 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 흐르면서 그러한 실패에 익숙해지고 그만큼 신경을 많이 쓰지 않는다. 이내 타당한 실패도 무시하기 시작해 기능이 고장 나도 운영 환경에 들어가게 된다.
* 반면에 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어지며, 더 이상 믿을 만한 안전망으로 인식하지 않는다. 즉 허위 경보로 인식이 나빠진다. 이렇게 신뢰가 부족해지면 리팩터링이 줄어든다. 회귀를 피하려고 코드 변경을 최소한으로 하기 때문이다.

### 무엇이 거짓 양성의 원인인가?

* 테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다.
* __테스트와 테스트 대상 시스템의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.__
* 거짓 양성이 생길 가능성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것 뿐이다.
* 테스트를 통해 SUT(target)이 제공하는 최종 결과를 검증하는지 확인해야 한다.
* 테스트는 최종 사용자의 관점에서 SUT를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다. 다른 모든 것은 무시해야 한다.

> SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다.

결국 테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것 뿐이다.
__즉, 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다.__
 
결론을 정리하면 거짓 양성은 대상 시스템의 내부 구현 세부 사항과 테스트 간의 강결합의 결과다. 결합도를 낮추려면 테스트는 SUT가 수행한 단계가 아니라 SUT가 만든 최종 결과를 검증해야 한다.

## Section 2. 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

이 절에서 다룰 내용은 다음과 같다.

* 테스트 정확도 극대화
* 거짓 양성과 거짓 음성의 중요성

코드 정확도와 테스트 결과에 대해서는 아래와 같이 네 가지 결과가 있을 수 있다.

<img width="515" alt="스크린샷 2023-05-08 오후 8 37 16" src="https://user-images.githubusercontent.com/76802855/236814197-5781dc58-9f79-4e9a-abb3-b3f2d99a558e.png">

* 거짓 음성을 피하는 데 좋은 테스트의 첫 번째 특성인 회귀 방지가 도움이 된다.
* 거짓 양성을 피하는 데 좋은 테스트의 두 번째 특성인 리팩터링 내성이 도움이 된다.
* 회귀 방지와 리팩터링 내성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 한다.

정확도 지표는 다음 두 가지 요소로 구성된다.

* 테스트가 버그 있음을 얼마나 잘 나타내는가(거짓 음성(회귀 방지 영역) 제외)
* 테스트가 버그 없음을 얼마나 잘 나타내는가(거짓 양성(리팩터링 내성 영역) 제외)

테스트 정확도에 관한 공식은 아래와 같다.

> 테스트 정확도 = 신호(발견된 버그 수) / 소음 (허위 경보 발생 수)

즉 테스트 정확도를 향상시키는 방법은 두 가지다.

1. 첫 번째는 분자, 신호를 증가시키는 것이다. 이는 회귀를 더 잘 찾아내는 테스트로 개선하는 것이다.
2. 두 번째는 분모, 소음을 줄이는 것이다. 허위 경보를 발생시키지 않는 테스트로 개선하는 것이다.

거짓 양성에 신경쓰는 개발자는 드물다. 대부분 회귀 방지에만 중점을 두는 경향이 있다.
중대형 프로젝트에서 작업하면, 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울여야 한다.

## Section 3. 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

좋은 단위 테스트의 특성 중 남은 두 가지 요소는 아래와 같다.

* 빠른 피드백
  * 테스트 속도가 빠를 수록 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다.
  * 테스트가 빠르게 실행되면 코드에 결함이 생기자마자 버그에 대해 경고하기 시작할 정도로 피드백 루프를 대폭 줄여서, 버그를 수정하는 비용을 거의 0까지 줄일 수 있다.
  * 반면 느린 테스트는 피드백을 느리게 하고 잠재적으로 버그를 뒤늦게 눈에 띄게 해서 버그 수정 비용이 증가한다.
* 유지 보수성
  * 유지 보수성 지표는 아래 두 가지 지표로 이루어진다.
  * 테스트가 얼마나 이해하기 어려운가 -> 테스트는 코드 라인이 적을수록 더 읽기 쉽다.
    * 테스트 코드의 품질은 제품 코드만큼 중요하다. 테스트를 작성할 때 절차를 생략하지 말아라
  * 테스트가 얼마나 실행하기 어려운가
    * 프로세스 외부 종속성에 의존하면 상시 운영하는 데 시간을 들여야 한다.

## Section 4. 이상적인 테스트를 찾아서

회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성 이 네 가지 특성을 곱하면 테스트의 가치가 결정된다.
여기서 곱셈은 수학적인 의미의 곱셈이다. 즉, 어떤 특성이라도 0이 되면 전체가 0이 된다.
 
물론 이런 특성을 정확하게 측정하는 것은 불가능하다. 그러나 네 가지 특성과 관련해서 테스트가 어디쯤 있는지는 비교적 정확하게 평가할 수 있다.
테스트 코드를 포함한 모든 코드는 __책임__ 이다. 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라.
소수의 매우 가치 있는 테스트는 다수의 평범한 테스트보다 프로젝트가 계속 성장하는 데 훨씬 더 효과적이다.

### 이상적인 테스트를 만들 수 있는가?

각 속성마다 최솟값과 최댓값을 각각 0과 1로 했을 때 이상적인 테스트는 모두 1을 얻어야 한다. 그러나 이는 불가능하다.
처음 세 가지 특성인 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다.
 
다른 특성에 집중하려고 하나의 특성을 버릴 수는 없다. 네 가지 범주 중 하나에서 0점을 받는 테스트는 가치가 없다.
__따라서 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 한다.__
 
두 특성을 최대로 하는 것을 목표로 해서 한 가지 특성을 희생해 결국 가치가 0에 가까워진 테스트를 살펴보자.

1. 엔드 투 엔드 테스트
   * 엔드 투 엔드 테스트는 많은 코드를 테스트하므로 회귀 방지를 훌륭히 해낸다.
   * 또한 거짓 양성에 면역이 돼 리팩터링 내성도 우수하다. 리팩터링은 식별할 수 있는 동작을 변경하지 않으므로 엔드 투 엔드 테스트에 영향을 미치지 않는다.
   * 엔드 투 엔드 테스트의 큰 단점은 바로 느린 속도다. 따라서 피드백을 빨리 받기 어렵다.
2. 간단한 테스트
   * 매우 빠르게 실행되고 빠른 피드백을 제공한다. 
   * 또한 거짓 양성이 생길 가능성이 상당히 낮기 때문에 리팩터링 내성도 우수하다.
   * 그러나 기반 코드에 실수할 여지가 많지 않기 때문에 간단한 테스트는 회귀를 나타내지 않을 것이다. 즉 회귀 방지가 없다는 것이 단점이다.
3. 깨지기 쉬운 테스트
   * 실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트를 작성하기가 매우 쉽다.
   * 이러한 테스트를 __깨지기 쉬운 테스트__ 라고한다.
   * 이는 리팩터링을 견디지 못하고, 해당 기능이 고장 났는지 여부와 관계 없이 빨간색으로 바뀐다.
   * 객체의 내부 구현에 종속적인(SQL 문법 검증) 테스트 코드를 봄.

### 이상적인 테스트를 찾아서

결론은 세 가지 특성 모두 완벽한 점수를 얻어서 이상적인 테스트를 만드는 것은 불가능하다.

* 좋은 테스트를 만드는 특성 간에 균형을 이뤄내는 것은 쉽지 않다. 절충해야 한다.
* 어떤 특성도 0이 되지 않는 식으로 절충해야 한다. 부분적으로 그리고 전략적으로 희생해야 한다.
* 리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야 한다.
* 따라서 테스트가 얼마나 버그를 잘 찾아내는지와 얼마나 빠른지 사이의 선택으로 절충이 귀결된다.

> 테스트 스위트를 탄탄하게 만드려면 테스트의 불안정성(거짓 양성)을 제거하는 것이 최우선 과제다.

## Section 5. 대중적인 테스트 자동화 개념 살펴보기

### 테스트 피라미드 분해

* 테스트 피라미드는 종종 세 가지 유형의 테스트가 있는 피라미드로 표현한다. 
* 피라미드 각 층의 너비는 테스트 스위트에서 해당 테스트가 얼마나 보편적인지를 나타낸다.
* 즉 넓을수록 해당 테스트는 많아진다.
* 층의 높이느 이러한 테스트가 최종 사용자의 동작을 얼마나 유사하게 흉내 내는지 나타내는 척도다.
* 엔드 투 엔드 테스트가 가장 위에 임ㅆ고, 이는 사용자 경험에 가장 가깝게 흉내 내는 것을 의미한다.

피라미드 내 테스트 유형에 따라 빠른 피드백과 회귀 방지 사이에서 선택을 한다. 피라미드 상단의 테스트는 회귀 방지에 유리한 반면, 하단은 실행 속도를 강조한다.
 
어느 계층도 리팩터링 내성을 포기하지 않는다. 단위 테스트도 마찬가지다. 모든 테스트는 거짓 양성을 가능한 한 적게 하는 것을 목표로 해야 한다.
심지어 제품 코드로 직접 작업할 때도 그래야 한다.

엔드 투 엔드 테스트가 가장 적고, 단위 테스트가 가장 많으며, 통합 테스트는 중간 어딘가에 있어야 한다.

테스트 피라미드에도 예외가 존재한다. 비즈니스 규칙이 단순 CRUD와 단순 알고리즘이면 얘기가 다르다.

> 단위 테스트는 알고리즘이나 비즈니스 복잡도가 없는 환경에서는 유용하지 않으므로 간단한 테스트 수준까지 빠르게 내려간다.
> 반면 통합 테스트는 그 가치가 잘 지켜진다. 코드가 아무리 단순하더라도 데이터베이스와 같이 다른 하위 시스템과 잘 동작하는지 확인하는 것이 중요하다.

결국 단위 테스트는 적어지고 통합 테스트가 더 많아진다. 이런 단순한 예에서는 통합 테스트가 단위 테스트보다 더 많을 수 있다.

### 블랙박스 테스트와 화이트박스 테스트 간의 선택

* 블랙박스 테스트는 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다.
* 화이트박스 테스트는 애플리케이션의 내부 작업을 검증하는 방식이며, 테스트 요구 사항이나 명세가 아닌 소스 코드에서 파생된다.

화이트 박스 테스트가 더 철저한 편이다. 반면에 테스트 대상 코드의 툭정 구현과 결합돼 있기 때문에 깨지기 쉽다.

> 결론은 '화이트박스 테스트 대신 블랙박스 테스트를 기본으로 선택하자'이다. 
> 모든 테스트가 시스템을 블랙박스로 보게 만들고 문제 영역에 의미 있는 동작을 확인하라.

테스트를 작성할 때는 블랙박스 테스트가 바람직하지만, 테스트를 분석할 때는 화이트박스 방법을 사용할 수 있다.
코드 커버리지 도구를 사용해서 어떤 코드 분기를 실행하지 않았는지 확인한 다음 코드 내부 구조에 대해 전혀 모르는 것처럼 테스트하라.




