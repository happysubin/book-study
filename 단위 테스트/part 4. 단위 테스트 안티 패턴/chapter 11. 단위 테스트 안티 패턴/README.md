# Chapter 11. 단위 테스트 안티 패턴

## Section 1. 비공개 메서드 단위 테스트

* 비공개 메서드를 노출하면 테스트가 구현 세부 사항과 결합되고 결과적으로 리팩터링 내성이 떨어진다.
* 비공개 메서드를 직접 테스트하는 대신, 포괄적인 식별할 수 있는 동작으로서 간접적으로 테스트하는 것이 좋다.
* 비공개 메서드가 너무 복잡해서 공개 API로 테스트할 수 없다면, 추상화가 누락됐다는 뜻이다.
* 비공개 메서드를 공개로 하지 말고 해당 추상화를 별도 클래스로 추출하라.

<br>

## Section 2. 비공개 상태 노출

* 비공개였던 상태를 단위 테스트만을 위해 노출하지 말라.
* 테스트는 제품 코드와 같은 방식으로 테스트 대상 시스템과 상호작용해야 한다.
* 어떠한 특권도 가져서는 안되기 때문이다.

예시에서는 enum 값에 따라 할인율을 리턴하는데, 이 할인율만 테스트해도 충분하다고 말하는 것 같다.

> 테스트 유의성을 위해 공개 API 노출 영역을 넓히는 것은 좋지 않은 관습이다.

<br>

## Section 3. 테스트로 유출된 도메인 지식

* 테스트를 작성할 때 특정 구현을 암시하지 말라.
* 블랙박스 관점에서 제품 코드를 검증하라.
* 또한 도메인 지식을 테스트에 유출하지 않도록 하라.

> 직관적이지 않아 보일 수 있지만, 단위 테스트에서는 예쌍 결과를 하드 코딩하는 것이 좋다.
> 하드 코딩된 값의 중요한 부분은 SUT가 아닌 다른 것을 사용해 미리 계산하는 것이다.
> 물론 알고리즘이 복잡한 경우메만 그렇다.

코드 예시를 보면 파라미터화된 테스트가 도메인 지식이 없으므로 좋다고 말하는 것 같다.

<br>

## Section 4. 코드 오염

* 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것이다.
* 이는 테스트 코드와 제품 코드가 혼재되게 하고 제품 코드의 유지비를 장가시키기 때문에 안티 패턴이다.

> 본인은 생성자 정도는 괜찮다고 생각하는데... 흠...

<br>

## Section 5. 구체 클래스 목으로 처리

* 기능을 지키려고 구체 클래스를 목으로 처리해야 하면, 이는 단일 책임 원칙을 위배하는 결과다.
* 해당 클래스를 두 가지 클래스 ,즉 도메인 로직이 있는 클래스와 프로세스 외부 의존성과 통신하는 클래스로 분리해라.

결국 도메인 로직과 인프라스트럭쳐를 분리한 것

## Section 6. 시간 비공개 메섣처리하기

> 앰비언트 컨텍스트(ambient context)는 프로그래밍에서 실행 중인 코드의 환경과 관련된 정보를 전역적으로 접근 가능한 컨텍스트로 관리하는 패턴

예시 코드는 앰비언트 컨텍스트에서 정적 메서드를 통해 참조하는 방법을 안티 패턴으로 보여준다.
 

* 현재 시간을 앰비언트 컨텍스트로 하면 제품 코드가 오염되고 테스트하기가 더 어려워진다.
* 서비스나 일반 값의 명시적인 의존성으로 시간을 주입하라.
* 가능하면 항상 일반 값이 좋다.



