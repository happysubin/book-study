# Chapter 10. 데이터베이스 테스트

## Section 1. 데이터베이스 테스트를 위한 전제 조건

### 조건 1. 형상 관리 시스템에 데이터베이스 유지

* 데이터베이스 스키마를 일반 코드로 취급
* 일반 코드와 마찬가지로 데이터베이스 스키마는 Git과 같은 형상 관리 시스템에 저장하는 것이 최선
* 참조 데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터이다.
* 참조 데이터도 데이터 베이스 스키마다.

> 애플리케이션이 데이터를 수정할 수 있으면 일반 데이터이고, 그렇지 않으면 참조 데이터다. (긱사생 프로젝트 카테고리 느낌)

### 조건 2. 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용

테스트 데이터베이스를 공유하면 다음과 같은 문제가 발생한다.

1. 서로 다른 개발자가 실행한 테스트는 서로 간섭된다.
2. 하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있다.

테스트 실행 속도를 극대화하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용하자.

### 조건 3. 데이터베이스 배포에 마이그레이션 기반 방식 적용

### 상태 기반 방식

* 개발 내내 유지 보수하는 모델 데이터베이스가 있다.
* 배포 중에 비교 도구가 스크립트를 생성해서 운영 데이터베이스를 모델 데이터베이스와 비교해 최신 상태로 유지한다.
* 상태 기반 방식을 사용하면 물리적인 모델 데이터베이스는 원천 데이터가 아니라는 것이다.
* 대신 해당 데이터베이스를 작성하는 데 사용할 수 있는 SQL 스크립트가 있다. 
* 스크립트는 형상 관리에 저장된다.

### 마이그레이션 방식

* 데이터베이스를 어떤 버전에서 다른 버전으로 전환하는 명시적인 마이그레이션을 의미한다.
* 이 방식은 운영 데이터베이스와 개발 데이터베이스를 자동으로 동기화하기 위한 도구를 쓸 수 없고, 업그레이드 스크립트를 직접 작성해야 한다.
* 하지만 운영 데이터베이스 스키마에서 문서화되지 않은 변경 사항을 발견할 때 데이터베이스 비교 도구가 유용할 수 있다.

### 상태 기반 방식보다 마이그레이션 기반 방식을 선호하라

* 상태 기반 방식은 상태를 형상 관리에 저장함으로써 상태를 명시하고 비교 도구가 마이그레이션을 암묵적으로 제어할 수 있게 한다.
* 마이그레이션 기반 방식은 마이그레이션을 명시적으로 하지만 상태를 암묵적으로 둔다. 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다.
 
데이터베이스 상태가 명확하면 병합 충돌을 처리하기가 수월한 반면, 명시적 마이그레이션은 데이터 모션 문제를 해결하는 데 도움이 된다.

> 데이터 모션은 새로운 데이터베이스 스키마를 준수하도록 기존 데이터의 형태를 변경하는 과정이다.

병합 충돌 완화와 데이터 모션 용이성은 똑같이 중요한 이점처럼 보일 수 있지만, 대부분의 프로젝트에서는 데이터 모션이 병합 충돌보다 훨씬 더 중요하다. 
 
아직 애플리케이션을 운영 환경에 릴리스하지 않은 경우가 아니라면 쉽게 폐기할 수 없는 데이터가 반드시 있을 것이다.

> 마이그레이션을 통해 데이터베이스 스키마에 모든 수정 사항을 적용하라
> 형상 관리에 마이그레이션이 커밋 된 후에는 수정하지 말라
> 마이그레이션이 잘못된 경우 이전 마이그레이션을 수정하는 대신 새 마이그레이션을 생성하라.
> 잘못된 마이그레이션으로 인해 데이터가 손실될 수 있는 경우에만 이 규칙을 예외로 하라.

<br>

## Section 2. 데이터베이스 트랜잭션 관리

### 제품 코드에서 데이터베이스 트랜잭션 관리하기

* 비즈니스 연산은 데이터를 원자적으로 업데이트해야 한다.
* 원자성을 얻으려면 데이터베이스 트랜잭션 메커니즘에 의존하자.
* 가능하면 작업 단위 패턴을 사용해라.
* 작업 단위는 데이터베이스 트랜잭션에 의존하며, 비즈니스 연산 종료 시점까지 업데이트를 모두 지연시켜서 성능을 향상시킨다.

### 통합 테스트에서 데이터베이스 트랜잭션 관리하기

* 테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라.
* 작업 단위를 재사용하는 것은 운영 환경에서 하는 것과 다른 환경을 만들기 때문에 문제가 된다.
* 준비, 실행, 검증 구절에 각각 고유의 트랜잭션이나 작업 단위가 있어야 한다.

<br>

## Section 3. 테스트 데이터 생명 주기

공유 데이터베이스를 사용하면 통합 테스트를 서로 분리할 수 없다는 문제가 생긴다. 이 문제를 해결하려면,

* 통합 테스트를 순차적으로 실행한다.
* 테스트 실행 간에 남은 데이터를 제거한다.

통합 테스트는 순차적으로 실행하자. 데이터베이스는 개발자당 하나의 인스턴스만 갖는 것이 제일 실용적이다.

### 테스트 실행 간 데이터 정리

* 각 테스트 전에 데이터베이스 백업 복원하기 -> 너무 느림
* 테스트 종료 시점에 데이터 정리하기
* 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기 -> 스프링 테스트 트랜잭션 방식인 듯. 운영 환경과 다른 설정이 아쉬운 점
* 테스트 시작 시점에 데이터 정리하기 -> 이게 최고라고 함

### 인 메모리 데이터베이스 피하기

* 인메모리 데이터베이스는 일반 데이터베이스와 기능적으로 일관성이 없기 때문에 사용하지 않는 것이 좋다.
* 운영환경과 테스트 환경이 일치하지 않는 문제가 발생.
* 테스트에서도 운영 환경과 같은 데이터베이스 관리 시스템을 사용하라.

<br>

## Section 4. 테스트 구절에서 코드 재사용하기

* 준비 구절 or given 구절에서 팩토리 패턴을 활용한 오브젝트 마더를 사용하자.
* 실행 구절 or when 구절에서 데코레이터 메서드를 작성하자.
* 검증 구절 or then 구절에서 플루언트 인터페이스를 사용하자.

> 본인은 실행 구절은 그냥 명시적으로 두고 준비 구절과 검증 구절을 재사용하는 것이 좋다고 생각한다. 

> given 구절에서 재사용하는 구문도 많으므로 그냥 팩토리 메서드를 별도의 클래스로 빼는 것이 좋다고 생각한다.


### 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?

데이터베이스 컨텍스트를 추가하면 테스트가 느려지기 때문에 어느 정도 문제가 되기는 하지만, 할 수 있는 것은 많지 않다. 결국 절충안을 찾아야 한다.
 
__이러한 경우는 유지 보수성을 위해 성능을 양보함으로써 절충하는 것이 좋다.__

<br>

## Section 5. 데이터베이스 테스트에 대한 일반적인 질문

### 읽기 테스트를 해야하는가?

* 가장 복잡하고 중요한 읽기 작업만 테스트, 나머지는 무시하자.

### 리포지터리는 테스트해야하는가?

* 리포지터리는 직접 테스트하지 않고 포괄적인 통합 테스트 스위트로 취급하자.
* 리포지터리 테스트는 회귀 방지에 대한 이득이 너무 적은 데 반해 유지비가 너무 높다. ex: SQL에 의존하는 경우


