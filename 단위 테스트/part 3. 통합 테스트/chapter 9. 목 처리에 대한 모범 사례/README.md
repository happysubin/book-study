# Chapter 9. 목 처리에 대한 모범 사례

## Section 1. 목의 가치를 극대화하기

### 시스템 끝에서 상호 검증하기

* 목을 사용할 때 항상 다음 지침을 따르자. 시스템 끝에서 비관리 의존성과의 상호작용을 검증하라.
* 비관리 의존성에 대한 호출은 애플리케이션을 떠나기 전에 몇 단계를 거친다.
* 마지막 단계를 선택하자. 외부 시스템과의 하위 호환성을 보장하는 가장 좋은 방법이며, 하위 호환성은 목을 통해 달성할 수 있는 목표다.

<br>

### 목을 스파이로 대체하기

* 스파이는 수동으로 작성하는 반면에 목은 목 프레임워크의 도움을 받아 생성하는 것이 유일한 차이점이다.
* 시스템 끝에 있는 클래스의 경우 스파이가 목보다 낫다.
* 스파이는 검증 단계에서 코드를 재사용해 테스트 크기를 줄이고 가독성을 향상시킨다.
* 검증문을 작성할 때 제품 코드에 의존하지 말자. 테스트에서 별도의 리터럴과 상수 집합을 사용하자. 필요하면 리터럴과 상수는 복제하자.
* 테스트는 제품 코드와 독립적으로 검사점을 제공해야한다.

<br>

### DomainLogger의 경우는?

* 모든 비관리 의존성에 하위 호환성이 동일한 수준으로 필요한 것은 아니다.
* 메시지의 정확한 구조가 중요하지 않고 메시지의 존재 여부와 전달하는 정보만 검증하면 시스템의 끝에서 비관리 의존성과의 상호 작용을 검증하라는 지침을 무시할 수 있다.
* 대표적인 예가 로깅이다.
* 반면 메시징 큐는 메시지 구조가 중요하므로 시스템 끝에서 상호 검증하는 것이 좋다.

<br>

## Section 2. 목 처리에 대한 모범 사례

현재까지 목 처리에 대해 2가지 모범 사례를 배웠다.

* 비관리 의존성에만 목 적용하기
* 시스템 끝에 있는 의존성에 대해 상호 작용 검증하기

이번에는 몇 가지 모범 사례를 추가한다.

<br>

### 통합 테스트에서만 목을 사용하고 단위 테스트에서는 사용하지 않기

<br>

### 테스트당 목이 하나일 필요는 없다.

* 테스트된 사용된 목의 수는 관계가 없다. 목의 수는 비관리 의존성의 수에 따라 달라진다.

<br>

### 항상 목 호출 수 확인하기

* 목에 예상되는 호출이 있는지와 예상치 못한 호출이 없는지를 확인하라.

<br>

### 보유 타입만 목으로 검증하기

* 보유 타입만 목으로 처리하라. 
* 비관리 의존성에 접근하는 서드파티 라이브러리 위에 어댑터를 작성하라.
* 기본 타입 대신 해당 어댑터를 목으로 처리하라. 
* 최근에 AmqpAdmin을 멤버 변수로 가지는 클래스 AmqpService를 만든 것이 이거랑 맞다고 생각