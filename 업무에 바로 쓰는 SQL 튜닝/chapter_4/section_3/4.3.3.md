
# 불필요한 조인을 수행하는 나쁜 SQL 문

## 튜닝 전

```sql
SELECT COUNT(DISTINCT 사원.사원번호) as 데이터건수
FROM 사원, (SELECT 사원번호 FROM 사원출입기록 기록 WHERE 출입문 = 'A') 기록
WHERE 사원.사원번호 = 기록.사원번호
```

```sql
explain SELECT COUNT(DISTINCT 사원.사원번호) as 데이터건수
        FROM 사원, (SELECT 사원번호 FROM 사원출입기록 기록 WHERE 출입문 = 'A') 기록
        WHERE 사원.사원번호 = 기록.사원번호
```

* FROM 절의 인라인 뷰는 사실상 옵티마이저에 의해 조인 방식이 뷰 병합으로 최적화된다.
* 실행 계획에 따르면, 드라이빙 테이블인 사원 출입기록 테이블에 접근할 때 I_출입문 인덱스를 활용해 데이터에 접근하는 것을 확인할 수 있다.
* SELECT 절의 최종 결과는 사원 테이블의 사원번호에서 중복 제거한 건수를 구한 것이다. 


* 이때 실제로는 66만여 건에 달하는 사원출입기록 테이블의 데이터 결과가 최종 결과에 어떻게 활용되는지를 확인해봐야 한다.
* 왜냐하면 사원출입기록 테이블의 사원번호는 사원 테이블과 조인을 수행하는 과정 중에 값의 존재 여부만 알면 되기 때문이다.

## 튜닝 후

```sql
SELECT COUNT(1) AS 데이터건수
FROM 사원
WHERE EXISTS( SELECT 1 FROM 사원출입기록 기록
              WHERE 출입문 = 'A'
                AND 기록.사원번호 = 사원.사원번호)
```

```sql
explain SELECT COUNT(1) AS 데이터건수
        FROM 사원
        WHERE EXISTS( SELECT 1 FROM 사원출입기록 기록
                      WHERE 출입문 = 'A'
                        AND 기록.사원번호 = 사원.사원번호)
```

* 사원출입기록 테이블의 데이터는 최종 결과에 사용되지 않고 단지 존재 여부만 파악하면 되므로 EXISTS 구문으로 변경한다.
* 출입문 A에 관한 기록이 있는 사원번호에 대한 조인을 수행한 뒤, 해당하는 데이터만 집계하는 방식으로 튜닝한다.
 
