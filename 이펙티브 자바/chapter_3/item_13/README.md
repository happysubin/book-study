# chapter 3. 모든 객체의 공통 메서드

## item 13. clone 정의는 주의해서 진행하라.

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스다. 그러나 의도한 목적을 제대로 이루지 못했다.

> clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이기 때문이다. 그마저도 protected.
> 그래서 외부 객체에서 clone 메서드를 호출할 수 없다.

<br>

Cloneable 인터페이스는 Object의 protected 메서드인 clone의 동작 방식을 결정한다.

Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다.

이는 인터페이스를 상당히 이례적으로 사용한 예이니 따라하지 말자.

<br>

명세에는 적혀있지 않지만, __실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.__

clone 메서드의 일반 규약은 허술하며, Object 명세에서 가져온 다음 설명을 보자.

> 이 객체의 복사본을 생성해 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다.
> 일반적인 의도는 다음과 같다. 어떤 객체 x에 대해 다음 식은 참이다.
> 
> 아래 식은 참.
> x.clone() != x
> 
> 아래 식도 참.
> x.clone().getClass() == x.getClass()
> 
> 다음식은 참이지만, 필수는 아님
> x.clone().equals(x)
> 
> 관례상, 이 메서드가 반환하는 객체는 super.clone()를 호출해 얻어야 한다. 이 클래스와 (Object을 제외한) 모든 상위 클래스가 이 관례를 따른 다면 다음 식은 참이다.
> x.clone().getClass() == x.getClass()
> 
> 관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.
> 깊은 복사 느낌..

강제성이 없다는 점을 빼면 생성자 연새와 비슷한 메커니즘이다.

즉 clone 메서드가 super.clone이 아닌, 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 불평하지 않을 것이다.

하지만 이 클래스의 하위 클래스에서 super.clone을 호출한다면 잘못된 클래스의 객체가 만들어져, 결국 하위 클래스의 clone 메서드가 제대로 동작하지 않게 된다.

clone을 재정의한 클래스가 final이라면 걱정해야 할 하위 클래스가 없으니 이 관례를 무시해도 안전하다.

하지만 final 클래스의 clone 메서드가 super.clone을 호출하지 않는다면 Clonealbe을 구현할 이유도 없다.
Object의 clone 구현의 동작 방식에 기댈 필요가 없기 때문이다.

