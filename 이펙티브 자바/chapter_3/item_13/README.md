# chapter 3. 모든 객체의 공통 메서드

## item 13. clone 정의는 주의해서 진행하라.

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스다. 그러나 의도한 목적을 제대로 이루지 못했다.

> clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이기 때문이다. 그마저도 protected.
> 그래서 외부 객체에서 clone 메서드를 호출할 수 없다.

<br>

Cloneable 인터페이스는 Object의 protected 메서드인 clone의 동작 방식을 결정한다.

Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던진다.

이는 인터페이스를 상당히 이례적으로 사용한 예이니 따라하지 말자.

<br>

명세에는 적혀있지 않지만, __실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.__

clone 메서드의 일반 규약은 허술하며, Object 명세에서 가져온 다음 설명을 보자.

> 이 객체의 복사본을 생성해 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다.
> 일반적인 의도는 다음과 같다. 어떤 객체 x에 대해 다음 식은 참이다.
> 
> 아래 식은 참.
> x.clone() != x
> 
> 아래 식도 참.
> x.clone().getClass() == x.getClass()
> 
> 다음식은 참이지만, 필수는 아님
> x.clone().equals(x)
> 
> 관례상, 이 메서드가 반환하는 객체는 super.clone()를 호출해 얻어야 한다. 이 클래스와 (Object을 제외한) 모든 상위 클래스가 이 관례를 따른 다면 다음 식은 참이다.
> x.clone().getClass() == x.getClass()
> 
> 관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.
> 깊은 복사 느낌..

강제성이 없다는 점을 빼면 생성자 연새와 비슷한 메커니즘이다.

즉 clone 메서드가 super.clone이 아닌, 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 불평하지 않을 것이다.

하지만 이 클래스의 하위 클래스에서 super.clone을 호출한다면 잘못된 클래스의 객체가 만들어져, 결국 하위 클래스의 clone 메서드가 제대로 동작하지 않게 된다.

clone을 재정의한 클래스가 final이라면 걱정해야 할 하위 클래스가 없으니 이 관례를 무시해도 안전하다.

하지만 final 클래스의 clone 메서드가 super.clone을 호출하지 않는다면 Clonealbe을 구현할 이유도 없다.
Object의 clone 구현의 동작 방식에 기댈 필요가 없기 때문이다.

<br>

clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉 clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.

배열의 clone은 런타임 타입과 컴파일 타입 모두가 원본 배열과 똑같은 배열을 반환한다.

배열을 복제할 때는 배열의 clone을 사용하라고 권장한다. 배열의 clone 기능만이 유일한 예외

Cloneable 아키텍처는 가변객체를 참조하는 필드는 final로 선언하라 라는 일반 용법과 충돌한다. 그래서 복제할 수 있는 클래스를 만드릭 위해 일부 필드에서 final 한정자를 제거해야 할 수도 있다.

참고로 HashTable.Entry는 깊은복사(deep copy)를 지원하도록 보강되었다. 

<br>

## 정리

* 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안된다.
* final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야한다.
* 기본 원칙은 __'복제 기능은 생성자와 팩터리를 이용하는 게 최고'__ 라는 것이다.
* 단, 배열만 은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외다.

배열 아니면 clone() 사용하지말자 ^^