# chapter 4. 클래스와 인터페이스

## item 18. 상속보다는 컴포지션을 사용하라

* 일반적인 구체 클래스를 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.
* 이번 아이템에서 논하는 문제는 인터페이스 상속과는 무관하다.

메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.

* 상위 클래스는 릴리즈마다 내부 구현이 달라질 수 있으며, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.
* 이러한 이유로 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변화에 발맞춰 수정돼야만 한다.

하위 클래스가 깨지기 쉬운 이유는 더 있다. 다음 릴리스에서 상위 클래스에 새로운 메서드를 추가하다면 어떨까?
보안 때문에 컬렉션에 추가된 모든 원소가 특정 조건을 만족해야만 하는 프로그램을 생각해보자.

* 그 컬렉션을 상속하여 원소를 추가하는 모든 메서드를 재정의해 필요한 조건을 먼저 검사하게끔 하면 될 것 같다.
* 하지만 이 방식이 통하는 것은 상위 클래스에 또 다른 원소 추가 메서드가 만들어지기 전까지다.
* 다음 릴리스에서 우려한 일이 생기면, 하위 클래스에서 재정의하지 못한 그 새로운 메서드를 사용해 '허용되지 않은' 원소를 추가할 수 있게 된다.

모두 메서드 재정의가 원인이었다.
따라서 클래스를 확장하더라도 메서드를 재정의하는 대신 새로운 메서드를 추가하면 괜찮으리라 생각할 수도 있다.
이 방식이 훨씬 안전한 것은 맞지만, 위험이 전혀 없는 것은 아니다.
다음 릴리스에서 상위 클래스에 새 메서드가 추가 됐는데, 운 없게도 하필 우리가 추가한 메서드와 시그니처가 같고 반환 타입은 다르다면 클래스는 컴파일조차 되지 않는다.
 
### 이런 문제를 해결하는 방법이 있는데 바로 조합을 사용하는 것이다. 

* 즉 기존 클래스를 확장하지 말고 새로운 클래스를 만들어 기존 클래스의 인스턴스 변수로 사용하면 된다.
* 조합을 사용하면 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.
* 조합에서 새로운 클래스를 감싸는 클래스를 래퍼 클래스라고 한다. 

상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. is-a 관계에서만 사용해야 한다.
아니라면 컴포지션, 즉 조합을 사용하는 것이 훨씬 좋다.

* 조합을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 것이다.
* 그 결과 API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한된다.
* 더 큰 문제는 클라이언트가 노출된 내부에 직접 접근할 수 있다는 점이다.

## 정리

* 상속은 강력하지만 캡슐화를 해친다.
* 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때 사용해야 한다.
* is-a 관계도 안심할 수는 없다.
* 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.
* 상속의 취약점을 피하려면 상속 대신 상속과 전달을 사용하자.
* 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.
* 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

