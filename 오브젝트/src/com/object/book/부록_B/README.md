# 부록 B. 타입 계층의 구현

### 클래스를 이용한 타입 계층 구현

* 타입은 객체의 퍼블릭 인터페이스를 가리키기 때문에 결과적으로 클래스는 객체의 타입과 구현을 동시에 정의하는 것이다.
* 이것이 객체지향 언어에서 클래스를 사용자 정의 타입이라고 부르는 이유다.
* 퍼블릭 인터페이스는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 가장 쉬운 방법은 상속을 이용하는 것이다.
* 그러나 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시키기 때문에 구체 클래스를 상속받는 것은 피해야 한다.
* 가급적 추상 클래스를 상속받거나 인터페이스를 구현해야 한다.

### 인터페이스를 이용한 타입 계층 구현

* 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법은 클래스가 아닌 인터페이스를 사용하는 것이다.
* 게임 예제를 살펴봄.
* 여러 클래스가 동일한 타입을 구현했고, 하나의 클래스가 여러 타입을 구현했다.
* 인터페이스를 이용해 타입을 정의하고 클래스를 이용해 객체를 구현하면 클래스 상속을 사용하지 않고도 타입 계층을 구현했다.
* 객체지향에서 중요한 것은 클래스가 아닌 타입이다. 타입이 식별된 후에 타입에 속하는 객체를 구현하기 위해 클래스를 사용하는 것이다.
* 타입은 역할과 같은 것 같다.

### 추상 클래스를 이용한 타입 계층 구현

* 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법이 있다. 바로 추상 클래스를 이용하는 것이다.
* 이전에 구현한 할인 정책 예시를 살펴봄.
* 구체 클래스로 타입을 정의해서 상속 받는 방법과 추상 클래스로 타입을 정의해서 상속 받는 방법 사이에는 중요한 차이점이 두 가지가 있다.
* 하나는 추상화의 정도이고 다른 하나는 상속을 사용하는 의도다.
* 첫 번째는 먼저 의존하는 대상의 추상화 정도가 다르다.
* 두 번째는 상속을 사용하는 의도다. 코드 재사용이 목적이 아니라 애초에 상속을 염두에 두고 설계된 클래스다.

### 추상 클래스와 인터페이스 결합하기

* 인터페이스만 사용하면 중복 코드를 제거하기 어렵다.
* 인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우에는 추상 클래스를 이용해 중복 코드를 방지하는 것이다.
* 이런 형태로 추상 클래스를 사용하는 방식을 골격 구현 추상 클래스라고 부른다.
* 인터페이스와 골격 구현 추상 클래스를 사용하는 방법은 추상 클래스만 사용하는 방법에 비해 두 가지 장점이 있다.
  1. 다양한 구현 방법이 필요한 경우 새로운 추상 클래스를 추가해서 쉽게 해결할 수 있다. 예를 들어, 금액 할인 정책을 더 빠른 속도로 처리할 수 있는 방법과 메모리를 더 적게 차지하는 방법 모두를 구현해 놓고 상황에 따라 적절한 방법을 선택하게 할 수 있다. 
  2. 이미 부모 클래스가 존재하는 클래스라고 하더라도 인터페이스를 추가함으로써 새로운 타입으로 쉽게 확장할 수 있다. DiscountPolicy 타입이 추상 클래스로 구현돼 있는 경우에 이 문제를 해결할 ㅁ수 있는 유일한 방법은 상속 계층을 다시 조정하는 것 뿐이다.
* 설계가 상속 계층에 얽매이지 않은 타입 계층을 요구한다면 인터페이스로 타입을 정의하라.
* 추상 클래스로 기본 구현을 제공해서 중복 코드를 제거하자.
* 하지만 이런 복잡성이 필요하지 않다면 타입을 정의하기 위해 인터페이스나 추상 클래스 둘 중 하나만 사용하자.

### 덕 타이핑 사용하기

* 덕 타이핑은 주로 동적 타입 언어에서 사용하는 방법으로 다음과 같은 덕 테스트를 프로그래밍 언어에 적용한 것이다.
* 덕 테스트는 어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것이다.
* 다시 말해 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 문제가 없다.
* 자바와 같은 대부분의 정적 타입 언어에서는 덕 타입을 지원하지 않는다.
* 예제 루비 코드를 살펴봤다.
* 루비 같은 동적 언어에서는 명시적으로 동일한 클래스를 상속받거나 동일한 인터페이스를 구현하지 않더라도 시그니처가 동일한 메서드를 가진 클래스는 같은 타입으로 취급할 수 있다.
* 덕 타이핑은 타입이 행동에 대한 것이라는 사실을 강조한다.
* 두 객체가 동일하게 행동한다면 내부 구현이 어떤 방식이든 상관없다. 타입 관점에서 두 객체는 동일한 타입인 것이다.
* 메서드의 시그니처만 동일하면 명시적인 타입 선언이라는 컨텍스트를 제거할 수 있다.
* 덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체한다.
* 결과적으로 코드는 낮은 결합도를 유지하고 변경에 유연하게 대응할 수 있다.
* 대신 덕 타이핑을 사용하면 컴파일 시점에 발견할 수 있는 오류를 실행 시점으로 미루기 때문에 설계의 유연성을 얻는 대신 코드의 안전성을 악화시킬 수 있다는 점에 주의하자.
* C#의 dynamic 예시와 C++의 제네릭 예시도 살펴봄.

### 믹스인과 타입 계층

* 믹스인은 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스다.
* 언어마다 구현의 차이는 있지만 믹스인을 사용하는 목적은 다양한 객체 구현 안에서 동일한 행동을 중복 코드 없이 재사용할 수 있게 하려는 것이다.
* 믹스인을 통해 코드를 재사용하는 객체들은 동일한 행동을 공유하게 된다.
* 공통의 행동이 믹스인된 객체들은 동일한 메시지를 수신할 수 있는 퍼블릭 인터페이스를 공유하게 되는 것이다.
* 타입은 퍼블릭 인터페이스와 관련이 있기 때문에 대부분의 믹스인을 구현하는 기법들은 타입을 정의하는 것으로 볼 수 있다.
* 이번에는 스칼라 언어에서 믹스인을 구현하는 코드를 살펴봄.
* 자바 8의 디폴트 메서드는 인터페이스에 메서드의 기본 구현을 허용한다.
* 디폴트 메서드를 사용하면 추상 클래스가 제공하는 코드 재사용성이라는 혜택을 그대로 누리면서도 특정한 상속 계층에 얽매이지 않는 인터페이스의 장점을 유지할 수 있다.
* 자바의 경우에는 믹스인을 구현하기 위해 디폴트 메서드를 사용할 수 있으며, 이를 통해 간결한 인터페이스를 가진 클래스를 풍부한 인터페이스를 가진 클래스로 변경할 수 있다.
* 디폴트 메서드를 사용하면 추상 클래스를 상속받지 않아도 된다.
* 디폴트 메서드 안에서 사용된다는 이유만으로 public 메서드가 되야 한다. 이것은 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가하는 결과를 낳게 된다.
* 디폴트 메서드를 사용해 추상 클래스를 대체할 경우 인터페이스가 불필요하게 비대해지고 캡슐화가 약화될 수도 있다.
* 디폴트 메서드가 추가된 이유는 기존에 널리 사용되고 있는 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서지 추상 클래스를 제거하기 위한 것이 아니다.
* 따라서 타입을 정의하기 위해 디폴트 메서드를 사용할 생각이라면 그 한계를 명확하게 알아둬야 한다.
* 어떤 타입이든 서브타입과 슈퍼타입의 조건을 만족시키려면 구현할 때 리스코프 치환 원칙을 준수해야 한다.