# 자바 Next Step 웹 프로그래밍

## part 3. 개발 환경 구축 및 웹 서버 실습 요구 사항

* 사용자 요청이 발생 할 때까지 대기 상태에 있도록 지원하는 역할은 자바에 포함되어 있는 ServerSocket 클래스가 담당.
* WebServer 클래스는 ServerSocket에 사용자 요청이 발생하는 순간 클라이언트와 연결을 담당하는 Socket을 RequestHandler에 전달하면서 새로운 스레드를 실행하는 방식으로 멀티스레드 프로그래밍을 지원하고 있다.
* RequestHandler 클래스는 Thread를 상속하고 있으며, 사용자의 요청에 대한 처리와 응답에 대한 처리를 담당하는 가장 중심이 되는 클래스다.
* 프로그래밍을 할 때 좋은 습관 중의 하나는 프로그래밍 실행 중 발생하는 로그 메시지를 주의 깊게 살펴보는 것이다.
* 디버깅하니 실제로 들어오는 스트림은 SocketInputStream이다.
* br.readLine()은 줄바꿈 문자가 나오지 않으면 Lock에 걸려서 대기함.
* br.read()와 Content-Length 헤더를 사용해서 해결.
* Content-Length가 어디까지 body가 인지 알려줌. 즉 바디의 크기를 알려줌.
* Location 헤더를 사용해서 리다이렉트함.
* HTTP 공부를 다시 해야할 것 같다고 느낌.
* 리팩토링하면서 위에 적은 br.readLine()에서 헤맴.
* Set-Cookie를 사용함.
* 200번대로 내려주는데 이러면 Redirect가 안됨.
* 차라리 300번대로 내리고 Redirect하는게 맞는듯. 수정하자.
* /user/** 경로에서 쿠키는 살아있음. /index.html로 가면 쿠키가 없어짐.
* Accept: text/css 와 / 방식을 사용해서 빠르게 해결. 다형성을 지키지는 못함..
* 필요한 css, js 파일마다 http 요청을 서버로 보낸다.

## part 4. HTTP 웹 서버 구현을 통해 HTTP 이해하기

* 완전 절차지향적인 코드를 살펴봄.

## part 5. 웹 서버 리팩토링, 서블릿 컨테이너와 서블릿의 관계

### chapter 5.1 

* 얼마나 편하게 개발하는고 있는지 느꼈고, 기초가 부족한 부분이 많았는데, 문제 좀 잘 읽자. 
* 최대한 NextStep에서 배운 뭐 일급 콜렉션, 래핑 클래스 이런 것들을 떠올리자.
* 코테, 작은 플젝, 웹 개발 등 공통적으로 생각할 것. 예를 들어 코테에서 id를 사용해 기록을 추적, HttpRequest 클래스 내부 클래스 만들기 Http Path 등
* map putAll 기억하기. HttpRequest처럼 묶었으면 잘한 것 같은데 아쉽다. 
* HttpRequest 관련 리팩토링이 수월해서 다행이다. 중복이라기보단 로직이 많이 분산된 느낌이었음. 
* 컨트롤러는 잘 나눈 것 같다. 대신 응답에 중복 코드가 많아서 바꿀 때 고생할 것 같다.
* 정보 전문가 패턴을 사용해서 좀 더 책임을 나눴으면 좋았을 것 같다. 아직 많이 부족한 듯.
* 저번 Next Step 과정 처럼 클래스를 조금이나마 설계하고 했으면 좋았을 듯. 앞으로는 무조건 이렇게 하자.
* 뭔가 리팩토링 할 수록 처음에 짠 코드가 너무 아쉽다. 이 기분 아쉬운 기분 기억하고, 다음에는 더 잘.하.자.

### chapter 5.2

* 클라이언트 요청에 대한 헤더와 본문 데이터 처리, 요청에 따른 로직 처리, 로직 처리 완료 후 클라이언트에 대한 응답 헤더와 본문 데이터 처리 작업 3개로 나뉨.
* 3개의 책임을 분할해서 리팩토링을 진행.
* 테스트 코드 작성 장점.
  * 클래스에 버그가 있는지를 빨리 찾아 구현할 수 있다.
  * 디버깅하기 쉽다.
  * 테스트 코드가 있기 때문에 마음 놓고 리팩토링을 할 수 있다.
* private 메서드를 테스트하는 방법
  * private 접근 제어자인 메소드를 default 접근 제어자로 수정하고 메소드 처리 결과를 반환하도록 수정해 테스트한다.
  * 메소드 구현 로직을 새로운 클래스로 분리한다.
* private 메서드의 복잡도가 높으면 보통 리팩토링할 부분이 있다는 힌트다.
* RequestMapping 이라는 별도의 전역적인 Map으로 관리하는 아이디어.
* 중복 코드를 줄이기 위해 추상 클래스를 사용.
* 현재 구현한 HTTP 서버 문제점.
  * HTTP 요청과 응답 헤더, 본문 처리와 같은 데 시간을 투자함으로써 정작 중요한 비즈니스 로직을 구현하는데 투자할 시간이 상대적으로 적다.
  * 동적인 HTML을 지원하는데 한계가 있다. 동적인 HTML 생성에 많은 코딩량을 필요로 한다.
  * 사용자가 입력한 데이터가 서버를 시작함녀 사라진다.

### chapter 5.3

* 서블릿은 앞에서 구현한 웹 서버의 Controller, HttpRequest, HttpResponse를 추상화해 인터페이스로 정의해 놓은 표준이다.
* HTTP 클라이언트 요청과 응답에 대한 표준을 정해 놓은 것을 서블릿이라고 생각하면 된다.
* 웹서버의 역할과 서블릿 컨테이너의 역할은 동일하다.
* 서블릿 컨테이너는 서버가 시작할 때 서블릿 인스턴스를 생성해, 요청 URL과 서블릿 인스턴스를 연결해 놓는다.
* 클라이언트에서 요청이 오면 요청 URL에 해당하는 서블릿을 찾아 서블릿에 모든 작업을 위임한다.
* 서블릿 컨테이너느 서버를 시작할 때 클래스패스에 있는 클래스 중 HttpServlet을 상속하는 클래스를 찾은 후 @WebServlet 애노테이션의 값을 읽어 요청 URI과 서블릿을 연결하는 Map을 생성한다.
* 서블릿 컨테이너의 중요한 역할 중의 하나는 서블릿 클래스의 인스턴스 생성, 요청 URL과 서블릿 인스턴스 매핑, 클라이언트 요청에 해당하는 서블릿을 찾은 후 서블릿에 작업을 위임하는 역할을 한다.
* 이외에도 서블릿 컨테이너느 서블릿의 생명 주기를 관리한다. 초기화와 소멸 작업. 그밖에도 멀티쓰레딩 지원, 설정 파일을 활용한 보안관리 ,JSP 등을 지원.
* 컨테이너란 단어의 핵심은 생명주기 관리.
* 서블릿에서 알아야할 중요한 부분 중의 하나는 서블릿 컨테이너가 생성하는 서블릿 인스턴스의 개수다.
* 서블릿 컨테이너는 멀티스레드로 동작하는데, 즉 동시에 여러 명의 클라이언트가 접속할 수 있도록 지원한다.
* 그럼 서블릿은 요청마다 생성하는가? 우리가 구현한 코드를 살펴보면 아니다. 한 번 초기화하면 더 이상 초기화하지 않고 계속 사용한다. 싱글톤과 같다.

## part 6. 서블릿/JSP를 활용해 동적인 웹 애플리케이션 개발하기

* 프로젝트 준비. 재성님이 올려주신 코드를 인스톨함.
* 에러가 발생. 라이브러리를 설치함. tomcat-catalina을 pom.xml에 추가. WEB-INF에 jakarta-taglibs-standart-1.1.2 라이브러리를 추가해 문제를 해결함. 
* 6.1.2 무난하게 실행. JSP를 잘 몰라서 문법 찾아다님.
* 설정 오류라고 생각했는데, 그냥 내 오타였다. 침착하게 디버깅하자.

### chapter 6.3

* 이 부분은 다시 한 번 꼭 해보자.
* JSESSIONID를 사용해서 HttpSessions에서 나의 HttpSession 객체를 가져오고, "user" 키를 활용해서 내가 가져와야할 user 객체를 가져온다.

### 정리

* 스프링 MVC 강의에서 배운 프론트 컨트롤러 패턴을 간단하게 진행.
* HttpSession이 제일 감명 깊은 부분이였다.
* loadOnStartup 설정을 하지 않았을 경우 서블릿 인스턴스 생성과 초기화는 서블릿 컨테이너가 시작을 완료한 후 클라이언트의 요청이 최초로 발생하는 시점에 진행ㄴ된다.
* 즉 서블릿 컨테이너를 시작한 후 10분만에 클라이언트 요청이 최초로 발생하면 그 시점에 서블릿 인스턴스가 생성되고, 초ㅓ기화가 진행된다.
* 하지만 LoadOnStatrup 설정을 하는 경우 서블릿 컨테이너가 시작하는 시점에 서블릿 인스턴스 생성과 초기화가 진행된다. 
* 해당 설정 값이 낮은 순으로 먼저 초기화가 진행된다.


## part 7. DB를 활용해 데이터를 영구적으로 저장하기

## chapter 7.1

* 톰캣 서버가 시작할 때 contextInitialized() 메서드를 호출함으로써 초기화 작업을 한다.
* 이 작업이 가능한 이유는 ContextLoaderListener가 ServleteContextListener 인터페이스를 구현하고 있으며, @WebListener 애노테이션 설정이 있기 때문이다.
* 서블릿 컨테이너는 ServletContextListener 인터페이스 구현체 중 @WebListener 애노테이션이 설정되어 있으면 서블릿 컨테이너를 시작하는 과정에서 contextInitialized() 메서드를 호출해 초기화 작업을 진행한다.
* 서블릿의 초기화가 해당 서블릿과 관련된 초기화를 담당한다면 ServletContextListener 초기화는 웹 애플리케이션 전체에 영향을 미치는 초기화가 필요한 경우 활용할 수 있다.

### chapter 7. 실습 정리

* 리팩토링을 완료한 후에는 반드시 테스트를 통해 확인하는 습관을 들이자.
* 메서드 구현은 userDao가 책임을 가진다. JdbcTemplate는 실행 뼈대를 제공해야한다.
* 추상 클래스와 추상 메서드를 익명 클래스에서 구현하는 부분이 인상 깊음. 본인은 익명 클래스가 아닌 클래스를 만들어서 오버라이딩하는 첫 시도로 진행함.
* 이 부분이 템플릿 메서드 패턴이다.
* 의존 관계 제거를 위해 추상 메서드를 userDao에서 오버라이딩해서 값을 주입함.
* 추후에는 함수형 인터페이스를 사용해서 동작 파라미터를 주입했다. 전략 패턴이라고 생각함. 상속이 아닌 합성의 관계로 해결한 것.
* 결론적으로 데이터 접근 로직 처리에 대한 공통 라이브러리를 JDBC 하나로 제공하는데 성공함.
* 체크 익셉션을 catch문에서 잡아 언체크 익셉션으로 바꿔서 던졌다. 그러므로 throws 구문을 선언부에 적지 않아도 된다.
* 자원을 활용한 후 반납하기 위해 close() 메서드가 많았다.
* AutoClosable 인터페이스를 구현하는 클래스는 try-with-resources 구문을 활용해 자원을 자동으로 반납할 수 있다. 이 구문을 사용!
* 반드시 AutoClosable 인터페이스를 구현해야 한다. 
* 제네릭을 적용해 캐스팅 하지 않도록 개선함. 제네릭은 추후 공부가 더 필요할 것 같다. 람다 파트는 수월하게 해결함. 뿌듯

### chapter 7. 실습 과정에서 선생님이 주고자 하는 학습 목표

* 콜백 인터페이스를 활용했을 때의 유연함. 콜백 인터페이스는 공통 라이브러리를 만들거나 코드에 유연함이 필요한 경우 유용하게 사용할 수 있다. 동작의 파라미터화.
* 리팩토링을 최대한 안전하게 진행해야 하는 것이다. 새로운 기능을 추가하지 않으면서 설계를 개선하는 작업. 따라서 리팩토링을 진행하며 테스트는 필수고 테스트 자동화는 필수다.이

