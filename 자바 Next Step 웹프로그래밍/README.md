# 자바 Next Step 웹 프로그래밍

## part 3. 개발 환경 구축 및 웹 서버 실습 요구 사항

* 사용자 요청이 발생 할 때까지 대기 상태에 있도록 지원하는 역할은 자바에 포함되어 있는 ServerSocket 클래스가 담당.
* WebServer 클래스는 ServerSocket에 사용자 요청이 발생하는 순간 클라이언트와 연결을 담당하는 Socket을 RequestHandler에 전달하면서 새로운 스레드를 실행하는 방식으로 멀티스레드 프로그래밍을 지원하고 있다.
* RequestHandler 클래스는 Thread를 상속하고 있으며, 사용자의 요청에 대한 처리와 응답에 대한 처리를 담당하는 가장 중심이 되는 클래스다.
* 프로그래밍을 할 때 좋은 습관 중의 하나는 프로그래밍 실행 중 발생하는 로그 메시지를 주의 깊게 살펴보는 것이다.
* 디버깅하니 실제로 들어오는 스트림은 SocketInputStream이다.
* br.readLine()은 줄바꿈 문자가 나오지 않으면 Lock에 걸려서 대기함.
* br.read()와 Content-Length 헤더를 사용해서 해결.
* Content-Length가 어디까지 body가 인지 알려줌. 즉 바디의 크기를 알려줌.
* Location 헤더를 사용해서 리다이렉트함.
* HTTP 공부를 다시 해야할 것 같다고 느낌.
* 리팩토링하면서 위에 적은 br.readLine()에서 헤맴.
* Set-Cookie를 사용함.
* 200번대로 내려주는데 이러면 Redirect가 안됨.
* 차라리 300번대로 내리고 Redirect하는게 맞는듯. 수정하자.
* /user/** 경로에서 쿠키는 살아있음. /index.html로 가면 쿠키가 없어짐.
* Accept: text/css 와 / 방식을 사용해서 빠르게 해결. 다형성을 지키지는 못함..
* 필요한 css, js 파일마다 http 요청을 서버로 보낸다.

## part 4. HTTP 웹 서버 구현을 통해 HTTP 이해하기

* 완전 절차지향적인 코드를 살펴봄.

## part 5. 웹 서버 리팩토링, 서블릿 컨테이너와 서블릿의 관계

### chapter 5.1 

* 얼마나 편하게 개발하는고 있는지 느꼈고, 기초가 부족한 부분이 많았는데, 문제 좀 잘 읽자. 
* 최대한 NextStep에서 배운 뭐 일급 콜렉션, 래핑 클래스 이런 것들을 떠올리자.
* 코테, 작은 플젝, 웹 개발 등 공통적으로 생각할 것. 예를 들어 코테에서 id를 사용해 기록을 추적, HttpRequest 클래스 내부 클래스 만들기 Http Path 등
* map putAll 기억하기. HttpRequest처럼 묶었으면 잘한 것 같은데 아쉽다. 
* HttpRequest 관련 리팩토링이 수월해서 다행이다. 중복이라기보단 로직이 많이 분산된 느낌이었음. 
* 컨트롤러는 잘 나눈 것 같다. 대신 응답에 중복 코드가 많아서 바꿀 때 고생할 것 같다.
* 정보 전문가 패턴을 사용해서 좀 더 책임을 나눴으면 좋았을 것 같다. 아직 많이 부족한 듯.
* 저번 Next Step 과정 처럼 클래스를 조금이나마 설계하고 했으면 좋았을 듯. 앞으로는 무조건 이렇게 하자.
* 뭔가 리팩토링 할 수록 처음에 짠 코드가 너무 아쉽다. 이 기분 아쉬운 기분 기억하고, 다음에는 더 잘.하.자.

### chapter 5.2

* 클라이언트 요청에 대한 헤더와 본문 데이터 처리, 요청에 따른 로직 처리, 로직 처리 완료 후 클라이언트에 대한 응답 헤더와 본문 데이터 처리 작업 3개로 나뉨.
* 3개의 책임을 분할해서 리팩토링을 진행.
* 테스트 코드 작성 장점.
  * 클래스에 버그가 있는지를 빨리 찾아 구현할 수 있다.
  * 디버깅하기 쉽다.
  * 테스트 코드가 있기 때문에 마음 놓고 리팩토링을 할 수 있다.
* private 메서드를 테스트하는 방법
  * private 접근 제어자인 메소드를 default 접근 제어자로 수정하고 메소드 처리 결과를 반환하도록 수정해 테스트한다.
  * 메소드 구현 로직을 새로운 클래스로 분리한다.
* private 메서드의 복잡도가 높으면 보통 리팩토링할 부분이 있다는 힌트다.
* RequestMapping 이라는 별도의 전역적인 Map으로 관리하는 아이디어.
* 중복 코드를 줄이기 위해 추상 클래스를 사용.
* 현재 구현한 HTTP 서버 문제점.
  * HTTP 요청과 응답 헤더, 본문 처리와 같은 데 시간을 투자함으로써 정작 중요한 비즈니스 로직을 구현하는데 투자할 시간이 상대적으로 적다.
  * 동적인 HTML을 지원하는데 한계가 있다. 동적인 HTML 생성에 많은 코딩량을 필요로 한다.
  * 사용자가 입력한 데이터가 서버를 시작함녀 사라진다.

### chapter 5.3

* 서블릿은 앞에서 구현한 웹 서버의 Controller, HttpRequest, HttpResponse를 추상화해 인터페이스로 정의해 놓은 표준이다.
* HTTP 클라이언트 요청과 응답에 대한 표준을 정해 놓은 것을 서블릿이라고 생각하면 된다.
* 웹서버의 역할과 서블릿 컨테이너의 역할은 동일하다.
* 서블릿 컨테이너는 서버가 시작할 때 서블릿 인스턴스를 생성해, 요청 URL과 서블릿 인스턴스를 연결해 놓는다.
* 클라이언트에서 요청이 오면 요청 URL에 해당하는 서블릿을 찾아 서블릿에 모든 작업을 위임한다.
* 서블릿 컨테이너느 서버를 시작할 때 클래스패스에 있는 클래스 중 HttpServlet을 상속하는 클래스를 찾은 후 @WebServlet 애노테이션의 값을 읽어 요청 URI과 서블릿을 연결하는 Map을 생성한다.
* 서블릿 컨테이너의 중요한 역할 중의 하나는 서블릿 클래스의 인스턴스 생성, 요청 URL과 서블릿 인스턴스 매핑, 클라이언트 요청에 해당하는 서블릿을 찾은 후 서블릿에 작업을 위임하는 역할을 한다.
* 이외에도 서블릿 컨테이너느 서블릿의 생명 주기를 관리한다. 초기화와 소멸 작업. 그밖에도 멀티쓰레딩 지원, 설정 파일을 활용한 보안관리 ,JSP 등을 지원.
* 컨테이너란 단어의 핵심은 생명주기 관리.
* 서블릿에서 알아야할 중요한 부분 중의 하나는 서블릿 컨테이너가 생성하는 서블릿 인스턴스의 개수다.
* 서블릿 컨테이너는 멀티스레드로 동작하는데, 즉 동시에 여러 명의 클라이언트가 접속할 수 있도록 지원한다.
* 그럼 서블릿은 요청마다 생성하는가? 우리가 구현한 코드를 살펴보면 아니다. 한 번 초기화하면 더 이상 초기화하지 않고 계속 사용한다. 싱글톤과 같다.

## part 6. 서블릿/JSP를 활용해 동적인 웹 애플리케이션 개발하기

* 프로젝트 준비. 재성님이 올려주신 코드를 인스톨함.
* 에러가 발생. 라이브러리를 설치함. tomcat-catalina을 pom.xml에 추가. WEB-INF에 jakarta-taglibs-standart-1.1.2 라이브러리를 추가해 문제를 해결함. 
* 6.1.2 무난하게 실행. JSP를 잘 몰라서 문법 찾아다님.
* 설정 오류라고 생각했는데, 그냥 내 오타였다. 침착하게 디버깅하자.

### chapter 6.3

* 이 부분은 다시 한 번 꼭 해보자.
* JSESSIONID를 사용해서 HttpSessions에서 나의 HttpSession 객체를 가져오고, "user" 키를 활용해서 내가 가져와야할 user 객체를 가져온다.