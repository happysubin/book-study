# part 6. 응용 서비스와 표현 영역

## chapter 6.1 표현 영역과 응용 영역

* 도메인이 제 기능을 하려면 사용자와 도메인을 연결해주는 매개체가 필요하다.
* 표현 영역은 사용자의 요청을 해석한다. 
* 사용자는 HTTP 요청을 표현 영역에 전달한다. 요청을 받은 표현 영역은 사용자가 실행하고 싶은 기능을 판별하고 그 기능을 제공하는 응용 서비스를 실행한다.
* 실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스다.
* 사용자가 회원 가입을 요청했다면 실제 그 요청을 위한 기능을 제공하는 주체는 응용 서비스에 위치한다.
* 응용 서비스는 기능을 실행하는 데 필욜한 입력 값을 메서드 인자로 받고 실행 결과를 리턴한다.
* 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변경해서 요청한다.
* 응용 서비스를 실행한 뒤에 표현 영역은 실행 결과를 사용자에게 알맞은 형식으로 응답한다. 사용자 요청에 맞게 HTML, JSON 형식으로 리턴.
* 사용자와 상호작용은 표현 영역이 처리하기 때문에, 응용 서비스는 표현 영역에 의존하지 않는다. 단지 입력 값을 받아 실행하고 결과를 리턴한다.

## chapter 6.2 응용 서비스의 역할

* 응용 서비스는 사용자가 요청한 기능을 실행한다.
* 응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.
* 표현 영역 입장에서 보았을 때 응용 서비스는 도메인 영여과 표현 영역을 연결해주는 창구 역할을 한다.
* 응용 서비스는 주로 도메인 객체간의 흐름을 제어하므로 단순한 형태를 가진다.
  1. 리포지터리에서 애그리거트를 구한다.
  2. 애그리거트의 도메인 기능을 실행.
  3. 결과를 리턴.
* 응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
* 응용 서비스가 도메인 로직을 일부 구현하면 코드 중복, 로직 분산 등 코드 품질에 안 좋은 영향을 줄 수 있다.
* 응용 서비스는 트랜잭션 처리도 담당한다. 응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리해야 한다.

### section 6.2.1 도메인 로직 넣지 않기

* 검증하는 로직은 사실 도메인 로직이다. 따라서 응용 서비스가 아닌 도메인 영역에서 구현해야 한다.
* 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.
* 첫 번째 문제는 코드의 응집성이 떨어진다.
* 두 번째 문제는 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다는 것이다. 중복 코드가 발생하는 것이다.
* 일부 도메인 로직이 응용 서비스에 출현하면서 발생하는 두 가지 문제는 결과적으로 코드 변경을 어렵게 만든다.
* 소프트웨어의 가치, 즉 변경에 유연하게 대응하려면 도메인 로직을 도메인 영역에 모아서 코드 중복을 줄이고 응집도를 높여야 한다.

## chapter 6.3 응용 서비스의 구현

* 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사드와 같은 역할을 한다.

### section 6.3.1 응용 서비스의 크기

* 응용 서비스는 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현한다.
  * 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
  * 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
* 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하면 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.
* 그러나 클래스의 크기가 너무 커지는 단점이 있다. 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아지며 결국 관련 없는 코드가 뒤섞여 코드를 이해하는데 방해가 된다.
* 구분되는 기능별로 서비스 클래스를 구현하는 방식은 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현한다.
* 이 방식을 사용하면 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는데 도움이 된다.
* 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있다.
* 이런 경우에는 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.
* 선생님은 각 클래스마다 구분되는 역할을 갖는 것을 선호한다고 하신다. 구분뙤는 기능을 별도의 서비스 클래스로 구현하는 방식.

### section 6.3.2 응용 서비스의 인터페이스와 클래스

* 인터페이스가 필요한 몇 가지 상황은 바로 구현 클래스가 여러 가지인 경우다. 또한 런타임에 구현 객체를 교체해야할 때 인터페이스를 유용하게 사용한다.
* 사실 응용 서비스는 런타임에 교체하는 경우가 거의 없고 한 응용 서비스의 구현 클래스가 두 개인 경우도 드물다.
* 선생님의 의견은 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택이 아니라고 말하셨다.

### section 6.3.3 메서드 파라미터와 값 리턴

* 응용 서비스에 데이터로 전달할 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 dto를 사용하는 것이 편리하다.
* 본인의 생각은 의존성을 위해 표현 계층 dto, 응용 계층 dto 따로 두어서 사용하면 좋다고 생각한다.
* 응용 서비스에서 애그리거트를 반환하지말자. 즉 DTO를 사용해서 결괏값을 리턴하자. 본인이 지금하는 방법이 옳다고 다시 한번 느꼈다.

### section 6.3.4 표현 영역에 의존하지 않기

* 표현 영역의 의존성이 응용 계층으로 넘치면 안된다. HttpServletRequest, 표현 계층 dto 등.
* 응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기가 어려워진다.
* 표현 영역이 변경되면 응용 서비스의 구현도 함께 변경하는 문제가 발생할 수도 있다.
* 제일 심각한 문제인 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 발생할 가능성도 있다. 책에서는 예시로 표현 영역에서 쿠키와 세션을 다루는 예시를 보여줌.
* 철저하게 응용 서비스가 표현 영역의 기술을 사용하지 않도록 하자.

### section 6.3.5 트랜잭션 처리

* 스프링은 @Transactional이 적용한 메서드가 런타임 예외를 던지면 트랜잭션을 롤백하고 그렇지 않으면 커밋한다. 이건 아주 기본적인 규칙!
* 응용 서비스의 중요한 역할. 응용 서비스의 메서드 단위로 트랜잭션을 관리하자.

## chapter 6.4 표현 영역

* 표현 영역의 책임은 크게 다음과 같다.
  * 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.
  * 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
  * 사용자의 세션을 관리한다.

## chapter 6.5 값 검증 

* Errors, BindingResult 예시 등장. 그러나 코드가 번잡하다.
* 표현 영역은 필수 값, 값의 형식, 범위 등을 검증한다.
* 응용 계층은 데이터의 존재 유무와 같은 논리적 오류를 검증한다.
* 선생님은 응용 서비스에서 값 오류를 검증한다고 하신다. 본인은 그래도 형식 검증은 @Valid와 익셉션 핸들러를 사용하는게 좋다고 생각.

## chapter 6.6 권한 검사

* 표현 영역, 응용 서비스, 도메인에서 권한 검사를 수행할 수 있다.
* 표현 영역에서 할 수 있는 기본적인 검사는 인증된 사용자인지 아닌지 검사하는 것이다. 대표적인 예가 회원 정보 변경 기능.
* 이때 사용하기 좋은 방법이 서블릿 필터. 스프링 시큐리티도 물론 가능하다.
* URL 만으로 접근 제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 권한 검사를 수행해야한다. 이때 @PreAuthorize 스프링 시큐리티 AOP를 사용해서 검증하는 것이 유용하다.
* 개별 도메인 객체 단위로 권한 검사를 하는 경우는 구현이 복잡해진다. 보통 애그리거트를 로딩해서 직접 권한 검사 로직을 구현해야하기 때문이다.
* 스프링 시큐리티와 같은 보안 프레임워크를 확장해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합할 수도 있다.
* 도메인에 맞게 보안 프레임워크를 확장하려면 프레임워크에 대한 수준 높은 이해가 필요하다.
* 만약 그런 수준 높은 이해도가 아니라면 프레임워크를 사용하는 대신 도메인에 맞는 권한 검사 기능을 직접 구현하는 것이 코드 유지 보수에 유리하다.
* 필자가 생각하기에는 로그인은 프레임워크를 사용해도 된다고 생각. 다른 도메인 검증은 코드를 작성해 검증하는 것이 좋은 것 같다.

## chapter 6.7 조회 전용 기능과 응용 서비스

* 조회 로직은 트랜잭션이 필요하지 않다. 이 경우라면 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 문제가 없다.
* 표현 계층에서 바로 QueryRepository를 참조해서 조회를 하는 느김.
* 물론 이 경우는 조회를 위한 응용 서비스가 단지 정말 조회만 한다면 응용 서비스를 생략해도 무방하다는 것이다.





