# part 3. 애그리거트

## chapter 3.1 애그리거트

* 도메인 객체 모델이 복잡해지면 개별 구성 요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
* 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다.
* 복잡한 도메인을 이해하기 관리하기 쉬운 단위로 만들려면 상위 수준에서 모데를 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다.
* 애그리거트는 관련된 객체를 하나의 군으로 묶어 주며, 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
* p.99, p.100에서 애그리거트를 적용한 도메인 모델을 살펴봄.
* 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
* 모델을 보다 잘 이해할 수도 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.
* 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력(개발 시간)도 줄여준다.
* 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
* 도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.
* 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
* 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
* 흔히 A가 B를 가진다로 설계하는 요구사항이 있으면 한 애그리거트로 묶어서 생각하기 쉬운데, 이는 한 애그리거트가 아닐 수도 있다. 예시로 상품과 리뷰의 관계를 들 수 있다.
* 작가님의 경험으로는 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물었다고 하심.

## chapter 3.2 애그리거트 루트

* 애그리거트는 여러 객체로 구성 되기 때문에 한 객체만 상태가 정상이면 안 된다.
* 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티다.
* 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티다. 에그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.
* 주문 애그리거트에서 루트 역할을 하는 엔티티는 Order 이다.

### section 3.2.1 도메인 규칙과 일관성

* 애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다.
* 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
* 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
* 예를 들어 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하고, 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다.
* 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
* 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다. 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
* 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
  * 단순히 필드를 변경하는 set 메서드를 public 하게 만들지 않는다.
  * 밸류 타입은 불변으로 구현한다. 변경을 원한다면 새로운 밸류 값을 참조하자.
  
### section 3.2.2 애그리거트 루트의 기능 구현

* 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
* 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다. 뭔가 정보 전문가 패턴 같다!!!
* 일급 콜렉션 같은 코드를 살펴봄. 역시 정보 전문가 패턴 같다.

### section 3.2.3 트랜잭션 범위

* 트랜잭션 범위는 당연히 작을수록 좋다.
* 한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다. 잠금(락) 때문이다.
* 잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미하고 이것은 전체적인 성능(처리량)을 떨어트린다.
* 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
* 한 트랜잭션에서 두 개의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높아지므로 한번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어진다.
* 애그리거트는 최대한 독립적이어야 한다.
* 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아진다.
* 결합도가 높아지면 높아질수록 향후 수정 비용이 증가하므로 애그리거트에서 다른 애그리거트의 상태를 변경하지 말아야 한다.
* 만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.
* 한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만, 다음 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
* 팀 표준, 기술 제약, UI 구현의 편리
* 추후에 나오지만 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

## chapter 3.3 리포지토리와 애그리거트

* 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
* 예를 들어 주문 애그리거트에서는 Order를 위한 리포지토리만 존재한다. 하위 도메인을 위한 리포지토리는 없다.
* 새로운 애그리거트를 만드려면 저장소에 애그리거트를 영속화하고, 애그리거트를 사용하려면 저장소에서 애그리거트를 읽어야 하므로, 리포지토리는 보통 다음의 두 메서드를 기본으로 제공한다.
  * save - 애그리거트 저장
  * findById - Id로 애그리거트를 찾음
* 이 두 메서드 이외에 요구사항에 따라 애그리거트에 관련된 메서드 자유롭게 추가 가능.
* 애그리거트는 개념적으로 하나이므로 리포지토리는 애그리거트 전체를 저장소에 영속화해야 한다.
* 예를 들어 Order 애그리거트와 관련된 테이블이 세 개라면 Order 애그리거트를 저장할 때 애그리거트 루트와 매핑되는 테이블 뿐만 아니라 애그리거트에 속한 모든 구성요소에 매핑된 테이블에 데이터를 저장해야 한다.
* 동일하게 애그리거트를 구하는 리포지토리 메서드는 완전한 애그리거트를 제공해야 한다.
* 애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.
* 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.
* RDBMS를 이용해서 리포지터리를 구현하면 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장한다.
* 몽고 DB를 사용하면 한 개 애그리거트를 한 개 문서에 저장함으로써 한 애그리거트의 변경을 손실 없이 저장소에 반영할 수 있다.

## chapter 3.4 ID를 이용한 애그리거트 참조

* 애그리거트 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같다.
* 애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다.
* 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.
* ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있고 필드를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 뎅리터를 쉽게 조회할 수 있다.
* 하지만 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수도 있다.
  * 편한 탐색 오용
  * 성능에 대한 고민
  * 확장 어려움
* 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다는 것이다. (다른 애그리거트를 수정하는 잘못된 방식으로 오용)
* 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.
* 트랜잭션 범위에서 언급한 것처럼 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.
* 두 번째 문제는 애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다. JPA에서는 즉시 로딩과 지연 로딩!!!
* 마지막 문제는 확장이다. 초기에느 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다. 문제는 사용자가 몰리기 시작하면서 발생한다.
* 사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다.
* 이 과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 때도 있다. 심지어 하위 도메인마다 다른 종류의 데이터 저장소를 사용하기도 한다.
* 한 하위 도메인은 마리아 DB를 사용하고 다른 하위 도메인은 몽고 DB를 사용하는 식으로 말이다.
* 이것은 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.
* 이런 세 가지 문제를 완하할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조화하는 것이다.
* DB 테이블에서 외래키로 참조하는 것과 비슷하게 ID를 이용한 참조는 다른 애그리거트를 참조할 때 ID를 사용한다.
* ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
* 이는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다.
* 또한 애그리거트 간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.
* 지연 로딩, 직접 로딩을 고민할 필요 없이 참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 이용해서 로딩하면 된다.

### section 3.4.1 ID를 이용한 참조와 조회 성능

* 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제될 수 있다.
* ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만드는 데 지연 로딩과 관련된 대표적인 문제가 N + 1 조회 문제다. N + 1 문제는 전체 조회 속도가 느려지는 원인이 된다.
* ID 참조 방식을 사용하면 서 N + 1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하면 된다.
* 예를 들어 데이터 조회를 위한 별도의 DAO를 만들고 DAO의 조회 메서드에서 조인을 이용해 한 번의 쿼리로 필요한 데이터를 로딩하면 된다. 예시 코드 p.120
* 애그리거트마다 서로 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.
* 이때는 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다.
* 이 방법은 코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일 수 있다는 장점이 있다.
* 특히 한 대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법이다.

## chapter 3.5 애그리거트 집합 연관

* 1 - N, M - N 연관에 대해 살펴봄. 두 연관은 모두 컬렉션을 사용함.
* 카테고리 예시를 살펴보았다. p.122 
* 읽기 전 카테고리와 상품은 생명주기가 다르므로 ID를 분리하는 것이 맞다고 생각함. 상품은 카테고리에 포함되지만 다른 애그리거트라고 생각.
* 카테고리에 포함된 모든 상품을 조회하면 성능에 큰 문제가 발생!
* 역시 Product 클래스 내부에 CategoryId를 저장하는 필드를 만듦. 해당 방식으로 문제를 해결! 
* M - N 도 조인 테이블과 ID 참조를 통해 해결함. 여기서 밸류 타입에 대한 컬렉션 매핑을 이용함. p.124. 이렇게 구현하면 되는구나 충격. 잘 기억하자!!!
* JPA를 이용한 모델 매핑에 대한 내용과 컬렉션을 사용할 때의 성능 관련 문제는 추후에 4장에서 살펴볼 예정.

## chapter 3.6 애그리거트를 팩토리로 사용하기

* 예제 코드(p.125)는 상품을 생성 가능한지 판단하는 코드와 상품을 생성하는 코드가 분리되어 있다.
* 코드가 나빠 보이지는 않는데, 중요한 도메인 로직 처리가 응용 서비스에 노출됨.
* Store가 Product를 생성할 수 있는 지를 판단하고 Product를 생ㅅ어하는 논리적으로 하나의 도메인 기능인데 이 도메인 기능을 응용 서비스에서 구현하는 것이다.
* 해당 기능을 Store 애그리거트에 구현하자.
* Store 애그리거트의 createProduct()는 Product 애그리거트를 생성하는 팩토리 역할을 한다. 팩토리 역할을 하면서도 중요한 도메인 로직을 구현하고 있다.
* 리팩토링한 코드와 이전 코드의 차이점은 응용 서비스에서 더 이상 Store의 상태를 확인하지 않는다는 점이다.
* Store가 Product를 생성할 수 있는지를 확인하는 도메인 로직은 Store에서 구현하고 있다.
* Product 생성 가능 여부를 확인하는 도메인 로직을 변경해도 도메인 영역의 Store만 변경하면 되고 응용 서비스는 영향을 받지 않는다.
* 도메인의 응집도가 높아졌다. 이것이 애그리거트를 팩토리로 사용할 때 얻을 수 있는 장점이다.
* 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.
* Store 애그리거트가 Product 애그리거트를 생성할 때 많은 정보를 알아야 한다면 Store 애그리거트에서 Product 애그리거트를 직접 생성하지 않고 다른 팩토리에 위임하는 방법도 있다.
* 다른 팩토리에 위임하더라도 검증 로직과 같은 도메인 로직은 한 곳에 계속 위치해야 한다.