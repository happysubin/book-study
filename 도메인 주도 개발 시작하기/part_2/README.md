# part 2. 아키텍처 개요

## chapter 2.1 네 개의 영역

* presentation, application, domain, infrastructure는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.
* presentation 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.
* application 영역은 시스템이 사용자에게 제공해야할 기능을 구현하는데 '주문 등록', '주문 취소', '상세 주문 조회'와 같은 기능 구현을 예로 들 수 있다.
* application 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다.
* application 영역은 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
* 도메인 영역은 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심로직을 구현한다. 예를 들어 주무 도메인은 '배송지 변경', '결제 완료', '주문 총액 계산'과 같은 핵심 로직을 도메인 모델에서 구현한다.
* infrastructure 영역은 구현 기술에 대한 것을 다룬다.
* infrastructure 영역은 RDBMS를 연동하거나 메시징 큐에 메시지를 전송하거나 수신하는 기능 등을 구현한다.
* infrastructure 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.

## chapter 2.2 계층 구조 아키텍처

* 계층 구조의 아키텍처는 presentation -> application -> domain -> infrastructure 으로 흔히 구성된다.
* 계층 구조는 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 게층에 의존하지 않는다.
* 계층 구조를 더 유연하게 가져갈 수 있는데 application에서 외부 시스템과의 연동을 위해 infrastructure 계층을 의존하는 경우도 많다.
* application, domain 영역은 DB나 외부 시스템 연동을 위해 infrastructure 사용하는데, 이런 경우 모든 계층이 infrastructure 계층에 종속된다. 이 부분이 중요하다.
* infrastructure 계층에 의존하면 2가지 문제가 생긴다.
* 먼저 첫 번째는 테스트가 어렵다는 점이다. 의존하는 시스템의 설정을 마치고 코드를 작성해야만 테스트를 진행할 수 있다.
* 두 번째는 구현 방식을 변경하기 어렵다는 점이다. 의존하는 것처럼 보이지 않아도 infrastructure 영역 기술에 의존하는 예시 코드를 살펴봄. p.68.
* infrastructure 계층에 의존하면 테스트 어려움과 기능 확장의 어려움이 발생한다. 이 문제를 풀기 위해서는 DIP를 적용해야 한다.

## chapter 2.3 DIP

* 고수준 모듈이 동작하려면 저수준 모듈(ex. infrastructure 계층 기술 구현 클래스)를 사용해야 한다.
* 그런데 고수준 모듈이 저수준 모듈을 사용하면 앞ㅇ서 계층 구조에서 언급했던 두 가지 문제, 구현 변경과 테스트가 어렵다는 문제가 발생한다.
* DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 만든다. 즉 추상화한 인터페이스를 사용하는 것이다.
* 인터페이스를 의존하는 고수준 모듈 클래스 예제를 살펴봄. p.71
* DIP를 적용하면 저수준 모듈이 고수준 모듈에 의존하게 된다.
* 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP(Dependency Inversion Principle) 의존성 역전 원칙이라고 한다.
* DIP를 적용하면 앞의 다른 영역이 infrastructure 계층에 의존할 때 발생했던 두 가지 문제인 구현 교체가 어렵다는 점과 테스트가 어렵다는 점을 해소할 수 있다.
* Mockito 프레임워크를 사용해 고수준 모듈을 쉽게 대체하는 테스트 코드를 살펴봄. p.75
* 고수준 모듈은 infrastructure 계층에 위치하는 것이 아닌 domain 계층에 위치해야 한다. 여기서는 infrastructure 구체 클래스가 구현한 인터페이스를 의미한다.
* infrastructure 계층은 구현 기술을 다루는 저수준 모듈이고 application과 domain 계층은 고수준 모듈이다.
* 아키텍처에 DIP를 적용하면 infrastructure 영역이 application 영역과 domain 영역에 의존하는 구조가 된다.
* infrastructure 계층의 클래스가 도메인이나 application 계층에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 application 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.
* DIP를 항상 적용할 필요는 없다. 구현 기술에 의존적인 코드를 도메인에 일부 포함하는 것이 효과적일 때도 있다. 적절한 트레이드 오프는 늘 필수다.


## chapter 2.4 도메인 영역의 주요 구성요소

* 도메인 영역의 주요 구성요소는 아래와 같다.

| 영역             | 설명                                                                                                                                        |
|----------------|-------------------------------------------------------------------------------------------------------------------------------------------|
| ENTITY         | 고유의 식별자를 갖는 개체로 자신의 라이프 사이클을 갖는다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다                             | 
| VALUE          | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 주소, 금액과 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.                     |
| AGGREGATE      | 애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다 예를들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트라고 묶을 수 있다.                        |
| REPOSITORY     | 도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.                                                                          |
| DOMAIN SERVICE | 특정 엔티티에 속하지 않는 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다. |

### section 2.4.1 엔티티와 밸류

* DB 모델의 엔티티와 도메인 모델의 엔티티는 같은 것이 아니다. 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점이다.
* 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체다.
* 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
* 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것이다.
* 밸류는 불변으로 구현할 것을 권장하며, 이는 엔티티의 밸류 타입 데이터를 변경할 때는 객체 자체를 완전히 교체한다는 것을 의미한다.
* 예를 들어 배송지 정보를 수정하려면, 기존 객체 값을 수정하지 않고 새로운 개체를 필드에 할당하는 것이다.

### section 2.4.2 애그리거트

* 규모가 커질수록 도메인 모델의 구성요소는 복잡해진다.
* 도메인 모델을 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는 데 도움이 된다.
* 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 바로 애그리거트다. 애그리거트는 관련 객체를 하나로 묶은 군집이다.
* 애그리거트의 대표적인 예가 주문이다. 주문이라는 도메인 개념은 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액의 하위 모델로 구성이 된다.
* 이 하위 개념을 표현한 모델을 하나로 묶어서 주문이라는 상위 개념으로 표현할 수 있다.
* 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다.
* 개별 객체 간의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현하게 되며, 큰 틀에서 도메인 모델을 관리할 수 있다.
* 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 가진다.
* 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
* 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근한다.
* 이것은 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화 할 수 있도록 돕는다. 예를 들어 애그리거트 루트인 주문이 애그리거트에 속한  객체를 관리한다.


### section 2.4.3 리포지토리

* 도메인 객체를 지속적으로 사용하려면 RDBMS, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야 한다.
* 이를 위한 도메인 모델이 리포지토리다.
* 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지토리는 구현을 위한 도메인 모델이다.
* 리포지토리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
* 도메인 모델을 사용해야 하는 코드는 리포지토리를 통해서 도메인 객체를 구한 뒤에 도메인 객체의 기능을 실행한다.
* application 계층과 리포지토리는 밀접한 연관이 있다.
  * application은 필요한 도메인 객체를 구하거나 저장할 때 리포지토리를 사용한다.
  * application은 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지토리의 구현 기술의 영향을 받는다.

## chapter 2.5 요청 처리 흐름

* 요청 처리 예시 흐름은 아래와 같다.
    1. 사용자가 서버로 HTTP 요청을 보낸다.
    2. 프레젠테이션 계층에서 요청 데이터를 application 필요 스펙에 맞게 변환하고 application 계층에서 사용할 모듈 실행
    3. 도메인이 필요하다면 application 계층에서 리포지토리를 통해 도메인 객체를 가져온다.
    4. 도메인 로직이 실행된다.
    5. application 계층에서 도메인 로직이 실행되면서 리턴 된 값을 프레젠테이션 영역으로 리턴한다.
    6. 리턴 값을 HTTP 응답으로 보낸다.
* application은 비즈니스 로직이 실행되므로 트랜잭션을 처리한다.

## chapter 2.6 인프라스트럭쳐 개요

* 늘 인프라스트럭처에 대한 의존을 없앨 필요는 없다.
* 구현의 편리함은 DIP가 주는 다른 장점만큼 중요하기 때문이다.
* 따라서 DIP의 장점을 해치지 않는 범위에서 application 영역과 도메인 영역에서 구현 기술ㄹ에 대한 의존을 가져가는 것이 나쁘지 않다.
* 좋은 예가 바로 스프링의 @Transactional 애노테이션이다.


## chapter 2.7 모듈 구성

* 모듈 예시를 살펴봄. p.96
* 작가님은 한 패키지에 가능하면 10 ~ 15개 미만으로 타입 개수를 유지하려고 노력하신다고 한다. 이 개수가 넘어가면 패키지 분리를 시도 하신다고.



