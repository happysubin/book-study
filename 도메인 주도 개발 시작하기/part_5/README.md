# part 5. 스프링 데이터 JPA를 이용한 조회 기능

## chapter 5.1 시작에 앞서

* CQRS는 명령 모델과 조회 모델을 분리하는 패턴이다.
* 명령 모델은 상태를 변경하는 기능을 구현할 때 사용하고 조회 모델은 데이터를 조회하는 기능을 구현할 때 사용한다. Object에서 본 명령 쿼리 모델 느낌.
* 엔티티, 애그리거트, 리포지터리 등의 모델은 상태를 변경할 때 주로 사용한다. 즉 도메인 모델은 명령 모델로 주로 사용된다.
* 페이징, 정렬, 검색 조건 지정과 같은 기능은 조회 모델을 구현해서 사용한다.
* 리포지터리는 명령 모델에서 사용하는 것 같고, DAO는 데이터 접근, 즉 조회 모델에서 사용하는 것 같다.

## chapter 5.2 검색을 위한 스펙

* 검색 조건을 다양하게 조합해야 할 때 사용할 수 있는 것이 스펙이다. Specification.
* 스펙은 애그리거트가 특정 조건을 충족하는지를 검사할 때 사용하는 인터페이스다.
* Order 애그리거트 객체가 특정 고객의 주문인지 확인하는 스펙을 구현하는 코드를 살펴봄.
* 리포지터리나 DAO는 검색 대상을 걸러내는 용도로 스펙을 사용한다.
* 리포지터리가 스펙을 이용해서 검색 대상을 걸러주므로 특정 조건을 충족하는 애그리거트를 찾고 싶으면 원하는 스펙을 생성해서 리포지터리에 전달해 주기만 하면 된다.
* 하지만 실제 스펙은 이렇게 구현하지 않는다. 실제 스펙은 기술에 맞춰 구현하게 된다.
* 이번 장에서는 스프링 데이터 JPA를 이용한 스펙 구현에 대해 알아보겠다.

## chapter 5.3 스프링 데이터 JPA를 이용한 스펙 구현

* 스프링 데이터 JPA는 검색 조건을 표현하기 위한 인터페이스인 SPecification을 제공한다.
* 스펙 인터페이스에서 제네릭 타입 파리미터 T는 JPA 엔티티 타입을 의미한다.
* toPredicate() 메서드는 JPA 크리테리아 API에서 조건을 표현하는 Predicate을 생성한다.
* 예제 코드를 살펴봄. p.179. 정적 메타 모델에 대해서도 알아봄. p.180
* 스펙 구현 클래스를 개별적으로 만들지 않고 별도 클래스에 스펙 생성 기능을 모아도 된다.
* 예제 코드 181. 함수형 인터페이스를 사용

## chapter 5.4 리포지터리/DAO에서 스펙 사용하기

* findAll 메서드 파라미터로 스펙 인터페이스를 넣는 코드를 살펴봄. p.182
* 해당 코드처럼 메서드를 사용하면 작성한 스펙 구현체를 사용해서 특정 조건을 충족하는 엔티티를 찾을 수 있다.

## chapter 5.5 스펙 조합

* 스프링 데이터 JPA가 제공하는 스펙 인터페이스는 스펙을 조합할 수 있는 두 메서드를 제공한다. 이 두 메서는 and와 or이다.
* and()와 or() 메서드는 기본 구현을 가진 디폭트 메서드다. spec 예시 코드를 살펴봄. p.183 , p.184
* and()와 or() 메서드를 사용하면 개별 스펙 조건마다 변수를 선언하지 않아도 된다. 불필요한 변수 사용을 줄일 수 있다.
* not() 메서드도 제공한다. not은 정적 메서드로 조건을 반대로 적용할 때 사용환다.
* null 가능성이 있는 스펙 객체와 다른 스펙을 조합해야 할 때가 있다. null 여부를 매번 검사하는건 상대적으로 귀찮은 일.
* where() 메서드를 사용해 이런 귀찮음을 줄였다. 
* 스펙 인터페이스의 정적 메서드로 null을 전달하면 아무 조건도 생성하지 않는 스펙 객체를 리턴하고 Null이 아니면 인자로 받은 스펙 객체를 그대로 리턴한다.

## chapter 5.6 정렬 지정하기

* 스프링 데이터 JPA는 두 가지 방법을 사용해서 정렬을 지정한다.
  * 메서드 이름에 OrderBy를 사용해서 정렬 기준 지정
  * Sort를 인자로 전달
* 이름을 사용해 쿼리 메서드를 만드는 방식. p. 186 코드를 살펴봄.

## chapter 5.7 페이징 처리하기

* 스프링 데이터 JPA는 페이징 처리를 위해 Pageable 타입을 이용한다.
* Sort와 마찬가지로 메서드에 Pageable 타입 파라미터를 사용하면 페이징을 자동으로 해준다.
* 페이징 처리와 관련된 정보가 필요 없다면 Page 리턴 타입이 아닌 List를 사용해서 불필요한 COUNT 쿼리를 실행하지 않도록 한다.
* 스펙을 사용하면 COUNT 쿼리를 실행한다고 한다.
* 스펙을 사용하고 페이징 처리를 하면서 COUNT 쿼리는 실행하고 싶지 않으면 커스팀 리포지터리 기능을 사용해야 한다. p. 189
* https://javacan.tistory.com/entry/spring-data-jpa-range-query

## chapter 5.8 스펙 조합을 위한 스펙 빌더 클래스

* p.190 예시 코드를 살펴봄.
* 스펙을 생성할 때 조건에 따라 스펙을 생성해야할 때가 있는데 그 때 스펙 빌더 클래스를 사용한다고 한다.

## chapter 5.9 동적 인스턴스 생성

* 예전에 JPA에서 본 내용 DTO를 스프링 데이터 리포지터리에서 생성해서 넘겨주는 방식
* 조회 전용 모델을 만들어 표현 영역을 통해 사용자에게 데이터를 보여준다.
* 동적 인스턴스의 장점은 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 동시에 지연 즉시 로딩과 같은 고민 없이 원하는 모습으로 데이터를 조회할 수 있다는 점이다.

## chapter 5.10 하이버네이트 @Subselect 사용

* 해당 애노테이션은 엔티티 클래스에서 작성해야 한다.
* 물론 엔티티에 JPA 애노테이션이 붙어 있지만 해당 기능까지 사용한다면 단일 책임 원칙을 많이 벗어난다고 생각한다.
* @Subselect로 조회한 엔티티는 수정할 수 없다. 예시 코드를 살펴봄 P. 196, p. 197. 이런게 있다 정도로 이해하자!




