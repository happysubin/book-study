# part 9. 도메인 모델과 바운디드 컨텍스트

## chapter 9.1 도메인 모델과 경계

* 처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.
* 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 도메인을 만들게 된다.
* 예를 들어 상품이라는 모델을 살펴보면, 카탈로그에서 상품, 재고 관리에서 상품, 주문에서 상품, 배송에서 상품은 의미만 같지 실제로 의미하는 것이 다르다.
* 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
* 카탈로그 도메인에서의 상품이 검색 도메인에서는 문서로 불리기도 한다. 비슷하게 시스템을 사용하는 사람을 회원 도메인에서는 회원이라고 부르지만, 주문 도메인에서는 주문자라고 부른다.
* 이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수 없다.
* 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다.
* 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
* 여러 하위 모델이 섞이기 시작하면 모델의 의미가 약해질 뿐만 아니라 여러 도메인의 모델이 서로 얽히기 때문에 각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.
* 모델은 특정한 컨텍스트 하에서 완전한 의미를 갖는다.
* 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다.
* 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트라고 부른다.

## chapter 9.2 바운디드 컨텍스트

* 바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.
* 바운디드 컨텏트느는 용어를 기준으로 구분한다.
* 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다.
* 또한 바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.
* 이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다. 바운디드 컨텍스트는 기업의 팀 조직 구조에 따라 결정되기도 한다.
* 예를 들어 주문 하위 도메인이라도 주문을 처리하는 팀과 복잡한 결제 금액 계산 로직을 구현하는 팀이 따로 있다고 가정하자.
* 이 경우 주문 하위 도메인에 주문 바운디드 컨텍스트와 결제 금액 계산 바운디드 컨텍스트가 존재하게 된다.
* 용어를 명확하게 구분하지 못해 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 하는 데, 예를 들어 카탈로그와 재고 관리가 아직 명확하게 구분되지 않은 경우 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.
* 규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현할 때도 있다. 소규모 쇼핑몰은 하나의 시스템에서 회원, 카탈로그, 재고, 구매, 결제와 관련된 모든 기능을 제공한다.
* 여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현하는 것이다.
* 이 때 주의할 점은 여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다.
* 비록 한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하며, 이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않고 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 볼 수 있다.
* 즉 물리적인 바운디드 컨텍스트가 한 개이더라도 내부적으로 패키지를 활용해서 논리적으로 바운디드 컨텍스트를 만든다.
* 바운디드 컨텍스트는 각자 구현하는 하위 도메인에 맞는 모델을 가진다.

## chapter 9.3 바운디드 컨텍스트 구현

* 바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다.
* 바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처 영역을 모두 포함한다. 테이블도 물론 포함이다.
* 모든 바운디드 컨텍스트를 만드시 도메인 주도로 개발할 필요는 없다. CQRS 패턴처럼 명령 모델과 쿼리 모델을 혼합하는게 더 좋은 방법일 수도 있다.
* 각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다. 또한 바운디드 컨텍스트는 UI를 가지지 않을 수도 있다. 다양하게 존재!

## chapter 9.4 바운디드 컨텍스트 간 통합

* 카테고리 바운디드 컨텍스트와 추천 기능을 위한 바운드 컨텍스트의 통합 예제를 살펴봄.
* 사용자가 카탈로그 바운디드 컨텍스트에 추천 제품 목록을 요청하면 카탈로그 바운디드 컨텍스트는 추천 바운디드 컨텍스트로부터 추천 정보를 읽어와 추천 제품 목록을 제공한다.
* 카탈로그 컨텍스트와 추천 컨텍스트의 도메인 모델은 서로 다르다.
* 카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기보다는 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야 한다.
* 상품 추천 도메인 서비스 인터페이스는 도메인 패키지에 위치. 도메인 서비스를 구현한 클래스는 인프라스트럭처 영역에 위치.
* REST API를 사용해 두 바운디드 컨텍스틀 통합하는 코드 예제를 살펴봄. p. 287. 메시지 시스템을 사용해 통합하는 방식도 존재. 큐 방식과 pub/sub.
* 참고 - MSA는 바운디드 컨텍스트와 잘 어울린다.

## chapter 9.5 바운디드 컨텍스트 간 관계

* 바운디드 컨텍스트는 어떤 식으로는 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.
* 두 바운디드 컨텍스트 관계 중 가장 흔한 관계는 한쪽에서 API를 제공하고 한 쪽은 API를 호출하는 관계다.
* 하류 컴포넌트(카탈로그 컨텍스트)는 상류 컴포넌트(추천 컨텍스트)가 제공하는 기능에 의존한다.
* 상류팀과 하류 팀은 개발 계획을 서로 공유하고 일정을 협의해야 한다.
* 상류 팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다.
* 이런 서비스를 가리켜 공개 호스트 서비스라고 한다. 대표적인 예는 검색이 있다. p.294 이미지.
* 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다고 한다. 이를 공유 커널이라고 부른다.
* 공유 커널의 장점은 중복을 줄여주는 것이다. 하지만 두 팀이 같은 모델을 공유하므로 한 팀에서 임의로 모델을 변경하면 안되며 두 팁이 밀접한 관계를 유지해야 한다.
* 서로 통합하지 않은 독립 방식도 존재한다. 독립 방식에서 두 바운디드 컨텍스트의 통합은 수동으로 사용자에 의해 이루어진다. 규모가 커질수록 독립 방식에는 한계가 있다.

## chapter 9.6 컨텍스트 맵

* 바운디드 컨텍스트 간 관계를 알아보기 쉽게 정리한 것이 컨텍스트 맵이다.
* 컨텍스트 맵은 시스템 전체 구조를 보여준다. 
* 이는 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절하고 사업의 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는 데 도움을 준다.





== 이벤트는 추후에 읽기