# part 8. 애그리거트 트랜잭션 관리

## chapter 8.1 애그리거트와 트랜잭션 

* 운영자와 고객이 동시에 한 주문 애그리거트를 수정하는 예시를 살펴봄.
* 트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.
* 운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트이지만 물리적으로 서로 다른 애그리거트 객체를 사용한다.
* 운영자가 주문 애그리거트 객체를 배송 상태로 변경하는데, 고객도 주문 애그리거트의 배송지 정보를 수정함. 애그리거트의 일관성이 깨져버린다.
* 일관성이 깨지는 문제가 발생하지 않도록 하려면 다음 두 가지 중 하나를 선택해야 한다.
  * 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하도록 막는다.
  * 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.
* 이 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있다.
* DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다.
* 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있다.
* 선점 잠금은 비관적 잠금, 비선점 잠금은 낙관적 잠금이라는 용어로도 표현한다.

## chapter 8.2 선점 잠금(비관적 잠금)

* 선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.
* 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.
* 위 예시에 선점 잠금을 대입하면 운영자 스레드가 먼저 선점 잠금 방식으로 주문 애그리거트를 구하면 운영자 스레드가 선점 잠금을 해제할 때까지 고객 스레드는 대기 상태가 된다.
* 운영제 스레드가 배송 상태로 변경한 뒤 트랜잭션을 커밋하면 잠금을 해제한다. 잠금ㅇ이 해제된 시점에 고객 스레드가 구하는 주문 애그리거트는 운영자 스레드가 수정한 배송 상태의 주문 애그리거트다.
* 배송 상태이므로 주문 애그리거트는 배송지 변경 시 에러를 발생하고 트랜잭션은 실패하게 된다.
* 선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다.
* JPA는 아래와 같은 방식으로 선점 잠금 방식을 적용한다.
```
Order order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE);
```
* 스프링 데이터 JPA는 @Lock 애너테이션을 사용해서 잠금 모드를 지정한다.
```
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select m from Member m where m.id = :id")
Optional<Member> findByIdForUpdate(MemberId id);
```

### section 8.2.1 선점 잠금과 교착 상태

* 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야 한다.
* 선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가한다.
* 이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정해야한다.
* JPA에서 선점 잠금을 시도할 때 최대 대기 시간을 지정하려면 다음과 같이 힌트를 사용한다. 지정한 시간 이내에 잠금을 구하지 못하면 예외를 던진다.
```
Map<String, Object> hints = new HashMap<>();
hints.put("javax.persistence.lock.timeout", 2000);
Order order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE, hints);
```
* 해당 힌트를 사용할 때 주의할점은 DBMS가 관련 기능을 지원하지 않을 수도 있으므로 이를 확인해야 한다.
* 스프링 데이터 JPA는 @QUeryHints 애너테이션을 사용해서 쿼리 힌트를 지정할 수 있다.
```
@Lock(LockModeType.PESSIMISTIC_WRITE)
@QueryHints({@QueryHint(name = "javax.persistence.lock.timeout", value = 2000)})
@Query("select m from Member m where m.id = :id")
Optional<Member> findByIdForUpdate(MemberId id);
```
* 참고 - DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다. 따라서 선점 잠금을 사용하려면 사용하는 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는지 반드시 확인해야 한다.

## chapter 8.3 비선점 잠금(낙관적 잠금)

* 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다. p.253 예외 상황을 살펴봄. 페이지에 입력하고 있는데 커넥션을 가져가 충돌이 발생!
* 운영자가 배송지 정보를 조회하고 배송 상태로 변경하는 사이에 고객이 배송지를 변경한 것이다. 이건 선점 잠금으로 해결할 수가 없다.
* 이때 필요한 것이 비선점 잠금인데, 비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.
* 비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다.
* 애그리거트를 수정할 때마다 버전으로 사용할 프로퍼티 값이 1씩 증가한다. p.255 예시를 살펴봄.
* JPA는 버전을 이용한 비선점 잠금 기능을 지원한다. 아래와 같이 엔티티 필드, 즉 컬럼을 넣으면 된다.
```
@Version
private long version;
```
* JPA는 엔티티가 변경되어 업데이트 쿼리를 실행할 때 @Version에 명시한 필드를 이용해서 비선점 잠금 쿼리를 실행한다.
* 비선점 잠금을 위한 쿼리를 실행할 때 쿼리 실행 결과로 수정된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것이다. 이는 트랜잭션이 충돌한 것이므로 예외가 발생.
* OptimisticLockingFailureException이 발생한다. 트랜잭션 애노테이션만 붙여 놓으면 됨!
* 만능인 것 같지만 여기도 예외가 존재. p.258 그림을 보자. 바로 여러 트랜잭션으로 인해 버전이 충돌한 것이다.
* 바선점 잠금 방식을 여러 트랜잭션으로 확장하려면 애그리거트 정보를 뷰로 보여줄 때 버전 정보도 함께 사용자 화면에 전달해야 한다.
* 예외가 발생하면 사용자에게 알려 사용자가 알맞은 후속 처리를 할 수 있게 해야 한다.
* 버전 정보를 뷰에 담는 예시는 HTML 히든 태그에 버전 정보를 넣어두고 이를 같이 폼에 담아 요청하는 것이다. 그럼 이제 표현 계층, 응용 계층 DTO도 버전 값을 저장할 필드를 가져야 한다.
* 응용 서비스는 전달 받은 버전 값을 이용해서 애그리거트 버전과 일치하는지 확인하고, 일치하는 경우에만 기능을 수행해야 한다.
* 예외 코드에 대한 설명도 살펴봄. p.261

### section 8.3.1 선점 잠금과 교착 상태

* 애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재하는데 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경된다고 가정해보자.
* 이 경우 JPA는 루트 엔티티의 버전 값을 증가시키지 않는다.
* 연관된 엔티티의 값이 변경되도 루트 엔티티 자체의 값이 바뀌는 것이 없으므로 루트 엔티티의 버전 값은 갱신하지 않는 것이다.
* 이런 JPA의 특징은 애그리거트 관점에서 보면 문제가 된다.
* 비록 루트 엔티티의 값이 바뀌지 않더라도 애그리거트의 구성요소 중 일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐 것이다.
* 따라서 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전 값이 증가해야 비선점 잠금이 올바르게 동작한다.
* JPA는 이런 문제를 처리할 수 있도록 엔티티 매니저 find 메서드로 엔티티를 구할때 강제로 버전 값을 증가시키는 잠금 모드를 지원한다.

```
entityManager.find(Order.class, orderNo, LockModeType.OPTIMISTIC_FORCE_INCREMENT);
```

* LockModeType.OPTIMISTIC_FORCE_INCREMENT를 사용하면 엔티티의 상태가 변경되었는지에 상관 없이 트랜잭션 종료 시점에 버전 값 증가 처리를 한다.
* 이 잠금 모드를 사용하면 애그리거트 루트 엔티티가 아닌 다른 엔티티나 밸류가 변경되더라도 버전 값을 증가시킬 수 있으므로 비선점 잠금 기능을 안전하게 사용할 수 있다.
* 스프링 데이터 JPA를 사용하면 @Lock 애너테이션을 이용하면 된다.

## chapter 8.4 오프라인 선점 잠금

* 더 엄격하게 데이터 충돌을 막고 싶다면 누군가 수정 화면을 보고 있을 때 다른 사용자는 수정 화면 자체를 실행하지 못하도록 만들어야 한다.
* 이때 필요한 것이 오프라인 선점 잠금 방식이다.
* 단일 트랜잭션에서 동시 변경을 막는 선점 잠금과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.
* 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다. p.264 이미지
* 잠금을 가지고 프로그램을 종료하면 잠금을 해제하지 않으므로 영원히 잠금을 구할 수 없는 상황이 된다. 따라서 오프라인 선점 방식은 잠금 유효 시간을 가져야한다.
* 유효 시간이 지나면 자동으로 잠금을 해제해서 다른 사용자가 잠금을 일정 시간 후에 다시 구할 수 있도록 해야 한다.
* LockManager 인터페이스와 DB를 이용한 LockManager 구현 예시 코드를 살펴봄. p. 265 