# part 10. 이벤트

## chapter 10.1 시스템 간 강결합 문제

주문 바운디드 컨텍스트와 결제바운디드 컨텍스트 간의 __강결합__ 으로 인해 발생하는 문제를 살펴보았다.
주문이 결제와 강하게 결합되어 있어서 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받게 되는 것이다.
 
이런 강결합을 없앨 수 있는 방법이 있는데, 바로 __이벤트__ 를 사용하는 것이다. 특히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.

<br>

## chapter 10.2 이벤트 개요

> 이벤트라는 용어는 '과거에 벌어진 어떤 것'을 의미한다.

이벤트가 발생했다는 것은 상태가 변경됐다는 것을 의미한다. 이벤트는 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

<br>

### Section 10.2.1 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하려면 네 개의 구성요소인, 이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들러(구독자)를 구현해야 한다.

<br>

<img width="420" alt="스크린샷 2023-05-16 오후 2 14 12" src="https://github.com/happysubin/book-study/assets/76802855/ad2336a4-5223-4e27-83dd-e1de4578d794">

<br>

도메인 모델에서 __이벤트 생성 주체__ 는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체다.
이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.

<br>

__이벤트 핸들러__ 는 이벤트 생성주체가 발생한 이벤트에 반응한다.
이벤트 핸들러는 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.

<br>

이벤트 생성 주체와 이벤트 핸들러를 연결해주는 것이 __이벤트 디스패처__ 다.
이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다.
이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다.
이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

<br>

### Section 10.2.2 이벤트의 구성

이벤트는 발생한 이벤트에 대한 정보를 담는다.

* 이벤트 종류: 클래스 이름(과거 시제)으로 이벤트 종류를 표현
* 이벤트 발생 시간
* 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

<br>


### Section 10.2.3 이벤트 용도

이벤트는 크게 두 가지 용도로 쓰인다.
 

첫 번째 용도는 트리거다. 도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
예를 들어 주문을 취소하면 환불을 처리해야 하는데 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.

<br>

두 번째 용도는 서로 다른 시스템 간의 데이터 동기화다.
예를 들어 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다.
주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

<br>


### Section 10.2.4 이벤트 장점

* 이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.
* 이벤트 핸들러를 사용하면 기능 확장도 용이하다. 예를 들어 구매 취소시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면 된다. 
* 기능을 확장해도 구매 취소 로직은 수정할 필요가 없다.

<br>

## chapter 10.3 이벤트, 핸들러, 디스패처 구현

이벤트와 관련된 코드는 아래와 같다.

* 이벤트 클래스: 이벤트를 표현한다.
* 디스패처: 스프링이 제공하는 ApplicationEventPublisher를 이용한다.
* Events: 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher를 사용한다.
* 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.

<br>

### Section 10.3.1 이벤트 클래스

이벤트 자체를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용하면 된다.
이벤트는 과거에 벌어진 상태 변화나 사건을 의미하므로 이벤트 클래스의 이름을 결정할 때에는 과거 시제를 사용해야 한다는 점만 유의하면 된다.
 
이벤트 클래스는 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함해야 한다.

<br>

### Section 10.3.2 Events 클래스와 ApplicationEventPublisher 

이벤트 발생과 출판을 위해 스프링이 제공하는 ApplicationEventPublisher를 사용한다.
스프링 컨테이너는 ApplicationEventPublisher도 되며, Events 클래스는 ApplicationEventPublisher를 사용해서 이벤트를 발생시키도록 구현한다.

<br>

```java
public class Events {
    
    private static ApplicationEventPublisher eventPublisher;
    
    static void setPublisher(ApplicationEventPublisher publisher){
        Events.eventPublisher = publisher;
    }
    
    public static void raise(Event event){
        if(eventPublisher != null){
            eventPublisher.publishEvent(event);
        }
    }
}
```

Events 클래스의 raise()의 메서드는 ApplicationEventPublisher가 제공하는 publishEvent() 메서드를 이용해서 이벤트를 발생시킨다.
Events 클래스가 사용할 Application Event Publisher 객체는 setPublisher() 메서드를 통해서 전달받는다.

<br>

```java
@Configuration
public class EventsConfig {
    
    @Autowired
    private ApplicationContext applicationContext;
    
    @Bean
    public InitializingBean eventsInitializer(){
        return () -> Events.setPublisher(applicationContext);
    }
}

```

eventsInitializer() 메서드는 InitializingBean 타입 객체를 빈으로 설정한다.
이 타입은 스프링 빈 객체를 초기화할 때 사용하는 인터페이스로, 이 기능을 사용해서 Events 클래스를 초기화 했다.
 
참고로 ApplicationContext는 ApplicationEventPublisher를 상속하고 있으므로 Events 클래스를 초기화할 때 ApplicationContext를 전달했다.


<br>


### Section 10.3.3 이벤트 발생과 이벤트 핸들러

이벤트를 발생시킬 코드는 Events.raise() 메서드를 사용한다.
이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener 애노테이션을 사용해서 구현한다.

<br>

### Section 10.3.4 이벤트 발생과 이벤트 핸들러

1. 도메인 기능을 실행한다.
2. 도메인 기능은 Events.raise()를 이용해서 이벤트를 발생시킨다.
3. Event.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해서 이벤트를 출판한다.
4. ApplicationEventPublisher는 @EventListener(이벤트타입.class) 애노테이션이 붙은 메서드를 찾아 실행한다.

코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.

<br>


> 즉 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

<br>

## chapter 10.4 동기 이벤트 처리 문제

이벤트를 사용해 강결합 문제는 해소했지만 아직 외부 서비스에 영향을 받는 문제가 남아있다.
외부 시스템이 갑자기 느려지면, 우리 시스템의 성능 저하로 이어진다. 성능 저하뿐만 아니라 트랜잭션도 문제가 된다.
 
예를 들면 외부 환불 서비스 실행에 실패했다고 해서 반드시 트랜잭션을 롤백 해야하는지에 대한 문제다.
일단 구매 취소 자체는 처리하고 환불만 재처리하거나 수동으로 처리할 수도 있다.

<br>

외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계하는 것이다.

<br>

## chapter 10.5 비동기 이벤트 처리

이벤트를 비동기로 구현할 수 있는 방법은 다양하다. 네 가지 방식을 먼저 알아보자.

1. 로컬 핸들러를 비동기로 실행하기
2. 메시지 큐 사용
3. 이벤트 저장소와 이벤트 포워더 사용하기
4. 이벤트 저장소와 이벤트 제공 API 사용하기

### Section 10.5.1 로컬 핸들러 비동기 실행

* @EnableAsync를 사용해 비동기 기능을 활성화한다.
* 이벤트 핸들러 메서드에 @Async 애너테이션을 붙인다.

### Section 10.5.2 메시지 큐 사용

* 래빗MQ나 카프카를 사용한다.
* 래빗MQ처럼 많이 사용되는 메시징 시스템은 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 임ㅆ다.
* 카프카는 글로벌 트랜잭션을 지원하지는 않지만 다른 메시징 시스템에 비해 높은 성능을 보여준다.

### Section 10.5.3 이벤트 저장소를 이용한 비동기 처리

> TODO 정리 해야함

## chapter 10.6 이벤트 적용 시 추가 고려 사항

이벤트를 구현할 때 고려할 점이 있다.

<br>

#### 첫 번째 주의사항. 이벤트 소스를 EventEntry에 추가할 여부

> TODO 정리 해야함

<br>

#### 두 번째 주의사항. 포워더에서 전송 실패를 얼마나 허용할 것이냐에 대한 것.

> TODO 정리 해야함

<br>

#### 세 번째 주의사항. 이벤트 손실에 대한 것.

이벤트 저장소를 이용한 방식은 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장할 수 있다.
 
반면에 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.

<br>

#### 네 번째 주의사항. 이벤트 순서에 대한 것.

이벤트 발생 순서대로 외부 시스템에 전달해야할 경우, 이벤트 저장소를 사용하는 것이 좋다.
이벤트 저장소는 저장소에 이벤트를 발생 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하기 때문이다.
반면에 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수도 있다.

<br>

#### 다섯 번째 주의사항. 이벤트 재처리에 관한 것.

동일한 이벤트를 다시 처리해야할 때 이벤트를 어떻게 할지 결정해야 한다.
가장 쉬운 방법은 마지막으로 처리한 이벤트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 것이다.

<br>

### Section 10.6.1 이벤트 처리와 DB 트랜잭션 고려

이벤트를 처리할 때는 DB 트랜잭션을 함께 고려해야 한다.
예를 들어 주문 취소와 환불 기능을 다음과 같이 이벤트를 이용해서 구현했다고 하자.

* 주문 취소 기능은 주문 취소 이벤트를 발생시킨다.
* 주문 취소 이벤트 핸들러는 환불 서비스에 환불 처리를 요청한다.
* 환불 서비스는 외부 API를 호출해서 결제를 취소한다.

위 예시에서는 DB에서는 주문이 취소된 상태로 데이터가 바뀌었는데(커밋을 함) 결제는 취소되지 않은 상태로 남게 되는 경우가 존재한다.

<br>

이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 한다.
트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다.
경우의 수를 줄이는 방법은 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.

<br>

__스프링은 @TransactionalEventListener 애노테이션을 지원한다.__
이 애노테이션은 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 해준다.

트랜잭션이 성공할 대만 이벤트 핸들러를 실행하게 되면 트랜잭션 실패에 대한 경우의 수가 줄어 이제 이벤트 처리 실패만 고민하면 된다.
이벤트 특성에 따라 재처리 방식을 결정하면 된다.









