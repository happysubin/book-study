# part 1. 도메인 모델 시작하기

## chapter 1.1 도메인이란

* 도메인이란 소프트웨어로 해결하고자 하는 문제 영역을 말한다.
* 도메인은 다시 하위 도메인으로 나눌 수 있다. (온라인 서점 도메인은 주문, 정산, 회원, 배송 등 작은 하위 도메인으로 이루어진다)
* 특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야 할 모든 기능을 직접 구현하는 것은 아니다. 외부 배송 업체의 시스템이 등을 사용할 수 있다. 결제 시스템도 외부 API를 사용할 수 있다.
* 도메인마다 고정된 하위 도메인이 존재하는 것은 아니다. 하위 도메인을 어떻게 구성할지 여부는 상황에 따라 달라진다.

## chapter 1.2 도메인 전문가와 개발자 간 지식 공유

* 온라인 홍보, 정산, 배송 등 각 영역에는 도메인 전문가가 있다. 이들은 해당 도메인에 대한 지식과 경험을 바탕으로 본인들이 원하는 기능 개발을 요구한다.
* 개발자는 이런 요구사항을 분석하고 설계하여 코드를 작성하며 테스트하고 배포한다.
* 요구사항은 첫 단추와 같다. 첫 단추를 잘못 끼우면 엉뚱한 기능을 만들게 된다. 엉뚱한 기능을 수정하는 건 정말 고역이다.
* 잘못 개발한 코드를 수정해서 올바르게 고치려면 많은 노력이 든다.
* 요구사항을 올바르게 이해하려면 개발자가 도메인 전문가와 직접!! 대화해야한다.
* 도메인 전문가 만큼은 아니지만 좋은 제품을 개발하려면 개발자도 도메인 지식을 갖춰야 한다.

## chapter 1.3 도메인 모델

* 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. p27에서 객체 기반 주문 도메인 모델을 살펴보았다.
* 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 된다.
* 도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야 하는데, 이런 면에서 기능과 데이터를 함께 보여주는 객체 모델은 도메인을 모델링하기에 적합하다.
* 도메인 모델을 객체로만 모델릴할 수 있는 것은 아니다. p.28 상태 다이어그램을 이용해서 주문 상태 전이를 모델링했다.
* 도메인 모델은 어떤 방식을 사용하든 도메인을 이해하는 데 도움이 된다면 그걸로 좋은 것이다.
* 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념이다. 개념 모델을 이용해서 바로 코드를 작성할 수 있는 것은 아니기에 구현 기술에 맞는 구현 모델이 필요하다.
* 도메인에 따라 용어 의미가 결정되므로 여러 하위 도메인을 하나의 다이어그램에 모델링하며 안된다. 예를 들어 카탈로그 도메인의 상품과 배송 도메인의 상품은 다르다.

## chapter 1.4 도메인 모델 패턴

| 영역             | 설명                                                           |
|----------------|--------------------------------------------------------------|
| presentation   | 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 사용자는 사람이 아니라 시스템일 수도 있다.       | 
| Application    | 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다. |
| domain         | 시스템이 제공할 도메인 규칙을 구현한다.                                       |
| infrastructure | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.                       |

* 일반적으로 애플리케이션의 아키텍처는 위 표와 같은 네 개의 영역으로 이루어진다.
* 도메인 계층은 도메인의 핵심 규칙을 구현한다.
* 주문 도메인의 경우 '출고 전에 배송지를 변경할 수 있다'라는 규칙과 '주문 취소는 배송 전에만 할 수 있다.'라는 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.
* 이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.
* Order와 OrderState 코드 예제를 살펴봄.
* 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.
* 처음부터 완벽한 개념 모델을 만들기보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야 한다.
* 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는 데 집중하고, 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.

## chapter 1.5 도메인 모델 도출

* 기획서, 유스케이스, 사용자 스토리와 같은 요구사항과 관련자와의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 비로소 코드를 작성할 수 있다.
* 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.
* 예제 주문 도메인의 요구사항을 살펴봄.
* 예제를 진행함. 주문과 관련된 요구사항에서 도메인 모델을 점진적으로 만들어 나감. 일부는 구현 수준까지 일부는 이름 정도만 정의
* 이렇게 만든 모델은 요구사항 정련을 위해 도메인 전문가나 다른 개발자와 논의하는 과정에서 공유하기도 한다. 모델은 누구나 쉽게 접근 가능해야 한다.
* 문서화를 하는 주된 이유는 지식을 공유하기 위해서다.
* 코드도 문서화의 대상인데, 단순히 보기 좋은 코드를 작성하는 것이 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야 문서로서 코드가 의미를 가진다.

## chapter 1.6 엔티티와 밸류

### 엔티티

* 도출한 모델은 크게 엔티티와 밸류로 구분된다.
* 엔티티의 가장 큰 특징은 식별자를 가진다. 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 가진다. 예를 들어 주문의 주문번호.
* 주문에서 배송지 주소가 바뀌거나 상태가 바뀌더라도 주문번호는 바뀌지 않는다. 마찬가지로 엔티티의 식별자는 바뀌지 않는다. 엔티티의 수명동안 식별자는 그대로 유지된다.
* 엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.
* 엔티티를 구현한 클래스는 식별자를 이용해서 equals() 메서드와 hashCode() 메서드를 구현할 수 있다.
* 흔히 식별자는 다음 중 한 가지 방식으로 생성한다.
  * 특정 규칙에 따라 생성
  * UUID나 Nano Id와 같은 고유 식별자 생성기 사용
  * 값을 직접 입력
  * 일련 번호 사용 (시퀀스나 DB의 자동 증가 컬럼 사용)
* 흔히 사용하는 규칙은 현재 시간과 함께 다른 값을 함께 조합하는 것이다.
* 이른 내용이지만 repository는 도메인 객체를 데이터베이스에 저장할 때 사용하는 구성요소다.
* 자동 증가 컬럼을 사용할 경우 repository는 DB가 생성한 식별자를 구해서 엔티티 객체에 반영한다. 추후에 repository에 대해 더 살펴보자.

### 밸류 

* 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. ShippingInfo를 리팩토링함.
* 밸류 타입이 꼭 두 개 이상의 데이터를 가져야하는 것은 아님.
* 의미를 명확하게 표현하기 위해 밸류 타입을 사용하기도 한다. 좋은 예가 OrderLine이다. Money는 돈을 의미하는데 코드를 이해하는데 도움이 된다.
* 또한 밸류 타입은 밸류 타입을 위한 기능을 추가할 수 있다는 것이다. Money 클래스 예제를 진행.
* 작가님은 밸류 객체의 데이터를 변경하면 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다고 하신다.
* 예를 들어 Money 클래스의 add 메서드를 실행하면 새로운 Money 인스턴스를 생성한다. Money처럼 데이터 변경 기능을 제공하지 않는 타입을 불변이라고 표현한다.
* 불변의 장점은 안전한 코드를 작성할 수 있다는 것이다. 참조 투명성과 관련된 문제를 살펴보았다. p.51
* 밸류 객체를 비교할 때는 모든 속성이 같은지 비교한다.
* 식별자로 String과 같은 문자열을 자주 사용한다. 식별자를 위한 밸류 타입을 사용해서 의미가 더 잘 드러나게 할 수 있다. 
* 예시로 OrderNo 타입을 만들어서 String 타입 대신에 사용한다. 그럼 필드 이름이 OrderNo 이므로 필드의 의미를 더 확실하게 알 수 있다.
* 습관적으로 게터와 세터를 추가하는 습관은 좋지 않다. 특히 세터.
* 습관적으로 작성한 세터는 필드값만 변경하고 끝나기 때문에 상태 변경과 관련된 도메인 지식이 코드에서 사라지게 된다,.
* 또한 세터 메서드는 도메인 객체를 생성하지 않을 때 온전하지 않은 상태가 될 수 있다. 생성자를 통해 필요한 데이터를 모두 받도록 하자.

## chapter 1.7 도메인 용어와 유비쿼터스 언어

* 도메인 용어가 코드에 녹아 있지 않은 예제를 살펴보았다. 코드 분석이 매우 힘듦.
* 에릭 에반스는 도메인 주도 설계에서 언어의 중요함을 강조하기 위해 유비쿼터스 언어라는 용어를 사용했다.
* 전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인, 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용한다.
* 이렇게 하면 소통 과정에서 발생하는 용어의 모호함을 줄이고 갭라자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.
* 시간이 지날수록 도메인에 대한 이해가 높아지는데 새롭게 이해한 내용을 잘 표현할 수 있는 용어를 찾아내고 이를 다시 공통의 언어로 만들어 다 같이 사용한다.
* 새로 발견한 용어는 코드나 문서에도 반영해서 산출물에 최신 모델을 적용한다.
* 도메인에 어울리지 않은 단어를 사용하면 코드는 도메인과 점점 멀어진다. 그러므로 도메인 용어에 알맞은 단어를 찾는 시간을 아까워하지 말자.