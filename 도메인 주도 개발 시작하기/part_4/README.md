# part 4. 리포지터리와 모델 구현

## chapter 4.1 JPA를 이용한 리포지터리 구현

* 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다. (최대한 이렇게 하는 것이 좋다.)
* 리포지터리는 ID로 애그리거트를 조회하고, 저장할 수 있어야 한다. 인터페이스는 애그리거트 루트를 기준으로 작성한다.
* 순수 JPA를 사용해 리포지터리 인터페이스와 구현체를 작성하는 코드를 살펴봄.

## chapter 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현

* 스프링 데이터 JPA는 인터페이스를 사용하는 코드를 살펴봄.
* JpaRepository 를 상속받은 인터페이스를 다른 클래스에서 사용한다면 상속보다는 합성으로 사용하는 것이 좋아보임. p.137

## chapter 4.3 매핑 구현

### section 4.3.1 엔티티와 밸류 기본 매핑 구현

* 애그리거트 루트는 엔티티이므로 @Entity 매핑 설정한다.
* 밸류는 @Embeddable로 매핑 설정한다. 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.
* 밸류와 엔티티를 매핑한 코드 예제를 살펴보았다.

### section 4.3.2 기본 생성자

* 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달 받는다.
* 불변 타입은 세터를 제공하지 않는다.

### section 4.3.3 필드 접근 방식 사용 

* JPA는 필드와 메서드의 두 가지 방식으로 매핑을 처리할 수 있다.
* 메서드 방식을 사용하면 프로퍼티를 위한 게터와 세터를 구현해야 한다. 그러나 이런 방식은 좋지 않다.
* 객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 게터 세터 메서드를 구현하지 말아야 한다.

### section 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리

* int, long, String, LocalDate와 같은 타입은 DB 테이블의 한 개 칼럼에 매핑된다.
* 밸류 타입의 프로퍼티를 한 개 컬럼에 매핑해야 할 때도 있다.
* 예를 들면 Length가 길이 값과 단위의 두 프로퍼티를 갖고 있는데 DB 테이블에는 '1000mm'와 같은 형식으로 저장할 수 있다.
* 이럴 때 사용하는 것이 AttributeConverter이다. 예제 코드를 살펴봄.
* AttributeConverter는 밸류 타입과 칼럼 데이터 간의 변환을 처리하기 위한 기능을 정의하고 있다.

### section 4.3.5 밸류 컬렉션: 별도 테이블 매핑

* 밸류 컬렉션을 별도 테이블로 매핑할 때는 @ElementCollection과 @CollectionTable을 함께 사용한다. 관련 매핑 코드는 다음과 같다.
* JPA는 @OrderColumn 애너테이션을 이용해서 지정한 칼럼에 리스트의 인덱스 값을 저장한다.
* @CollectionTable은 밸류를 저장할 테이블을 지정한다. name 속성은 테이블 이름을 지정하고 joinColumns 속성은 외부키로 사용할 칼럼을 지정한.

### section 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑

* 밸류 컬렉션을 별도 테이블이 아닌 한 개 컬럼에 저장해야 할 때가 있다.
* 예를 들어 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고 DB에는 한 개 칼럼에 콤마로 구분해서 저장해야할 때가 있다.
* 이때 AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다.
* 단 AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.
* 코드 예제를 살펴보았다.(p.150)

### section 4.3.7 밸류를 이용한 ID 매핑

* 식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수도 있다.
* OrderNo, MemberId 등이 식별자를 표현하기 위해 사용한 밸류타입인데, 밸류 타입을 식별자로 매핑하면 @EmbeddedId 애노테이션을 사용해야 한다.
* 참고로 JPA에서 식별자 타입은 Serializable 타입이어야 하므로, Serializable 인터페이스를 상속받아야 한다.
* 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다. 예시 코드 p.152
* JPA는 내부적으로 엔티티를 비교할 목적으로 equals() 메서드와 hashCode() 값을 사용하므로 식별자를 사용할 밸류 타입은 이 두 메서드를 알맞게 구현해야 한다.

### section 4.3.8 별도 테이블에 저장하는 밸류 매핑

* 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류이다.
* 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 한다.
* 단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다. 주문 애그리거트도 OrderLine을 별도 테이블에 저장하지만 OrderLine 자체는 엔티티가 아니라 밸류이다.
* 밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 한다.
* 특히 자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.
* 예를 들어 후기와 상품은 다른 애그리거트다. 
* 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지를 확인하는 것이다.
* 하지만 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안 된다.
* 별도 테이블로 저장하고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 가지는 것은 아니기 때문이다.
* ARTICLE 테이블과 ARTICLE_CONTENT 테이블 예시를 살펴봄. 그냥 연결을 위한 PK용.
* 이런 방식으로 구현하면 문제가 있는데 ARTICL 목록만 가져오려고 하는데 ARTICLE_CONTENT 데이터가 늘 따라온다.
* 위 문제를 해결하려고 지연 로딩 방식을 구현하면 ARTICLE_CONTENT 밸류 타입을 정말 엔티티로 만들어야한다. 이는 좋은 해결방법이 아니다.
* 대신 조회 전용 기능을 구현하는 방법을 사용하는 것이 좋다고 한다. 이는 5장에서 살펴본다. 또한 11장에서 명령 모델과 조회 전용 모델 구분에 대해서 알아본다고 한다.

### section 4.3.9 밸류 컬렉션을 @Entity로 매핑하기

* 개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때가 있다.
* 이미지 경로와 섬네일 제공 여부가 달라진다라는 예시를 듦. (p.156 그림 4.7 )
* JPA는 @Embeddable 타입의 클래스 상속 매핑을 지원하지 않는다. 엔티티 상속을 사용한 @DiscriminatorColumn 사용 예제를 살펴봄.
* @OneToMany에서 컬렉션의 clear() 메서드는 효율적이지 않다. 이유는 대상 객체를 가져와서 하나하나 delete 쿼리를 실행하기 때문이다. 
* 따라서 사용 빈도가 높으면 전체 서비스에 문제가 될 수 있다.
* @Embeddable는 clear() 메서드는 한 번의 delete로 쿼리로 삭제 처리를 수행한다. 물론 다형성을 사용할 수는 없다. if-else로 로직을 처리해야함.
* 결국 트레이드 오프!!!! 이런 상황에서 엔티티 vs 밸류는 트레이드 오프다. 코드 유지 보수와 성능의 두 가지 측면을 고려해서 구현 방식을 선택해야 한다.

### section 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

* 애그리거트 간 집합 연관은 성능 상의 이유로 피해야 한다고 했다.
* 그럼에도 불구하고 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용해 볼 수 있다.
* 이전에 살펴본 예시와 동일하게 ID를 사용해 직접 참조가 아니라 간접 참조 예제를 살펴봄. 아주 좋은 듯. 꼭 기억하자. (p.160)

## chapter 4.4 애그리거트 로딩 전략

* JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.
* 즉 애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태여야 함을 의미한다.

```
Product product = productRepository.findById(id);
```

* 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정하면 된다.
* 물론 JPA 글로벌 지연 로딩 전략에서는 추천하지 않는 방법이다. 컬렉션에 대해 로딩 전략을 EAGER로 설정하면 성능에서 문제가 있을 수 있기 때문이다.
* 애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야하는 것은 아니다.
* 애그리거트가 완전해야 하는 이유는 두 가지 정도로 생각해 볼 수 있다.
  1. 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하기 때문이다.
  2. 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다.
* 두 번째는 별도의 조회 전용 기능과 모델을 구현하는 방식을 사용하는 것이 더 유리하다. 
* 상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필요는 없다.
* JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.
* 일반적인 애플리케이션은 상태 변경 기능을 실행하는 빈도보다 조회 기능을 실행하는 빈도가 훨씬 높다.
* 그러므로 상태 변경을 위해 지연로딩을 사용할 때 발생하는 추가 쿼리로 인한 실행 속도 저하는 보통 문제가 되지 않는다.
* 그냥 전역적으로 지연 로딩을 설정하고 필요한 것(특히 조회)만 즉시 로딩을 설정하면 될 듯.

## chapter 4.5 애그리거트의 영속성 전파

* 애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다.
  * 저장 메서드는 애그리거트 루트만 저장하면 안 되고 애그리거트에 속한 모든 객체를 저장해야 한다.
  * 삭제 메서드는 애그리거트 루트뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.
* @Embeddable 매핑 타입은 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다.
* 애그리거트에 속한 @Entity 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설정해야 한다.

## chapter 4.6 식별자 생성 기능

* 식별자는 크게 세 가지 방식 중 하나로 생성한다.
  * 사용자가 직접 생성
  * 도메인 로직으로 생성
  * DB를 이용한 일련번호 사용
* 식별자 생성 규칙이 있다면 엔티티를 생성할 때 식별자를 엔티티가 별도 서비스로 식별자 생성 기능을 분리해야 한다.
* 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야 한다.
* 특정 값의 조합으로 식별자가 생성되는 것 역시 규칙이므로 도메인 서비스를 이용해서 식별자를 생성할 수 있다.
* DB 자동 증가 칼럼을 식별자로 사용하면 식별자 매핑에서 @GeneratedValue를 사용한다.
* 자동 증가 컬럼은 DB의 insert 쿼리를 실행해야 식별자가 생성되므로 도메인 객체를 리포티저리에 저장할 때 식별자가 생성된다.
* 이 말은 도메인 객체를 생성하는 싲머에는 식별자를 알 수 없고 도메인 객체를 저장한 뒤에 식별자를 구할 수 있음을 의미한다.
* JPA는 저장 시점에 생성한 식별자를 @Id를 매핑 한 프로퍼티/필드에 할당하므로 위 코드처럼 저장 이후에 엔티티의 식별자를 사용할 수 있다.
* 자동 증가 칼럼 외에 JPA의 식별자 생성 기능을 사용하는 경우에도 마찬가지로 저장 시점에 식별자를 생성한다.

## chapter 4.7 도메인 구현과 DIP

* 이 장에서 구현한 리포지터리는 DIP 원칙을 어기고 있다. 먼저 엔티티는 아래 코드처럼 구현 기술인 JPA 애노테이션에 의존하고 있다.
* 도메인 모델이 영속성 구현 기술인 JPA에 의존하고 있는 것이다.
* 리포지터리 인터페이스도 마찬가지다. 스프링 데이터 JPA의 Repository 인터페이스를 상속하고 있다. 즉 도메인이 인프라에 의존하는 것이다.
* DIP를 적용하는 주된 이유는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않기 위함이다.
* 그러나 작가님께서 JPA를 사용하면서 마이바티스, 몽고 DB로 변경한적도 없다고 하심. 즉 경험에 의한 트레이드오프를 하신 것!
* 역시 설계는 트레이드 오프다.

