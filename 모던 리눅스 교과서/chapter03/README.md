
# 3장. 셸과 스크립팅


CLI 관점에서 리눅스 상호 작용하는 방법은 두 가지가 있다.

첫 번째 방법은 수동이다. 즉 사용자가 터미널 앞에 앉아 대화식으로 명령을 입력하고 출력값을 받는 것이다.
이런 즉흥적인 상호작용은 다음과 같이 매일 셸에서 수행하는 대부분의 작업에 해당한다.
이런 즉흥적인 상호작용은 다음과 같이 매일 셰{ㄹ에서 수행하는 대부분의 작업에 해당한다.

* 디렉터리 목록 출력, 파일 찾기, 파일 내부 내용 찾기
* 디렉토리 간 혹은 원격 시스템 간 파일 복사
* 이메일이나 뉴스를 읽거나 터미널에서 트윗 보내기

두 번째는 셸스크립팅 또는 스크립팅이라고 한다.

특수한 종류의 파일에 있는 일련의 명령을 자동으로 처리하는 것이다.

## 기본 개요

### 터미널

터미널은 텍스트로 된 사용자 인터페이스를 제공하는 프로그램이다.
터미널은 키보드에서 문자를 읽어 화면에 표시하는 기능을 지원.

기본적인 문자 중심의 입력과 출력외에도 터미널은 커서, 화면 처리, 그리고 잠재적으로 색상 지원이 가능하도록 이스케이프 시퀀스 또는 이스케이프 코드를 지원한다.

환경 변수 TERM은 사용중인 터미널 에뮬레이터 값을 가지고 있으며, 다음과 같이 infocmp를 통해 구성할 수 있다.

```
infocmp
```

### 셸

터미널 내부에서 실행되며 명령 인터프리터 역할을 하는 프로그램 셸.

셸은 스트림을 통해 입력, 출력을 처리하고 변수를 지원하며, 사용 가능한 내장 명령이 몇 가지 있으며, 명령 실행 및 상태를 처리하고, 일반적으로 대화식 사용과 스크립트 사용을 모두 지원한다.

공식적으로 셸은 sh로 정의하며, 종종 POSIX 셸이라는 용어를 접하게 되는데, 이는 스크리븥와 이식성 맥락에서 더욱 중요하다.

원래 sh가 많이 쓰였지만, 최근에는 대부분 배시 셸이 sh의 자리를 대체해 기본으로 널리 쓰이고 있다.

어떤 셸이 사용되고 있는지 궁금하면 아래 명령어를 사용해보자

```
file -h /bin/sh

echo $0

echo $SHELL
```

### 스트림

셸은 입력과 출력을 위한 세 가지 파일 디스크립터(FD)를 프로세스에 제공한다.

* stdin(FD 0)
* stdout(FD 1)
* stderr(FD 2)

이 FD들은 기본적으로 화면과 키보드에 각각 연결되어 있다.
셸에 입력하는 명령은 키보드에서 입력(stdin)을 가져오고 출력(stdout)을 화면에 전송한다.

셸이 제공하는 기본값을 사용하지 않으려면 스트림을 재지정할 수 있다.

$FD>와 <$FD를 사용해 프로세스의 출력 스트림을 재지정할 수 있따.
여기서 $FD는 파일 디스크립터다.

예를 들어 2>는 stderr 스트림을 재지정한다는 의미다.
1>과 >는 stdout이 기본 값이므로 동일한 뜻이다.

stdout과 stderr을 모두 재지정하려면 &>를 사용하고 스트림을 제거하려면 /dev/null 을 사용하면 된다.

구체적인 예시는 아래에서 살펴보자.

```shell
curl https://example.com &> /dev/null #1
curl https://example.com > /tmp/content.txt 2> /tmp/curl-status #2
head -3 /tmp/content.txt
tr < /tmp/curl-status [A-Z] [a-z]
```

1. stdout과 stderr을 모두 /dev/null로 지정해 출력값을 버린다.
2. 출력 값과 상태 값을 다른 파일로 재지정
3. 대화식으로 값을 입력하고 파일을 저장.
4. stdin에서 값을 읽는 tr 명령을 사용해 모든 단어를 소문자로 만든다.

셸은 일반적으로 다음과 같은 여러 특수 문자를 이해한다.

* &
  * 명령 마지막에 배치되며 백그라운드에서 명령을 실행한다.
* \
  * 긴 명령의 가독성을 높이기 위해 다음 행에서 명령을 계속할 때 사용한다.
* |
  * 한 프로세스의 stdout 값을 다음 프로세스의 stdin 과 연결해 데이터를 파일에 임시로 저장하지 않고 바로 전달할 수 있다.

### 변수

셸과 관련해 자주 접하게 되는 용어가 변수다.

변수는 다음과 같은 두 가지 종류로 나뉜다.

* 환경변수: 셸 전체의 설정 .env 명령어로 목록을 나열한다.
* 셸 변수: 현재 실행 상황에서 유효하다. 배시에서 set 명령어로 목록을 나열할 수 있다. 하위 프로세스는 셸 변수를 상속하지 않는다.

배시에서 export 명령어를 사용해 환경 변수를 만들 수 있다.

변수의 값에 접근하고 싶을 때는 앞에 $를 붙이고, 변수를 제거하고 싶을 때는 unset을 사용한다.


```shell
set MY_VAR=42 #1
set | grep MY_VAR #2
# 출력 _=MY_VAR=42

export MY_GLOBAL_VAR="fun with vars" #3
set | grep 'MY_*' #4 

env | grep 'MY_*' #5

bash #6

echo $MY_GLOBAL_VAR #7

set | grep 'MY_*' # 8 
```

1. MY_VAR이라는 셸 변수를 생성하고 값을 42로 저장
2. 셸 변수를 나열하고 MY_VAR를 필터링. 환경변수로 내보내지 않았음을 나타내는 _=에 유의하자.
3. MY_GLOBAL_VAR이라는 새 환경변수를 만든다.
4. 셸 변수를 나열하고 MY_로 시작하는 모든 변수를 필터링해본다. 예상대로 이전 단계에서 만든 두 변수가 모두 펴시된다.
5. 환경 변수를 나열한다. 예상대로 MY_GLOBAL_VAR이 표시된다.
6. 새 셸 세션, 즉 MY_VAR를 상속하지 않는 현재 셀 세션의 자식 프로세스를 만든다.
7. 환경 변수 MY_GLOBAL_VAR에 접근한다.
8. 현재 자식 프로세스에 있기 때문에 셸 변수를 나열하면 MY_GLOBAL_VAR만 나온다.
9. 자식 프로세스를 종료한 후 MY_VAR 셸 변수를 제거하고 셸 변수를 나열한다. 예상대로 MY_VAR이 사라졌다.

### 종료 상태

종료 상태를 확인하려면 echo $?를 사용

종료 상태값 0은 명령이 오류 없이 성공적으로 실행됐음을 의미하는 반면 1에서 255사이의 값은 실패를 나타낸다.

### 내장 명령어

셸에는 여러 내장 명령어가 있다.

몇 가지 유용한 예로는 yes, echo, cat, read가 있다. (리눅스 배포판에 따라 이들 명령어 중 일부는 내장되어 있지 않고 /usr/bin에 위치할 수 있다.)

help 명령어를 사용하면 내장 명령어 목록을 나열 할 수 있다.

help 명령을 사용하면 내장 명령어 목록을 나열할 수 있다. 그러나 그 외 모든 것은 보통 /usr/bin이나 /usr/sbin에 있는 셸 외부 프로그램이라는 점을 기억하자.

실행 파일을 어디에서 찾을지 어떻게 얼 수 있을까? 다음과 같은 몇 가지 방법이 있다.

```shell
$ which ls

$ type ls
```

### 작업 제어

작업 제어는 대부분의 셸이 지원하는 기능.

프로세스를 백그라운드에서 시작하려면 명령 마지막에 &를 넣고, 포어그라운드 프로세스를 백그라운드로 보내려면 Ctrl+Z를 누르면 된다.

```shell
watch -n 5 "ls" & #1
jobs #2
fg #3
```

1. 명령 끝에 &를 넣으면 백그라운드에서 명령이 실행된다.
2. 모든 작업의 목록을 출력한다.
3. fg 명령을 사용하면 프로세스를 포어그라운드로 가져올 수 있다. watch 명령을 종료하려면 Ctrl+C를 사용한다.

셸을 닫은 후에도 백그라운드 프로세스를 계속 실행하려면 nohup 명령을 앞에 추가하면 된다.

또한 이미 실행중이지만 앞에 nohup이 붙지 않은 프로세스의 경우에는 이미 실행 이후라도 disown을 사용하면 동일한 효과를 얻을 수 있다.

실행중인 프로세스르 제거하려면 다양한 수준의 강제성과 함께 Kill 명령어를 사용하자,

아래는 지피티

```
nohup 명령어를 사용할 때 &를 붙이지 않으면, nohup은 프로그램을 터미널 세션과 분리시켜 터미널이 닫히거나 사용자가 로그아웃해도 프로그램이 계속 실행되게 해주지만, 그 프로세스는 바로 백그라운드로 가지 않습니다. 
즉, 프로세스는 사용자가 다음 명령어를 입력할 때까지 터미널을 차지하게 됩니다. 
이는 프로세스가 백그라운드에서 실행되고 있다는 것과는 다릅니다.

&를 사용하면, 명령어를 실행하는 즉시 터미널이 해당 프로세스에서 해제되고, 사용자는 추가적인 명령을 입력할 수 있게 됩니다. 
이는 프로세스가 백그라운드에서 실행되고 있음을 의미합니다.

결론적으로, nohup만 사용하면 프로그램은 사용자 세션이 종료된 후에도 계속 실행되지만, 
터미널 세션을 반환하지 않습니다. 프로그램을 백그라운드에서 실행하고 싶다면 nohup과 함께 &를 사용해야 합니다. 
```

작업 제어보다는 터미널 멀티플렉서를 사용하는게 좋다.


## 모던 리눅스 명령어

* ls 대신 exa로 디렉터리 내용 나열하기
* cat 대신 bat로 파일 내용 보기
* rg로 파일에서 콘텐츠 찾기
* jq로 json 데이터 처리하기

### 일반 작업

1. 자주 사용하는 명령어 단축해보기
2. 행 탐색과 조작
3. 파일 내용 관리

```shell
echo "First line" > /tmp/something #1
cat /tmp/something #2

echo "Second line" >> /tmp/something && \
 cat /tmp/something
 
sed 's/line/Line/' /tmp/something

cat << 'EOF' > /tmp/another

diff -y /tmp/something /tmp/another
```

1. echo 출력을 재지정해 파일을 출력한다.
2. 파일 내용을 확인한다.
3. >> 연산자를 사용해 파일에 한 행을 추가한 후 내용을 확인한다.
4. sed를 사용해 파일 내용을 바꾸고 stdout으로 출력한다.
5. here 문서를 사용해 파일을 생성한다.
6. 생성한 파일의 차이점을 보여준다.

### 긴 파일 보기

```shell
head -5 /tmp/longfile # 긴 파일의 다섯행을 출력
sudo tail -f /var/log/Xorg.0.log # tail을 이용해 로그 파일의 마지막을 출력한다. 여기서 -f 옵션은 따르다라는 의미로, 결과를 지속적으로 확인하거나 자동 업데이트함을 의미한다.
```

## 인간 친화적인 셸

피시셸과 Z셸 

* /.zshenv: 셸의 모든 호출에 제공된다. 여기에는 검색 경로와 기타 중요한 환경변수를 설정하는 명령이 포함돼야 한다. 하지만 출력 값을 생성하거나 셸이 tty에 연결되어있다고 가정하는 명령이 포함돼서는 안된다.
* /.zprofile: ksh 영역을 위한 .zlogin의 대안으로 사용. .zshrc 이전에 제공된다
* /.zshrc: 대화형 셸에 제공된다. 앨리어스, 함수, 옵션, 키 바인딩 등을 설정하는 명령이 포함돼야 한다.
* /.zlogin: 로그인 셸에 제공. 로그인 셸에서만 실행돼야 하는 명령이 포함돼야 한다.
* /.zlogout: 로그인 셸이 종료된느 시점에 제공