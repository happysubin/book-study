
# chapter 05. 파일시스템

리눅스는 파일 시스템이 통일된 인터페이스를 제공한다.
이 인터페이스와 리눅스가 파일을 바이트 스트림으로 취급한다는 사실이 더해져서, 구조에 대한 별다른 염려 없이 다양한 파일 유형을 지원하는 도구를 만들 수 있게 된다.

## 기본 개요

* 예외가 있긴 하지만 오늘날 많이 사용되는 대부분의 파일 시스템은 계층 구조로 되어 있다. 즉 사용자는 보통 root(/)로 시작하는 단일 파일시스템 트리를 제공받게 된다.
* 파일 시스템 트리에는 디렉터리와 파일이라는 두 가지 유형의 객체가 있다. 디렉터리는 파일을 그룹화할 수 있는 조직의 단위. 이를 트리 구조에 적용해서 비유하자면, 디렉터리는 트리의 노드고 파일이나 디렉터리가 리프가 될 수 있다.
* 디렉터리의 내용을 나열하고 해당 디렉터리로 변경하고 현재 작업 디렉터리를 출력하는 등 파일 시스템을 탐색할 수 있다.
* 권한이 내장되어 있다. 파일 시스템이 가지고 있는 속성 중 소유권이 있는데, 결과적으로, 소유권은 할당된 권한을 통해 파일과 디렉터리에 대한 접근을 제한한다.
* 일반적으로 파일 시스템은 커널에서 구현된다.

이제 필요한 용어를 정리해보자.

* 드라이브
  * HDD 또는 SSD와 같은 블록 디바이스.
  * 가상 머신의 드라이브는 에뮬레이션될 수도 있다.
  * 예를 들어 /dev/sda, /dev/sdb, /dev/hda 와 같은 식이다.
* 파티션
  * 드라이브를 스토리지 섹터의 집합인 파티션으로 논리적으로 분할할 수 있다.
  * 예를 들어 HDD에 두 개의 파티션을 생성한다면 /dev/sdb1와 /dev/sdb2로 표시되는 식이다.
* 볼륨
  * 볼륨은 파티션과 비슷하지만 더 유연하며, 특정 파일시스템용으로 포맷되기도 한다.
* 슈퍼 블록
  * 시스템이 포맷되면 파일시스템의 시작 부분에 파일 시스템의 메타데이터를 캡쳐하는 특수 섹션이 생긴다.
  * 여기에는 파일 시스템의 유형, 블록, 상태, 블록당 아이노드 수 등이 담긴다.
* 아이노드
  * 파일 시스템의 아이노드는 크기, 소유자, 위치 날짜, 권한과 같은 파일의 메타데이터를 저장하지만 파일명과 실제 데이터는 저장하지 않는다.
  * 이 데이터는 디렉터리에 보관되며, 디렉터리는 아이노드를 파일명에 매핑하는 특볋한 종류의 일반 파일이라 할 수 있다.

아래 명령어를 통해 위 에서 배운 용어들을 확인 가능하다.

의사(루프) 디바이스를 제외한 모든 블록 디바이스를 나열한다.

```shell
lsblk --exclude 7 
```

이제 파일 시스템을 살펴보자.

```shell
findmnt -D -t nosquashfs

stat .
```

| 명령어                | 사용예제                    | 
|--------------------|-------------------------|
| lsblk              | 모든 블록 디바이스 나열           |
| fdisk, parted      | 디스크 파티션 관리              |
| blkid              | UUID와 같은 블록 디바이스 속성 표시  |
| hwinfo             | 하드웨어 정보 표시              |
| file -s            | 파일시스템과 파티션 정보 표시        |
| stat, df -i, ls -i | 아이노드와 관련된 정보 표시 및 목록 출력 |

파일 시스템과 관련해 앞으로 접하게 될 또 다른 용어가 바로 링크다.

다른 이름의 파일을 참조하거나 단축어를 제공하고 싶을때가 있을 것이다.

이와 관련해 리눅스에는 두 가지 유형의 링크가 있다.

* 하드 링크: 아이노드를 참조하며 디렉토리는 참조할 수 없다. 또한 파일 시스템이 서로 다르면 동작하지 않는다.
* 심볼릭 링크: 파일의 내용이 다른 파일의 경로를 나타내는 문자열인 특수 파일

```shell
ln myfile somealias (1)
ln -s myfile someofalias (2)

ls -al *alias
stat somealias
stat someofalias
```

1. myfile에 대한 하드링크
2. 동일한파일에 대한 소프트 링크
3. 파일 목록 출력. ls -ali *alias를 사용해 하드링크와 연관된 두 이름의 아이노드가 동일하다는 것을 알 수 있다.
4. 하드링크의 파일 내역 표기
5. 소프트링킈 파일 내역 표시

## 가상 파일시스템 (VFS)

리눅스는 가상 파일 시스템이라는 추상화를 통해 다양한 종류의 리소스(인메모리, 로컬 연결, 네트워크 스토리지)에 파일과 유사한 접근을 제공할 수 있다.

기본 개념은 클라이언트(시스템 콜)와 개별 파일 시스템 사이에 간접 계층을 도입하는 것이다.
여기서 개별 파일시스템은 구체적인 디바이스 또는 다른 리소스 유형을 위한 연산을 구현한다.
즉 VFS는 일반작업을 실제 구현 세부사항과 분리한다.

VFS는 파일 체계를 기반으로 클라이언트가 동일한 방법으로 리소스에 접근할 수 있게 해주는 커널의 추상화 계층이다.
리눅스의 파일에는 규정된 구조가 없다. 그저 바이트 스트림일 뿐이다.
바이트이ㅡ 의미를 결정하는 것은 클라이언트에게 달려있다.

VFS는 다양한 종류의 파일 시스템에 대한 접근을 추상화한다.

* ext3, XFS, FAT, NTFS 같은 로컬 파일 시스템
  * 이런 파일 시스템은 드라이버를 사용해 HDD, SSD와 같은 로컬 블록 디바이스에 접근한다.
* 장기 저장 디바이스가 지원하지 않지만 RAM에 상주하는 tmpfs와 같은 인메모리 파일 시스템
* procfs와 같은 의사 파일 시스템
  * 이런 파일 시스템도 본직적으로는 인메모리. 커널 인터페이스와 디바이스 추상화에 사용
* NFS, 삼바, 넷웨어 등의 네트워크 파일 시스템
  * 이런 파일도 드라이버를 사용. 하지만 실제 데이터가 상주하는 저장 디바이스는 로컬이 아니라 원격에 저장되어 있다. 이는 드라이버에 네트워크 작업이 포함됨을 의미한다.

VFS 인터페이스를 구성하는 시스템 콜은 아래와 같다.

| 카테고리               | 사용예제                                         | 
|--------------------|----------------------------------------------|
| 아이노드               | chmod, chown, stat                           |
| 파일                 | open, close, seek, truncate, read, write     |
| 디렉터리               | chdir, getcwd, link, unlink, rename, synlink |
| 파일시스템              | mount, flush, chroot                         |
| 그 외                | mmap, poll, sync, flock                      |

리눅스 커널은 관련 VFS 데이터 구조를 다음과 같이 정의한다.

* inode: 핵심 파일 시스템 객체, 캡처 유형, 소유권, 권한, 링크, 파일 데이터를 포함하는 블록에 대한 포인터, 생성과 접근 통계 등
* file: 열려 있는 파일을 나타냄
* dentry: 부모와 자식 저장
* super_block: 마운트 정보를 포함한 파일시스템을 나타냄
* 그 외: vfsmount와 file_system_type 포함

### 논리 볼륨 관리자

파티션을 사용해 드라이브를 분할할 수 있다. 그러나 파티션은 크기 조정이 필요할 때 사용하기 어렵다.

논리 볼륨 관리자(LVM)은 파일 시스템과 물리 개체(드라이브, 파티션)간의 간접 계층을 사용한다.
이렇게 하면 리소스 폴링을 통해 위험이 없고 중단 시간도 없는 확장과 자동 스토리지 증설이 가능해진다.

![KakaoTalk_Photo_2024-04-01-21-36-19](https://github.com/happysubin/book-study/assets/76802855/982b6a7c-3aaa-4582-a74d-66ef378ac4ae)


* 물리 볼륨
  * 디스크 파티션, 전체 디스크 드라이브, 기타 디바이스 등이 있다.
* 논리 볼륨
  * 볼륨 그룹(VG)에서 생성된 블록 디바이스, 이들은 개념적으로 파티션과 비슷하다. 논리 볼륨을 사용하려면 먼저 논리 볼륨에 파일 시스템을 생성해야 한다.
  * 사용중에 논리 볼륨의 크기를 쉽게 조정할 수 있다.
* 볼륨 그룹
  * 물리 볼륨과 논리 볼륨 사이의 중개자 볼륨, 볼륨 그룹이란 공동으로 리소스를 제공하는 물리 볼륨 풀이라고 생각하면 된다.

PV 관리 도구

* lvmdiskscan
* pvdisplay
* pvcreate
* pvscan

볼륨 그룹 관리 도구

* vgs
* vgdisplay
* vgcreate
* vgextend

논리 볼륨 관리 도구

* lvs
* lvscan
* lvcreate

```shell
sudo lvscan (1)
sudo vgs (2)
sudo pvdisplay (3)
```

1. 논리 볼륨을 나열
2. 볼륨 그룹을 나열
3. 물리 볼륨을 표시

### 파일 시스템 작업

파일 시스템을 생성(다른 OS 에서는 포맷) 한 다음 이를 마운트한다.

즉 파일 시스템 트리에 삽입한다.

파일 시스템 생성은 아래와 같은 명령어를 사용

```shell
mkfs -t ext 4 \  #(1)
  /dev/some_vg/some_lv #(2)
```

1. ext4 유형의 파일 시스템을 생성한다.
2. 논리 볼륨 /dev/some_vg/some_lv에 파일 시스템을 생성한다.

다음은 마운드 명령이다.

```shell
mount -t ext4,tmpfs (1)
```

1. 마운트목록을 출력하지만 특정 파일 시스템 유형만 표시한다.

이때 생성된 파일 시스템 유형으로 마운트됐는지를 반드시 확인해야 한다.
예를 들어 mount -t vfat /dev/sdX2 /media를 사용해 SD 카드를 마운트하려는 경우 해당 SD 카드가 vfat로 포맷됐는지 여부를 알아야 한다.

-a 옵션을 통해 마운트가 작동할 때까지 모든 파일 시스템을 시도하는 것도 가능하다.
또한 마운트는 시스템이 실행되는 동안만 유효하므로 영구적으로 유지하려면 fstab 파일을 사용해야 한다. 

### 범용 파일 시스템 레이아웃

프로그램이 저장된 위치, 구성 데이터 ,시스템 데이터, 사용자 데이터와 같은 항목을 구조화할 수 있는데,
이런 디렉터리의 구성과 그 내용을 __파일시스템 레이아웃__ 이라고 한다.

공식적으로 이런 레이아웃은 파일 시스템 계층 구조 표준(FHS) 라고 한다.

구체적인 설정을 알아보려면 man hier 명령을 사용하는 것이 좋다.

| 디렉터리       | 의미                                               | 
|------------|--------------------------------------------------|
| bin, sbin  | 시스템 프로그램과 명령(일반적으로 /usr/bin과 /usr/sbin에 링크되어 있다. |
| boot       | 커널 이미지와 관련 구성요소                                  |
| dev        | 디바이스(터미널, 드라이브 등)                                |
| etc        | 시스템 구성 파일                                        |
| home       | 사용자 홈 디렉터리                                       |
| lib        | 공유 시스템 라이브러리                                     |
| mnt, media | 이동식 미디어용 마운트 지점(ex: USB 스틱)                      |
| opt        | 배포판 지정 디렉터리. 패키지 관리자 파일을 호스팅                     |
| proc, sys  | 커널 인터페이스                                         |
| tmp        | 임시 파일용                                           |
| usr        | 사용자 프로그램(일반적으로 읽기 전용)                            |
| var        | 사용자 프로그램(로그, 백업, 네트워크 캐시 등)                      |


## 의사파일시스템

의사 파일 시스템은 파일시스템인 것처럼 가장하여 일반적인 방식(ls, cd, cat)으로 상호 작용할 수 있지만, 실제로는 커널 인터페이스를 래핑한 것이다.

여기서 인터페이스란 다음과 같이 다양한 범위에 이른다.

* 프로세스에 대한 정보
* 키보드 같은 디바이스와의 상호 작용
* 데이터 소스나 싱크로 사용할 수 있는 특수 디바이스 같은 유틸리티

이제 리눅스의 세 가지 주요 의사 파일 시스템을 가장 오래된 것부터 순서대로 자세히 살펴보자.

### procfs

리눅스는 유닉스로부터 파일 시스템을 물려 받았다.
원래 의도는 커널에서 프로세스 관련 정보를 발행하여 ps나 free 같은 시스템 명령에 사용할 수 있게 하는 것이다.

이는 구조에 대한 규칙이 거의 없고 읽기-쓰기 접근이 허용되며 시간이 지나면서 많은 정보가 procfs에 편입됐다.
일반적으로는 여기서 다음과 같은 두 가지 유형의 정보를 찾을 수 있다.

* /proc/PID/의 프로세스별 정보, 이는 커널에 디렉터리를 통해 제공하는 프로세스 관련 정보로, PID를 디렉터리 이름으로 사용한다.
* 마운트, 네트워크 관련 정보, TTY 드라이버, 메모리 정보, 시스템 버전, 가동 시간과 같은 기타 정보

cat 등의 명령을 사용하면 아래 표에 나열된 프로세스별 정보를 간단히 수집할 수 있다.
대부분은 읽기 전용이며, 쓰기의 의미는 원래 리소스에 따라 달라진다.

| 항목      | 유형   | 정보           |
|---------|------|--------------|
| attr    | 디렉터리 | 보안속성         |
| cgroup  | 파일   | 제어 그룹        |
| cmdline | 파일   | 커맨드라인        |
| cwd     | 링크   | 현재 작업 디렉터리   |
| environ | 파일   | 환경변수         |
| exe     | 링크   | 프로세스 실행 파일   |
| fd      | 디렉터리 | 파일 디스크립터     |
| io      | 파일   | 스토리지 (I/O)   |
| limits  | 파일   | 리소스 한계       |
| mem     | 파일   | 사용된 메모리      |
| mounts  | 파일   | 사용된 마운트      |
| net     | 디렉터리 | 네트워크 통계      |
| stat    | 파일   | 프로세스 상태      |
| syscall | 파일   | 시스템 콜 사용량    |
| task    | 디렉터리 | 작업별(스레드별) 정보 |
| timers  | 파일   | 타이머 정보       |

```shell
cat /proc/self/status | head -10

cat /proc/self/net/arp
```

### sysfs

procfs가 꽤 거친 반면, /sys 파일시스템은 커널이 표준화된 레이아웃을 사용하여 선택한 정보를 노출하는 리눅스 고유의 구조화된 방법이다.

다음은 sysfs의 디렉터리다.

* block/: 발견된 블록 디바이스의 심볼릭 링크
* bus/: 커널에서 지원하는 각 물리 버스 유형마다 한 개씩 하위 디렉터리가 있다.
* class/: 이 디렉터리에는 디바이스 클래스가 포함되어 있다.
* dev/: 이 디렉터리에는 두 개의 하위 디렉터리가 포함되어 있다. 블록 디바이스용 block/과 시스템의 문자 디바이스용 char/이며, 이는 major-ID:minor-ID로 구성된다.
* devices/: 커널은 디바이스를 트리 형태로 표현한 정보를 제공한다.
* firmware/: 이 디렉터리를 통해 펌웨어 관련 속성을 관리할 수 있다.
* fs/: 이 디렉터리에는 일부 파일시스템의 하위 디렉터리가 포함되어 있다.
* module/: 이 디렉터리에서 커널에 로드된 각 모듈의 하위 디렉터리를 찾을 수 있다.

```shell
ls -al /sys/block/sda/ | head -7
```

### devfs

/dev 파일시스템은 물리적 디바이스에서부터 난수 생성기나 쓰기 전용 데이터 싱크에 이르기까지 모든 디바이스를 나타내는 디바이스 특수 파일을 호스팅한다.

devfs를 통해 사용 가능하고 관리되는 디바이스는 다음과 같다.

* 블록 디바이스 (ex: 드라이브) 같은 블록의 데이터 처리
* 문자 디바이스 (ex: 터미널, 키보드, 마우스) 이런 디바이스를 문자 단위로 처리
* 특수 디바이스 (ex: /dev/null, /dev/random) 데이터를 생성하고 조작

아래는 임의의 문자열을 얻는 명령어

```shell
tr -dc A-Za-z0-9 < /dev/urandom | head -c 42

echo "something" > devtty
```

## 일반파일

일반 파일 예시 (오피스 문서, YAML, 이미지, 소스코드, 일반 텍스트 파일)

### 범용 파일 시스템

* ext4
  * 제일 많이 사용하는 파일 시스템
  * ext3과 호환되는 진화 버전
  * 저널링 기능 제공. 즉 변경 사항이 로그에 기록되어 최악의 경우가 닥쳤을 때 복구가 빠르다.
* XFS
  * 1990년대 초 실리콘 그래픽스가 워크스테이션용으로 설계한 저널링 파일 시스템
  * 대용량 파일과 고속 I/O를 지원. 현재는 레드햇 배포판 제품군 같은데서 사용
* ZFS
  * 초기 ZFS는 파일시스템과 볼륨 관리자 기능을 결합
  * 지금은 OpenZFS 프로젝트가 오픈 소스 영역에서 나아갈 길을 제시하고 있지만, ZFS와 리눅스의 통합에는 우려가 있다.
* FAT
  * 실제 리눅스용 FAT 파일 시스템 제품군으로, 그중에서도 vfat가 가장 자주 사용된다.
  * 주요 사용 사례는 FAT를 사용하는 이동식 미디어뿐만 아니라 윈도우 시스템과의 상호 운용성을 목적으로 한다.
  * 불륨에 대해 네이티브 고려사항이 그다지 적용되지 않았다.

### 인메모리 파일 시스템
* 
* debugfs
* loopfs
* pipefs
* sockfs
* swapfs
* tmpfs

### 쓰기 시 복사(Cow)

쓰기 시 복사는 I/O 속도를 높이는 동시에 공간은 적게 사용하는 개념이다.

![KakaoTalk_Photo_2024-04-02-21-45-54](https://github.com/happysubin/book-study/assets/76802855/132dbc91-45ef-4a37-8da2-8ef767afee83)

1. 블록 A, B, C로 이루어진 워본 파일인 파일 1을 파일 2에 복사한다. 실제 블록을 복사하는 대신 메타데이터만 복사한다. 메타데이터만 생성되기 때문에 속도가 빠르며 공간도 많이 차지하지 않는다.
2. 파일 2가 수정되면 C블록만 복사된다. C라는 새 블록이 생성되지만 파일 2는 여전히 수정되지 않은 블록 A와 B를 가리키고 있으며, 이제 새 블록을 사용해 새 데이터를 캡쳐한다.

구현 내용을 다루기 전에 먼저 이 내용과 관련된 두 번째 개념인 유니온 마운트를 이해해야 한다.

이는 여러 디렉터리를 하나의 위치로 결합해서, 
해당 디렉터리에 모든 참여 디렉터리가 결합된 내용이 포함된 것처럼 결과 디렉터리의 사용자에게 보이게 할 수 있다는 개념이다.

유니온 마운트를 사용하다 보면 마운트의 계층화 순서를 암시하는 상위 파일시스템과 하위 파일시스템이라는 용어를 자주 접하게 된다.
