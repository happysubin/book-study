
# chapter 05. 파일시스템

리눅스는 파일 시스템이 통일된 인터페이스를 제공한다.
이 인터페이스와 리눅스가 파일을 바이트 스트림으로 취급한다는 사실이 더해져서, 구조에 대한 별다른 염려 없이 다양한 파일 유형을 지원하는 도구를 만들 수 있게 된다.

## 기본 개요

* 예외가 있긴 하지만 오늘날 많이 사용되는 대부분의 파일 시스템은 계층 구조로 되어 있다. 즉 사용자는 보통 root(/)로 시작하는 단일 파일시스템 트리를 제공받게 된다.
* 파일 시스템 트리에는 디렉터리와 파일이라는 두 가지 유형의 객체가 있다. 디렉터리는 파일을 그룹화할 수 있는 조직의 단위. 이를 트리 구조에 적용해서 비유하자면, 디렉터리는 트리의 노드고 파일이나 디렉터리가 리프가 될 수 있다.
* 디렉터리의 내용을 나열하고 해당 디렉터리로 변경하고 현재 작업 디렉터리를 출력하는 등 파일 시스템을 탐색할 수 있다.
* 권한이 내장되어 있다. 파일 시스템이 가지고 있는 속성 중 소유권이 있는데, 결과적으로, 소유권은 할당된 권한을 통해 파일과 디렉터리에 대한 접근을 제한한다.
* 일반적으로 파일 시스템은 커널에서 구현된다.

이제 필요한 용어를 정리해보자.

* 드라이브
  * HDD 또는 SSD와 같은 블록 디바이스.
  * 가상 머신의 드라이브는 에뮬레이션될 수도 있다.
  * 예를 들어 /dev/sda, /dev/sdb, /dev/hda 와 같은 식이다.
* 파티션
  * 드라이브를 스토리지 섹터의 집합인 파티션으로 논리적으로 분할할 수 있다.
  * 예를 들어 HDD에 두 개의 파티션을 생성한다면 /dev/sdb1와 /dev/sdb2로 표시되는 식이다.
* 볼륨
  * 볼륨은 파티션과 비슷하지만 더 유연하며, 특정 파일시스템용으로 포맷되기도 한다.
* 슈퍼 블록
  * 시스템이 포맷되면 파일시스템의 시작 부분에 파일 시스템의 메타데이터를 캡쳐하는 특수 섹션이 생긴다.
  * 여기에는 파일 시스템의 유형, 블록, 상태, 블록당 아이노드 수 등이 담긴다.
* 아이노드
  * 파일 시스템의 아이노드는 크기, 소유자, 위치 날짜, 권한과 같은 파일의 메타데이터를 저장하지만 파일명과 실제 데이터는 저장하지 않는다.
  * 이 데이터는 디렉터리에 보관되며, 디렉터리는 아이노드를 파일명에 매핑하는 특볋한 종류의 일반 파일이라 할 수 있다.

아래 명령어를 통해 위 에서 배운 용어들을 확인 가능하다.

의사(루프) 디바이스를 제외한 모든 블록 디바이스를 나열한다.

```shell
lsblk --exclude 7 
```

이제 파일 시스템을 살펴보자.

```shell
findmnt -D -t nosquashfs

stat .
```

| 명령어                | 사용예제                    | 
|--------------------|-------------------------|
| lsblk              | 모든 블록 디바이스 나열           |
| fdisk, parted      | 디스크 파티션 관리              |
| blkid              | UUID와 같은 블록 디바이스 속성 표시  |
| hwinfo             | 하드웨어 정보 표시              |
| file -s            | 파일시스템과 파티션 정보 표시        |
| stat, df -i, ls -i | 아이노드와 관련된 정보 표시 및 목록 출력 |

파일 시스템과 관련해 앞으로 접하게 될 또 다른 용어가 바로 링크다.

다른 이름의 파일을 참조하거나 단축어를 제공하고 싶을때가 있을 것이다.

이와 관련해 리눅스에는 두 가지 유형의 링크가 있다.

* 하드 링크: 아이노드를 참조하며 디렉토리는 참조할 수 없다. 또한 파일 시스템이 서로 다르면 동작하지 않는다.
* 심볼릭 링크: 파일의 내용이 다른 파일의 경로를 나타내는 문자열인 특수 파일

```shell
ln myfile somealias (1)
ln -s myfile someofalias (2)

ls -al *alias
stat somealias
stat someofalias
```

1. myfile에 대한 하드링크
2. 동일한파일에 대한 소프트 링크
3. 파일 목록 출력. ls -ali *alias를 사용해 하드링크와 연관된 두 이름의 아이노드가 동일하다는 것을 알 수 있다.
4. 하드링크의 파일 내역 표기
5. 소프트링킈 파일 내역 표시

## 가상 파일시스템 (VFS)

리눅스는 가상 파일 시스템이라는 추상화를 통해 다양한 종류의 리소스(인메모리, 로컬 연결, 네트워크 스토리지)에 파일과 유사한 접근을 제공할 수 있다.

기본 개념은 클라이언트(시스템 콜)와 개별 파일 시스템 사이에 간접 계층을 도입하는 것이다.
여기서 개별 파일시스템은 구체적인 디바이스 또는 다른 리소스 유형을 위한 연산을 구현한다.
즉 VFS는 일반작업을 실제 구현 세부사항과 분리한다.

VFS는 파일 체계를 기반으로 클라이언트가 동일한 방법으로 리소스에 접근할 수 있게 해주는 커널의 추상화 계층이다.
리눅스의 파일에는 규정된 구조가 없다. 그저 바이트 스트림일 뿐이다.
바이트이ㅡ 의미를 결정하는 것은 클라이언트에게 달려있다.

VFS는 다양한 종류의 파일 시스템에 대한 접근을 추상화한다.

* ext3, XFS, FAT, NTFS 같은 로컬 파일 시스템
  * 이런 파일 시스템은 드라이버를 사용해 HDD, SSD와 같은 로컬 블록 디바이스에 접근한다.
* 장기 저장 디바이스가 지원하지 않지만 RAM에 상주하는 tmpfs와 같은 인메모리 파일 시스템
* procfs와 같은 의사 파일 시스템
  * 이런 파일 시스템도 본직적으로는 인메모리. 커널 인터페이스와 디바이스 추상화에 사용
* NFS, 삼바, 넷웨어 등의 네트워크 파일 시스템
  * 이런 파일도 드라이버를 사용. 하지만 실제 데이터가 상주하는 저장 디바이스는 로컬이 아니라 원격에 저장되어 있다. 이는 드라이버에 네트워크 작업이 포함됨을 의미한다.

VFS 인터페이스를 구성하는 시스템 콜은 아래와 같다.

| 카테고리               | 사용예제                                         | 
|--------------------|----------------------------------------------|
| 아이노드               | chmod, chown, stat                           |
| 파일                 | open, close, seek, truncate, read, write     |
| 디렉터리               | chdir, getcwd, link, unlink, rename, synlink |
| 파일시스템              | mount, flush, chroot                         |
| 그 외                | mmap, poll, sync, flock                      |

리눅스 커널은 관련 VFS 데이터 구조를 다음과 같이 정의한다.

* inode: 핵심 파일 시스템 객체, 캡처 유형, 소유권, 권한, 링크, 파일 데이터를 포함하는 블록에 대한 포인터, 생성과 접근 통계 등
* file: 열려 있는 파일을 나타냄
* dentry: 부모와 자식 저장
* super_block: 마운트 정보를 포함한 파일시스템을 나타냄
* 그 외: vfsmount와 file_system_type 포함

### 논리 볼륨 관리자

파티션을 사용해 드라이브를 분할할 수 있다. 그러나 파티션은 크기 조정이 필요할 때 사용하기 어렵다.

논리 볼륨 관리자(LVM)은 파일 시스템과 물리 개체(드라이브, 파티션)간의 간접 계층을 사용한다.
이렇게 하면 리소스 폴링을 통해 위험이 없고 중단 시간도 없는 확장과 자동 스토리지 증설이 가능해진다.

![KakaoTalk_Photo_2024-04-01-21-36-19](https://github.com/happysubin/book-study/assets/76802855/982b6a7c-3aaa-4582-a74d-66ef378ac4ae)


* 물리 볼륨
  * 디스크 파티션, 전체 디스크 드라이브, 기타 디바이스 등이 있다.
* 논리 볼륨
  * 볼륨 그룹(VG)에서 생성된 블록 디바이스, 이들은 개념적으로 파티션과 비슷하다. 논리 볼륨을 사용하려면 먼저 논리 볼륨에 파일 시스템을 생성해야 한다.
  * 사용중에 논리 볼륨의 크기를 쉽게 조정할 수 있다.
* 볼륨 그룹
  * 물리 볼륨과 논리 볼륨 사이의 중개자 볼륨, 볼륨 그룹이란 공동으로 리소스를 제공하는 물리 볼륨 풀이라고 생각하면 된다.

PV 관리 도구

* lvmdiskscan
* pvdisplay
* pvcreate
* pvscan

볼륨 그룹 관리 도구

* vgs
* vgdisplay
* vgcreate
* vgextend

논리 볼륨 관리 도구

* lvs
* lvscan
* lvcreate

```shell
sudo lvscan (1)
sudo vgs (2)
sudo pvdisplay (3)
```

1. 논리 볼륨을 나열
2. 볼륨 그룹을 나열
3. 물리 볼륨을 표시

### 파일 시스템 작업

파일 시스템을 생성(다른 OS 에서는 포맷) 한 다음 이를 마운트한다.

즉 파일 시스템 트리에 삽입한다.

파일 시스템 생성은 아래와 같은 명령어를 사용

```shell
mkfs -t ext 4 \  #(1)
  /dev/some_vg/some_lv #(2)
```

1. ext4 유형의 파일 시스템을 생성한다.
2. 논리 볼륨 /dev/some_vg/some_lv에 파일 시스템을 생성한다.

다음은 마운드 명령이다.

```shell
mount -t ext4,tmpfs (1)
```

1. 마운트목록을 출력하지만 특정 파일 시스템 유형만 표시한다.

이때 생성된 파일 시스템 유형으로 마운트됐는지를 반드시 확인해야 한다.
예를 들어 mount -t vfat /dev/sdX2 /media를 사용해 SD 카드를 마운트하려는 경우 해당 SD 카드가 vfat로 포맷됐는지 여부를 알아야 한다.

-a 옵션을 통해 마운트가 작동할 때까지 모든 파일 시스템을 시도하는 것도 가능하다.
또한 마운트는 시스템이 실행되는 동안만 유효하므로 영구적으로 유지하려면 fstab 파일을 사용해야 한다. 

## 의사파일시스템


## 일반파일

