
# 2장. 리눅스 커널

운영체제의 주요 기능이 다양한 하드웨어를 추상화하고 API를 제공한다.

## 리눅스 아키텍쳐

각 항목을 그룹화할 수 있는 3가지 개별 계층이 있다.

* 하드웨어 계층
* 커널 계층
* 사용자 영역 계층: shell, GUI 포함

커널과 사용자 영역 사이에는 시스템 콜이라는 인터페이스가 있다. 

셸, grep, find, ping 같은 유틸리티처럼 일반적으로 리눅스 OS의 일부로 여기는 많은 것이 실제로는 커널의 일부가 아니라 사용자 영역의 일부.

사용자 영역이라는 주제에 관련해서는 사용자 모드와 커널 모드를 비교하는 이야기를 자주 듣는다.
이는 실질적으로 하드웨어로의 접근 권한이 얼마나 있고 사용 가능한 추상화가 얼마나 제한됐는지를 나타낸다.

* 커널 모드는 추상화를 제한함으로써 빠르게 실행
* 사용자 모드는 상대적으로 느리지만 더 안전하고 편리한 추상화를 의미

## CPU 아키텍쳐

* x86 아키텍쳐: 인텔에서 개발했고 amd에도 라이선스된 명령어 세트 제품군이다. 인텔 32비트를 의미. 널리 사용되지만 에너지 사용이 비효율적
* x64 아키텍쳐: 인텔 64비트 프로세서를 나타낸다.
* amd 64 아키텍쳐: AMD 64비트 프로세서를 말한다.
* ARM 아키텍쳐: RISC 아키텍쳐 제품군. RISC는 일반적으로 더 빠르게 실행할 수 있는 작은 명령어 세트와 많은 일반 CPU 레지스터로 구성된다. x86 칩보다 빠르고 저렴하며 발열량이적다. 
  * ARM 기반 CPU가 점점 발전
* RISC-V: 새롭게 떠오르는 선수 RICS-v 리스크 파이브라고 읽음. 

## 커널 구성요소

리눅스 커널은 모놀리식 커널이지만, 코드베이스에는 특정 역할을 식별하고 부여할 수 있는 기능 영역이 나뉘어 있다.

커널 코드 베이스에서 찾을 수 있는 주요 기능 블록은 다음과 같다.

* 프로세스 관리
* 메모리 관리
* 네트워킹
* 파일시스템
* 캐릭터 디바이스와 디바이스 드라이버 관리

이런 기능 구성 요소는 상호 의존성이 있을 때가 많아서 커널의 개발자 모토인 '커널은 사용자 영역을 손상시키지 않는다'를 실제로 확실히 지키면서 작업하기는 정말 어렵다.

### 프로세스 관리

커널에는 프로세스 관리와 관련된 부분이 많다. 그중 일부는 인터럽트 같은 CPU 아키텍쳐 관련 사항을 처리하고, 다른 부분은 프로그램 실행과 스케줄링에 중점을 둔다.

일반적으로 프로세스는 실행 가능한 프로그램을 기반으로 하며, 사용자가 대면하는 유닛이다.
반면에 스레드는 프로세스 컨텍스트상에서의 실행 유닛을 말한다. 
프로세스에는 여러 실행 유닛이 병렬로 실행되며 이는 잠재적으로 각기 다른 CPU에서 실행될 수 있다.

아래는 리눅스에서 가장 큰 단위부터 가장 작은 단위까지다.

* 세션: 하나 이상의 프로세스 그룹을 포함하고 선택적으로 tty가 연결된 상위 수준의 사용자 대면 유닛을 나타낸다. 커널은 세션 ID(SID)라는 번호를 통해 세션을 식별한다.
* 프로세스 그룹: 하나 이상의 프로세스가 포함도ㅙ 있으며, 한 세션에는 포그라운드 프로세스 그룹이 둘 이상일 수 없다. 커널은 PGID라는 숫자를 통해 프로세스 그룹을 식별한다.
* 프로세스: 여러 리소스를 그룹으로 추상화한 것이며, 커널은 /proc/self를 통해 현재 프로세스를 사용자에게 노출한다. PID로 식별
* 스레드: 커널에 의해 프로세스로 구현된 유닛을 말한다. TID, TGID를 통해 스레드를 식별하며, 공유된 TGID 값은 멀티스레드 프로세스를 의미.
* 태스크: 커널에는 sched.h에 정의된 task_struct라는 데이터 구조가 있으며, 이는 프로세스와 스레드 구현의 기반을 형성한다. 커널 외부로 노출 X

아래 명령어로 PID, PGID, SID, TTY 확인 가능

```
ps -j
```

### 메모리 관리

가상 메모리는 시스템이 물리적으로 갖고 있는 것보다 더 많은 메모리를 갖고 있는 것처럼 보이게 한다.
사실 모든 프로세스는 많은 가상 메모리를 얻는다.

가상 메모리의 동작 방식은 다음과 같다

1. 물리 메모리와 가상 메모리는 모두 __페이지__ 라고 부르는 고정 길이의 청크로 나뉜다.
2. 페이지 테이블 프로세스의 가상 페이지를 주 메모리의 물리적 페이지에 매핑한다.
3. 각 프로세스 수준의 페이지 테이블을 통해 여러 가상 페이지가 동일한 물리적 페이지를 가리킬 수 있다.
4. 기존 공간을 최적으로 사용하면서 각 프로세스에 그들의 페이지가 실제로 RAM에 존재한다는 환상을 효과적으로 일으키는 방법

CPU가 프로세스의 가상 페이지에 접근할 때마다 원칙적으로 CPU는 프로세스가 사용하는 가상 주소를 이에 해당하는 물리적 주소로 변환해야 한다.
이 프로세스의 속도를 높이기 위해 최신 CPU 아키텍쳐는 TLB라는 조회용 on-chip을 지원한다.

TLB는 매우 작은 캐시로, 누락된 경우 CPU가 프로세스 페이지 테이블을 통해 페이지의 물리적 주소를 계산하고 TLB를 업데이트한다.

전통적으로 리눅스의 기본 페이지 크기는 4KB였으나 커널 버전 v2.6.3 부터는 최신 아키텍쳐와 워크로드를 더 잘 처리하도록 대형 페이지를 지원한다.

### 네트워킹

* 소켓: 추상화 커뮤니케이션을 위해 필요
* 전송 제어 프로토콜: TCP 및 사용 자 데이터그램 프로토콜 UDP
* 인터넷 프로토콜 IP

이와 같은 세 가지 작업은 커널이 처리하는 모든 것이다.
HTTP나 SSH 같은 애플리케이션 프로토콜은 주로 사용자 영역에서 구현된다.

아래 명령어를 통해 네트워크 인터페이스 개요를 확인할 수 있다.

```
ip link
```

ip route는 라우팅 정보도 제공한다. 

### 파일 시스템

리눅스는 파일 시스템을 사용해 HDD, SSD 플레시 메모리 같은 저장 디바이스의 파일과 디렉토리를 구성한다.
ext4, btrfs, ntfs 같은 다양한 유형의 파일 시스템이 있으며 동일한 파일 시스템의 인스턴스도 여러 개 사용할 수 있다.

VFS은 원래 여러 파일 시스템 유형과 인스턴스를 지원하기 위해 도입됐다.
VFS의 최상위 계층은 열기, 닫기, 읽기, 쓰기 기능 등 공통 API의 추상화를 제공하며, VFS의 최하위 계층은 주어진 파일 시스템에 대한 __플러그인__ 이라고 불리는 파일 시스템 추상화다.

### 디바이스 드라이버

드라이버는 커널에서 실행되는 코드다.

그 역할은 키보드, 마우스 같은 하드웨어 디바이스나 /dev/pts/ 아래의 의사 터미널 같은 의사 디바이스를 관리하는 것이다.

또 다른 흥미로운 하드웨어 클래스는 그래픽 장치(GPU)로 전통적으로 그래픽 출력을 가속화하고 CPU의 부하를 완화할 때 사용됐다.

리눅스 시스템 디바이스의 개요를 보려면 아래 명령을 사용한다.

```
ls -al /sys/devices
```

아래 명령어로 마운트된 디바이스를 나열할 수 있다.

```
mount
```

### 시스템 콜

커널이 노출하는 서비스 인터페이스와 해당 사용자 영역의 엔티티 호출은 시스템 호출의 모음이라 하며, 시스템 콜이라 부른다.

리눅스에는 수백 개의 시스템 콜이 있다. CPU 제품 군에 따라 다르지만 약 300개 이상이다.
하지만 우리 프로그램은 일반적으로 이런 시스템 콜을 직접 호출하지 않고 C 표준 라이브러리라고 부르는 것을 통해 호출한다.

아래 명령어를 통해 현재 사용중인 커널 버전을 알 수 있다.

```
uname -srm
```

### 모듈

모듈은 요청 시 커널에 로드할 수 있는 프로그램이다.
즉 커널을 다시 컴파일하거나 시스템을 재부팅할 필요가 없다.

최근의 리눅스는 대부분의 하드웨어를 자동으로 감지해 해당 모듈을 자동으로 로드한다.

아래 명령어를 실행하면 사용자 모듈을 나용할 수 있다.

```
find /lib/modules/$(uname -r) -type f -name '*.ko'
```

실제 로드한 모듈은 아래 명령어를 통해 확인할 수 있다.

```
lsmod
```

### 커널을 확장하는 현대적인 방법: eBPF

커널 기능을 확장하는 방법으로 인기를 끌고 있는 기술은 eBPF이다.

원래 BPF(Berkeley Packet Filter)로 불렸으며, 최근의 커널 프로젝트의 기술은 일반적으로 eBPF로 알려져있다.

eBPF는 bpf 시스템 콜을 사용해 리눅스 커널 기능을 안전하고 효율적으로 확장한다.
eBPF는 맞춤형 64비트 RISC 명령어 세트를 사용한 커널 내 가상 머신으로 구현됐다.

eBPF는 이미 여러 곳에서 다음과 같은 사례에 사용되고 있다.

* 쿠버네티스에서 포드 네트워킹을 활성하기 위한 CNI 플러그인
  * ex 실리움, 프로젝트 칼리코
* 관측 가능성용
  * iovisor 같은 리눅스 커널 추적과 허블을 사용한 클러스터 설정의 경우를 위해 사용
* 보안 제어 역할
  * CNCF 팔코 와 같은 프로젝트에서 활용하듯이 컨테이너 런타임 스캔을 수행
* 네트워크 로드밸런싱용
  * 페이스북의 L4 카트란 라이브러리에서 활용

