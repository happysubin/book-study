
# chapter 06. 애플리케이션, 패키지 관리, 컨테이너

애플리케이션은 __프로그램, 바이너리, 실행 파일__ 과 동일한 의미로 사용될 때가 많다.

리눅스가 시작되고 우리가 의존하는 모든 서비스를 제공하는 방식은 __부팅 프로세스__ 라고 부른다.
init 시스템, 특히 사실상의 표준인 systemd 생태계에 대해 살펴보자.

## 기본 개요

프로그램 

* 일반적으로 리눅스가 메모리에 로드하고 실행할 수 있는 바이너리 파일 혹은 셸 스크립트를 일컫는다.
* 이 엔티티를  부르는 또 다른 이름은 __실행 파일__ 이다.
* 실행 파일의 유형에 따라 그 실행을 정확히 무엇이 관리하는지가 결정된다.
* 예를 들어 셸 스크립트는 셸이 해석하고 실행한다.

프로세스

* 프로그램 기반의 실행 엔티티이며 슬립 상태가 아닌 한 메인 메모리에 로드되어 CPU나 I/O를 사용한다.

데몬

* __데몬 프로세스__ 의 줄임말로 __서비스__ 라고도 하며 다른 프로세스에 특정 기능을 제공하는 백그라운드 프로세스다.
* 예를 들어 프린터 데몬을 사용하면 인쇄가 가능해진다.
* 그 밖에도 웹 서비스, 로깅, 시간 등 매일 사용하는 유틸리티를 위한 온갖 데몬이 있다.

애플리케이션 

* 종속성을 포함한 프로그램, 사용자 인터페이스를 포함한 실질적인 프로그램이다.
* 일반적으로는 검색 부터 업그레이드를 위한 설치, 제거에 이르기까지, 프로그램의 전체 수명주기, 구성, 데이터와 연관해 애플리케이션이라는 용어를 사용한다.

패키지

* 프로그램과 구성을 포함한 파일을 말한다. 소프트웨어 애플리케이션을 배포하는데 사용된다.

패키지 관리자

* 패키지 입력 값으로 받아 해당 콘텐츠의 사용자 지침에 따라 리눅스 환경에서 패키지를 설치, 업그레이드, 제거하는 프로그램이다.

공급망

* 패키지를 기반으로 사용자가 애플리케이션을 찾고 사용할 수 있는 소프트웨어 생산자와 배포자의 모음을 뜻한다.

부팅

* 리눅스를 사용할 수 있는 상태로 만드는 것을 목표로 하드웨어와 운영체제를 초기화하는 리눅스의 시작 시퀀스를 의미한다.
* 여기에는 커널 로딩과 서비스(또는 데몬) 프로그램 시작도 포함된다.

## 리눅스 시작 프로세스

리눅스 부트 프로세스는 하드웨어와 커널이 함께 작동하는 여러 단계에 걸친 작업이다.

1. 전원 시작
2. UEFI나 BIOS (하드웨어)
3. 부트로더 (하드웨어)
4. 커널 (커널 공간)
5. init (사용자 공간)
6. 그 밖의 사용자 공간 (사용자 공간)


1번: 모던 환경에서 통일 확장 펌웨어 인터페이스 사양은 부팅 구성과 부팅 로더를 정의한다. 
이전 시스템에서는 이 단계에서 시동 자체 시험가 완료되면 기본 I/O 시스템이 하드웨어를 초기하고 부트 로더에 제어 권을 넘겨준다.

2번: 부트 로더의 목표는 커널을 부트스트랩하는 것이다. 부팅 매체에 따라 세부 사항은 약간 다르며 부트 로더의 옵션은 다양하고 현재 버전과 예전 레거시 모두 사용 가능하다.

3번: 커널을 일반적으로 압축된 형태로 /boot 디렉토리에 위치해 있다. 따라서 첫 번째 단계는 커널을 추출해 메인 메모리에 로드하는 것이다. 하위 시스템, 파일 시스템, 드라이버를 초기화하고 나면 커널은 init 시스템에 제어권을 넘기고 이로써 부팅 프로세스는 적절하게 종료한다.

4번: init 시스템은 시스템 전반에 걸쳐 데몬을 실행할 책임이 있다. 이 init 프로세스는 프로세스 계층 구조의 루트이며 프로세스 ID 값은 1을 가진다. 
즉 PID 1 프로세스는 시스템 전원을 끌 때까지 실행된다. 다른 데몬 실행을 담당하는 것 외에도 PID 1 프로세스는 전통적으로 고아 프로세스도 처리한다.

5번: 일반적으로 이 이후에 환경에 따라 또 다른 사용자 공간 수준의 초기화가 진행된다.
* 일반적으로는 터미널, 환경, 셸 초기화가 일어난다.
* 사용자 설정과 구성을 고려해 GUI가 있는 데스크톱 환경용 디스플레이 관리자, 그래픽 서버 등이 시작된다.

이제는 현재 거의 모든 리눅스 배포판에서 사용하는 init 시스템, systemd에 대해 알아보자.

## systemd

systemd는 처음에 initd를 대체하는 init 시스템이었지만 최근에는 로깅, 네트워크 구성, 네트워크 시간 동기화의 같은 기능을 포함하는 강력한 관리자다.
이는 데몬과 해당 종속성을 정의하는 유연하고 이식 가능한 방법은 물론이고 구성을 제어하는 통일된 인터페이스도 제공한다.

systemd는 다음을 통해 이전 init 시스템의 단점을 해결한다.

* 여러 배포판에서 리눅스의 시작을 관리할 수 있는 통일된 방법 제공
* 빠르고 이해하기 쉬운 서비스 구성 구현
* 모니터링, 리소스 사용 제어(cgroup), 내장된 감사(audit) 기능을 포함한 최신 제품군 제공

또한 init는 초기화 때 순서대로(즉 영숫자 순서로) 서비스를 시작하는 반면 systemd는 어느 서비스는 종속성만 충족되면 시작할 수 있으므로 시작 시간을 단축할 수 있는 잠재력이 있다.
무엇을 언제 어떻게 실행할지 systemd에 지시하는 방법은 유닛을 통해 이뤄진다.

### 유닛

systemd의 유닛은 기능 및 대상 리소스에 따라 의미 체계가 다른 논리 그룹이다.
systemd는 대상 리소스에 따라 여러 유닛을 구분한다.

* service 유닛 - 서비스나 애플리케이션을 관리하는 방법 설명
* target 유닛 - 종속성 캡쳐
* mount 유닛 - 마운트 지점 정의
* timer 유닛 - 크론 작업 등에 대한 타이머 정의

이보다 중요도가 조금 낮은 유닛은 아래와 같다.

* socket: 네트워크나 IPC 소켓을 설명
* device: udev나 sysfs 파일 시스템용
* automount: 자동 마운트 지점 구성
* swap: 스왑 공간 설명
* path: 경로 기반 활성화용
* snapshot: 변경사항이 일어난 후 시스템의 현재 상태를 재구성할 수 있음
* slice: cgroup과 연관됨
* scope: 외부에서 생성된 시스템 프로세스 세트를 관리

systemd에게 인식되려면 유닛은 한 파일로 직렬화돼야 한다.
systemd는 여러 위치에서 유닛 파일을 찾는다. 가장 중요한 파일 경로 세 가지는 다음과 같다.

* /lib/systemd/system: 패키지가 설치한 유닛
* /etc/systemd/system: 시스템 관리자가 구성한 유닛
* /run/systemd/system: 비지속적 런타임 수정사항

systemd의 기본 작업 유닛이 정의되었으니, 이제는 커맨드 라인으로 어떻게 제어하는지를 살펴보자.

### systemctl로 관리하기

systemd의 상호 작용해 서비스를 관리하기 위해 사용하는 도구가 systemctl다.
자주 사용하는 systemctl 명령 목록은 아래와 같다.

| 항목                             | 유형                                  |
|--------------------------------|-------------------------------------|
| systemctl enable xxxx.service  | 서비스 활성화. 시작할 준비를 갖춤                 |
| systemctl daemon-reload        | 모든 유닛 파일을 다시 로드하고 전체 종속성 트리를 다시 생성함 |
| systemctl start xxxx.service   | 서비스 시작                              |
| systemctl stop xxxx.service    | 서비스 정지                              |
| systemctl restart xxxx.service | 서비스 정지 후 새로 시작                      |
| systemctl reload xxxx.service  | 서비스에 reload 명령을 보냄. restart로 돌아감    |
| systemctl kill xxxx.service    | 서비스 실행 중지                           |
| systemctl status xxxx.service  | 일부 로그를 포함해서 서비스 상태에 대해 간단 요약        |

* bootctl: 부트 로더 상태를 확인하고 사용 가능한 부트로더를 관리할 수 있다. 
* timedatectl: 시간과 날짜 관련 정보를 설정하고 볼 수 있다.
* coredumpctl: 저장된 코어 덤프를 처리할 수 있다.

### journalctl로 모니터링하기

journal은 systemd의 구성요소다.
기술적으로 이는 systemd-journald 데몬이 관리하는 바이너리 파일로, systemd 구성요소가 기록하는 모든 멧시지를 한 곳에 모은 것이다.

systemd가 관리하는 로그를 볼 수 있는 도구가 journalctl이라는 점만 알면 된다.

greeter 애플리케이션 예시를 살펴봄.

## 리눅스 애플리케이션 공금망

공급망이란 소비자에게 제품을 공급하는 조직이나 개인들의 시스템을 뜻한다.

예를 들어 음식을 사거나 자동차에 연료를 공급할 때 처럼..

이 책에서 제품이란 소프트웨어 아티팩트로 구성된 애플리케이션이며, 소비자란 앱을 사용하는 사람 또는 앱을 관리할 때 사용하는 도구로 생각할 수 있다.

![KakaoTalk_Photo_2024-04-06-15-32-47](https://github.com/happysubin/book-study/assets/76802855/027bd17b-ccac-48dc-ada5-d45bd9722031)

* 소프트웨어 유지 보수 담당자
  * 소프트웨어 아티팩트를 생성해(repo 패키지) 올리는 개별 개발자, 오픈소스 프로젝트, 독립 소프트웨어 공급업체가 포함된다,
* 저장소
  * 여기에는 앱의 일부 혹은 전체가 메타데이터와 함께 포함된 패키지가 있다. 일반적으로 패키지는 앱의 종속성도 캡쳐하며, 여기서 종속성이란 앱이 작동하기 위해 필요한 다른 패키지다.
  * 이는 라이브러리, 일종의 내보내기나 가져오기 또는 기타 서비스 프로그램일 수 있다.
  * 이런 종속성을 최신 상태로 유지하기는 어려울 것이다.
* 도구(패키지 관리자)
  * 대상 시스템 쪽에서 패키지 관리자를 사용해 저장소에 위치한 패키지를 조회하고 설치하고 업데이트하고 삭제할 수 있다.
  * 앱과 그 종속성을 나타내는 패키지는 하나 이상일 수 있다.

세부사항은 배포판마다 다를 수 있으며 환경(서버, 데탑)에 따라 다를 수 있지만 웹 공급망은 모두 공통적으로 위 그림과 같은 요소가 있다.

전통적인 패키지 관리자, 컨테이너 기반, 솔루션, 최근의 접근 방식 등 패키지 종속성 관리에 사용할 수 있는 옵션은 매우 많다.

![KakaoTalk_Photo_2024-04-06-15-39-01](https://github.com/happysubin/book-study/assets/76802855/d9ce4c3d-0787-4c6c-bc00-743d7c8b0960)


전통적인 패키지 관리자

* 이 카테고리에서는 일반적으로 저수준 도구와 고수준 도구를 구분한다.
* 패키지 관리자가 종속성을 해결할 수 있고 고수준 인터페이스(CUD)를 제공하는 경우 이를 고수준 패키지 관리자라고 부른다.

컨테이너 기반 솔루션

* 처음에는 서버와 클라우드 컴퓨팅 영역에서 나온 솔류션이다.
* 이들의 능력을 감안할 때, 이를 사용하기 좋은 곳이 바로 애플리케이션 관리다.
* 즉 쉽게 테스트할 수 있고 프로덕션으로 바로 배포 가능한 앱을 간단하게 만들 수 있기 때문에 개발자는 컨테이너를 좋아한다.

최신 패키지 관리자

* 이들은 데탑 환경에 뿌리를 두고 있고 여기서 주요 목표는 최종 사용자가 앱을 최대한 쉽게 사용하게 하는 것이다.

## 패키지와 패키지 관리자

보통 데비안 계약과 레드햇 계열에서 유래된 패키지 형식과 패키지 관리자에 대한 얘기를 한다.
먼저 아래 개념을 알아보자.

패키지 그 자체

* 엄밀히 말하면 압축된 파일 하나며, 메타데이터가 포함되어 있다.

도구(패키지 관리자)

* 대상 시스템에서 해당 패키지를 처리해 앱을 설치하고 유지 관리한다.
* 패키지 관리자는 보통 사용자를 대신해 저장소와 상호 작용하고 패키지의 로컬 캐시를 유지 관리한다.

대상 시스템은 예를 들면 노트북의 데스크톱 환경이나 클라우드의 서버 가상 머신 인스턴스일 수 있다.
패키지들이 적용될 가능성은 환경에 따라 다소 달라진다.
예를 들어 서버에 설치된 GUI 앱은 무의미할 수 있다.

### RPM 패키지 관리자

RPM 패키지 관리자는 원래 레드햇에서 만들었지만 현재는 다양한 배포판에서 널리 사용된다.
.rpm 파일 형식은 리눅스 표준 베이스에서 사용되며 바이너리나 소스 파일을 포함할 수 있다.
패키지는 암호로 검증할 수 있으며 패치 파일을 통한 델타 업데이트를 지원할 수 있다.
RPM을 사용하는 패키지 관리자는 다음과 같다.

* yum, DNF, 자이퍼

### 데비안 deb

deb 패키지와 .deb 파일 형식은 데미안 배포판에서 시작됐으며, deb 패키지는 바이너리나 소스 파일도 포함할 수 있다.
dpkg처럼 종속성 관리가 없는 저수준 패키지 관리자와 apt-get, apt, apptitude와 같은 고수준 패키지 관리자를 포함해 많은 패키지 관리자가 deb를 사용한다.
우분투가 데비안 기반의 배포판이라는점을 감안할 때 deb 패키지는 데스크톱과 서버 모두에서 널리 사용된다.

## 컨테이너

우리는 컨테이너를 리눅스 네임스페이스, cgroup, 때때로 CoW 파일 시스템을 사용해 애플리케이션 수준의 종속성 관리를 제공하는 리눅스 프로세스 그룹으로 이해한다.

컨테이너의 사용 사례는 로컬 테스트와 개불 부터 분산 시스템 작업까지 이르기까지 매우 다양

개발자와 시스템 관리자에게는 컨테이너가 유용하지만 최종 사용자에게는 더 고수준의 도구를 사용해 애플리케이션을 관리하는 쪽이 더 편할 것이다. (ex 홈브루)

리눅스에서 컨테이너 자체는 새로운 것이 아니지만, 도커 덕분에 주류로 편입되었다.

컨테이너의 접근 방식의 공통점은 네임스페이스, cgroup 같이 리눅스 커널이 제공하는 기본 빌등 블록을 이용해 사용자가 애플리케이션을 실행할 수 있게 한다는 점이다.

도커는 기존 개념을 혁신하고 2가지 획기적인 요소를 도입했다.

하나는 컨테이너 이미지를 통해 패키징을 정의하는 표준화된 방ㅂ법, 다른 한가지는 인간 친화적인 사용자 인터페이스이다.
도커에서 컨테이너 이미지가 정의되고 배포되는 방식과 컨테이너가 실행되는 방식은 현재 OCI 핵심 사양의 기반이 됐다.

3 가지 핵심 OCI 컨테이너 사양은 다음과 같다.

* 런타임 사양
  * 운영과 수명 주기 단계를 포함해 런타임이 지원해야 하는 것을 정의한다.
* 이미지 형식 사양
  * 메타데이터와 계층을 기반으로 컨테이너 이미지가 구성되는 방식을 정의한다.
* 배포 사양
  * 컨테이너 이미지가 전달하는 방식, 컨테이너와 관련해 저장소가 효과적으로 동작할 수 있는 방식을 정의한다.

컨테이너와 관련된 또 다른 개념은 불변성이다. 한 번 구성되면 사용 중에 변경할 수 없다는 의미다.
즉 변경하려면 새로운 구성과 새 리소스를 생성해야 한다.

### 리눅스 네임스페이스

리눅스는 리소스에 대한 전역 뷰를 가지고 있다.

프로세스가 리소스에 대한 로컬 뷰를 가질 수 있도록 리눅스는 네임스페이스를 도입했다. 즉 리눅스 네임스페이스는 모두 리소스 가시성에 관한 것이며 운영체제 리소스의 다양한 측면을 격리하는 데 사용할수 있다.
이 맥락에서 격리란 대부분 프로세스가 무엇을 보는지와 관련이 있으며 보안 관점에서 볼 때 반드시 엄격한 경계는 아니다.
네임 스페이스를 생성하려면 다음과 같은 3가지 관련 시스템 콜을 원하는 대로 상황에 맞게 사용할 수 있다.

* clone
  * 실행 컨텍스트의 일부를 부모 프로세스와 공유할 수 있는 자식 프로세스를 만드는 데 사용
* unshare
  * 기존 프로세스에서 공유된 실행 컨텍스트를 제거하는 데 사용된다.
* setns
  * 기존 프로세스를 기존 네임스페이스에 결합하는데 사용된다.

이 시스템 콜은 다양한 플래그를 매개변수로 사용하므로 새로 생성, 가입, 탈퇴하려는 네임스페이스를 세밀하게 제어할 수 있다.

아래 명령어를 통해 사용중인 네임스페이스를 확인할 수 있다.

```shell
sudo lsns
```

### 리눅스 cgroup

네임스페이스가 가시성에 관한거싱라면 cgroup은 프로세스 그룹을 구성하는 메커니즘이다.
cgroup을 계층 구조와 함께 사용하면 시스템 리소스 사용을 제어할 수 있다.
또한 cgroup은 리소스 사용 추적을 할 수 있다.

예를 들어 프로세스가 RAM이나 CPU 시간을 얼마나 사용중인지를 보여줄 수 있다.
cgroup은 선언형 유닛으로, 그리고 컨트롤러는 특정 리소스 제한을 적용하거나 사용량을 보고하는 커널 코드로 생각하자.

현재는 cgroup v1과 v2가 있다. 현재는 v1이 널리 사용되고 있지만 결국 v2가 이를 대체할 것이다.

systemctl 명령을 이용하면 리눅스 시스템의 모든 v2 cgroup을 트리 모양으로 볼 수 있다.


```shell
systemctl status
systemd-cgtop
```

### 쓰기 시 복사(Cow) 파일 시스템

컨테이너의 세 번째 빌딩 블록은 쓰기 시 복사 파일 시스템이다.
이들은 빌드 시 사용되며, 애플리케이션과 모든 종속성을 배포 가능한 독립 파일 하나로 패키징한다.
Cow 파일 시스템은 주로 바인드 마운트와 함께 사용되어 종속성이 서로 다른 콘텐츠를 효율적인 방식으로 계층화한다.

### 다른 컨테이너 도구

OCI 컨테이너 작업을 위해 도커를 무조건 사용할 필요는 없다.

다음과 같이 OCI 컨테이너, 네임스페이스, cgroupㅇ 작업을 보다 쉽게 해주는 많은 도구가 있다.

* containerd
* skopeo
* systemd-cgtop
* nsenter
* unshare
* lsns
* cinf

## 최신 패키지 관리자

1. 스냅
2. 플랫팩
3. 앱이미지
4. 홈브루