
# chapter 06. 애플리케이션, 패키지 관리, 컨테이너

애플리케이션은 __프로그램, 바이너리, 실행 파일__ 과 동일한 의미로 사용될 때가 많다.

리눅스가 시작되고 우리가 의존하는 모든 서비스를 제공하는 방식은 __부팅 프로세스__ 라고 부른다.
init 시스템, 특히 사실상의 표준인 systemd 생태계에 대해 살펴보자.

## 기본 개요

프로그램 

* 일반적으로 리눅스가 메모리에 로드하고 실행할 수 있는 바이너리 파일 혹은 셸 스크립트를 일컫는다.
* 이 엔티티를  부르는 또 다른 이름은 __실행 파일__ 이다.
* 실행 파일의 유형에 따라 그 실행을 정확히 무엇이 관리하는지가 결정된다.
* 예를 들어 셸 스크립트는 셸이 해석하고 실행한다.

프로세스

* 프로그램 기반의 실행 엔티티이며 슬립 상태가 아닌 한 메인 메모리에 로드되어 CPU나 I/O를 사용한다.

데몬

* __데몬 프로세스__ 의 줄임말로 __서비스__ 라고도 하며 다른 프로세스에 특정 기능을 제공하는 백그라운드 프로세스다.
* 예를 들어 프린터 데몬을 사용하면 인쇄가 가능해진다.
* 그 밖에도 웹 서비스, 로깅, 시간 등 매일 사용하는 유틸리티를 위한 온갖 데몬이 있다.

애플리케이션 

* 종속성을 포함한 프로그램, 사용자 인터페이스를 포함한 실질적인 프로그램이다.
* 일반적으로는 검색 부터 업그레이드를 위한 설치, 제거에 이르기까지, 프로그램의 전체 수명주기, 구성, 데이터와 연관해 애플리케이션이라는 용어를 사용한다.

패키지

* 프로그램과 구성을 포함한 파일을 말한다. 소프트웨어 애플리케이션을 배포하는데 사용된다.

패키지 관리자

* 패키지 입력 값으로 받아 해당 콘텐츠의 사용자 지침에 따라 리눅스 환경에서 패키지를 설치, 업그레이드, 제거하는 프로그램이다.

공급망

* 패키지를 기반으로 사용자가 애플리케이션을 찾고 사용할 수 있는 소프트웨어 생산자와 배포자의 모음을 뜻한다.

부팅

* 리눅스를 사용할 수 있는 상태로 만드는 것을 목표로 하드웨어와 운영체제를 초기화하는 리눅스의 시작 시퀀스를 의미한다.
* 여기에는 커널 로딩과 서비스(또는 데몬) 프로그램 시작도 포함된다.

## 리눅스 시작 프로세스

리눅스 부트 프로세스는 하드웨어와 커널이 함께 작동하는 여러 단계에 걸친 작업이다.

1. 전원 시작
2. UEFI나 BIOS (하드웨어)
3. 부트로더 (하드웨어)
4. 커널 (커널 공간)
5. init (사용자 공간)
6. 그 밖의 사용자 공간 (사용자 공간)


1번: 모던 환경에서 통일 확장 펌웨어 인터페이스 사양은 부팅 구성과 부팅 로더를 정의한다. 
이전 시스템에서는 이 단계에서 시동 자체 시험가 완료되면 기본 I/O 시스템이 하드웨어를 초기하고 부트 로더에 제어 권을 넘겨준다.

2번: 부트 로더의 목표는 커널을 부트스트랩하는 것이다. 부팅 매체에 따라 세부 사항은 약간 다르며 부트 로더의 옵션은 다양하고 현재 버전과 예전 레거시 모두 사용 가능하다.

3번: 커널을 일반적으로 압축된 형태로 /boot 디렉토리에 위치해 있다. 따라서 첫 번째 단계는 커널을 추출해 메인 메모리에 로드하는 것이다. 하위 시스템, 파일 시스템, 드라이버를 초기화하고 나면 커널은 init 시스템에 제어권을 넘기고 이로써 부팅 프로세스는 적절하게 종료한다.

4번: init 시스템은 시스템 전반에 걸쳐 데몬을 실행할 책임이 있다. 이 init 프로세스는 프로세스 계층 구조의 루트이며 프로세스 ID 값은 1을 가진다. 
즉 PID 1 프로세스는 시스템 전원을 끌 때까지 실행된다. 다른 데몬 실행을 담당하는 것 외에도 PID 1 프로세스는 전통적으로 고아 프로세스도 처리한다.

5번: 일반적으로 이 이후에 환경에 따라 또 다른 사용자 공간 수준의 초기화가 진행된다.
* 일반적으로는 터미널, 환경, 셸 초기화가 일어난다.
* 사용자 설정과 구성을 고려해 GUI가 있는 데스크톱 환경용 디스플레이 관리자, 그래픽 서버 등이 시작된다.

이제는 현재 거의 모든 리눅스 배포판에서 사용하는 init 시스템, systemd에 대해 알아보자.

## systemd

systemd는 처음에 initd를 대체하는 init 시스템이었지만 최근에는 로깅, 네트워크 구성, 네트워크 시간 동기화의 같은 기능을 포함하는 강력한 관리자다.
이는 데몬과 해당 종속성을 정의하는 유연하고 이식 가능한 방법은 물론이고 구성을 제어하는 통일된 인터페이스도 제공한다.

systemd는 다음을 통해 이전 init 시스템의 단점을 해결한다.

* 여러 배포판에서 리눅스의 시작을 관리할 수 있는 통일된 방법 제공
* 빠르고 이해하기 쉬운 서비스 구성 구현
* 모니터링, 리소스 사용 제어(cgroup), 내장된 감사(audit) 기능을 포함한 최신 제품군 제공

또한 init는 초기화 때 순서대로(즉 영숫자 순서로) 서비스를 시작하는 반면 systemd는 어느 서비스는 종속성만 충족되면 시작할 수 있으므로 시작 시간을 단축할 수 있는 잠재력이 있다.
무엇을 언제 어떻게 실행할지 systemd에 지시하는 방법은 유닛을 통해 이뤄진다.

### 유닛

systemd의 유닛은 기능 및 대상 리소스에 따라 의미 체계가 다른 논리 그룹이다.
systemd는 대상 리소스에 따라 여러 유닛을 구분한다.

* service 유닛 - 서비스나 애플리케이션을 관리하는 방법 설명
* target 유닛 - 종속성 캡쳐
* mount 유닛 - 마운트 지점 정의
* timer 유닛 - 크론 작업 등에 대한 타이머 정의

이보다 중요도가 조금 낮은 유닛은 아래와 같다.

* socket: 네트워크나 IPC 소켓을 설명
* device: udev나 sysfs 파일 시스템용
* automount: 자동 마운트 지점 구성
* swap: 스왑 공간 설명
* path: 경로 기반 활성화용
* snapshot: 변경사항이 일어난 후 시스템의 현재 상태를 재구성할 수 있음
* slice: cgroup과 연관됨
* scope: 외부에서 생성된 시스템 프로세스 세트를 관리

systemd에게 인식되려면 유닛은 한 파일로 직렬화돼야 한다.
systemd는 여러 위치에서 유닛 파일을 찾는다. 가장 중요한 파일 경로 세 가지는 다음과 같다.

* /lib/systemd/system: 패키지가 설치한 유닛
* /etc/systemd/system: 시스템 관리자가 구성한 유닛
* /run/systemd/system: 비지속적 런타임 수정사항

systemd의 기본 작업 유닛이 정의되었으니, 이제는 커맨드 라인으로 어떻게 제어하는지를 살펴보자.

### systemctl로 관리하기

systemd의 상호 작용해 서비스를 관리하기 위해 사용하는 도구가 systemctl다.
자주 사용하는 systemctl 명령 목록은 아래와 같다.

| 항목                             | 유형                                  |
|--------------------------------|-------------------------------------|
| systemctl enable xxxx.service  | 서비스 활성화. 시작할 준비를 갖춤                 |
| systemctl daemon-reload        | 모든 유닛 파일을 다시 로드하고 전체 종속성 트리를 다시 생성함 |
| systemctl start xxxx.service   | 서비스 시작                              |
| systemctl stop xxxx.service    | 서비스 정지                              |
| systemctl restart xxxx.service | 서비스 정지 후 새로 시작                      |
| systemctl reload xxxx.service  | 서비스에 reload 명령을 보냄. restart로 돌아감    |
| systemctl kill xxxx.service    | 서비스 실행 중지                           |
| systemctl status xxxx.service  | 일부 로그를 포함해서 서비스 상태에 대해 간단 요약        |

* bootctl: 부트 로더 상태를 확인하고 사용 가능한 부트로더를 관리할 수 있다. 
* timedatectl: 시간과 날짜 관련 정보를 설정하고 볼 수 있다.
* coredumpctl: 저장된 코어 덤프를 처리할 수 있다.
