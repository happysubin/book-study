
# chapter 4. 접근 제어

## 기본 개요

### 리소스와 소유권

리눅스는 다중 사용자 운영체제로 유닉스로부터 사용자 개념을 물려받았다.
각 사용자 계정은 실행 파일, 파일, 장치, 기타 리눅스 자산에 접근할 수 있는 사용자 ID와 연결된다.

인간 사용자는 사용자 계정으로 로그인할 수 있으며 프로세스도 사용자 계정으로 실행할 수 있다.
그리고 사용자가 이용할 수 있는 하드웨어 또는 소프트웨어 구성요소인 리소스가 있다.

일반적으로 시스템 콜과 같이 다른 종류의 리소스에 대한 접근을 명시적으로 언급하지 않는 한 리소스는 파일로 지칭한다.

![스크린샷 2024-03-31 오전 11 27 48](https://github.com/happysubin/book-study/assets/76802855/e8cebb53-88d7-4e26-97a8-8cd382a869b8)

* 사용자
  * 프로세스를 실행하고 파일을 소유한다. 프로세스는 커널이 메인 메모리에 로드해 실행하는 일종의 프로그램이다.
* 파일
  * 소유자가 존재한다. 기본적으로는 파일을 만든 사용자가 파일을 소유한다.
* 프로세스
  * 의사소통과 지속성을 위해 파일을 사용한다. 물론 사용자도 파일을 간접적으로 사용하기도 하지만 그러려면 프로세스를 통해야 한다.

### 샌드박스

샌드박스라는 용어의 정의는 다소 모호해서, 제일(jail)에서 컨테이너, 가상 머신에 이르기까지 커널이나 사용자 영역에서 관리할 수 있는 다양한 방법을 가리킬 수 있다.
일반적으로 샌드 박스에서 실행되는 항목이 있다면 감시 메커니즘은 샌드박스 프로세스와 호스팅 환경 간에 어느 정도 격리를 실행한다.

### 접근 제어 유형

접근 제어의 한 측면은 접근 자체의 특성이다.

사용자나 프로세스가 무제한으로 리소스에 직접 접근하는가? 아니면 프로세스가 어떤 상황에서 어떤 종류의 리소스에 접근 가능한지에 대해 명확한 규칙 집합이 있을 수도 있다.

또는 접근 그 자체가 기록될 수도 있다.

개념적으로는 다양한 접근 제어 유형이 있으나 리눅스 관점에서 가장 중요하고 관련성이 높은 두 가지는 __임의 접근 제어__ 와 __강제 접근 제어__ 다.

* 임의 접근 제어
  * 임의 접근제어를 사용하면 사용자의 신분을 기반으로 리소스에 대한 접근을 제한할 수 있다.
  * 여기서 임의라 함은 특정 권한을 가진 사용자가 이를 다른 사용자에게 전달할 수 있음을 뜻한다.
* 강제 접근 제어
  * 강제 접근 제어는 보안 수준을 나타내는 계층 모델을 기반으로 한다.
  * 사용자에게는 허용 등급이 할당되고 리소스에는 보안 레이블이 할당된다.
  * 사용자는 자신의 허용 등급 이하로 설정된 리소스에만 접근할 수 있다.
  * 강제 접근 제어 모델에서는 관리자가 모든 권한을 설정하여 엄격하고 배타적으로 접근을 제어한다.
  * 즉 사용자는 리소스를 소유하고 있어도 권한을 스스로 설정할 수 없다.

리눅스에서 사용자는 모든 것을 변경할 수 있는 권한을 가진 수퍼유저이거나 일반 사용자 중 하나다.
처음에는 사용자나 프로세스에 특정 권한을 배정하는 쉽고 유연한 방법이 없었다.

한 예로, 일반적인 경우 "프로세스 X는 네트워킹 설정을 변경할 수 있다." 라는 조건을 활성화하려 면 root 접근 권한을 부여해야 했다.
이런 광범위한 권한은 공격자가 오요하기 쉽기 때문에 공격당한 시스템에 당연히 확실한 영향을 미친다.

추후 고급 권한 관리에서 이런 이분법적인 세계관을 극복해 더 세분화된 권한 관리를 허용하는 방법을 살펴본다.

### 사용자

리눅스에서는 목적 또는 의도적인 사용 관점에서 사용자 계정을 두 가지 유형으로 구별한다.

* 시스템 사용자 또는 시스템 계정
  * 일반적으로 프로그램은 이런 유형의 계정을 사용하여 백그라운드 프로세스를 실행한다.
  * 이들 프로그램이 제공하는 서비슨느 네트워킹과 같은 운영체제의 일부이거나 애플리케이션 계층에 있을 수 있다.
* 일반 사용자
  * 예를 들어 셸을 통해 리눅스를 대화식으로 사용하는 인간 사용자 유형

리눅스는 UID를 통해 사용자를 식별. 사용자는 그룹 ID, GID를 통해 식별되는 하나 이상의 그룹에 속한다.

여기에는 일반적으로 root라고 하는 UID 0을 가진 특별한 종류의 사용자가 있는데 이 '수퍼유저'는 무엇이든 할 수 있다.
제한이 전혀 적용되지 않는다.

일반적인 경우 root 사용자로 작업하는 것은 피해야한다. 권한이 너무 많기 때문. 주의하지 않으면 시스템을 파괴하기 쉽다.

각각의 리눅스 배포만마다 UID 범위를 관리하는 방법을 결정하는 고유한 방법이 존재한다.

예를 들어 systemd 기반 배포판에는 다음과 같은 규칙이 있다.

* UID -> root 사용자
* UID 1부터 999 -> 시스템 사용자에게 할당
* UID 65534 -> nobody 사용자. 예를 들어 NFS절의 경우와 같이 원격 사용자를 잘 알려진 ID에 매핑하는데 사용
* UID 10000부터 65333, 그리고 65536ㅂ주터 4294967294까지 -> 일반 사용자

자신의 uid를 알아내리면 다음과 같은 id 명령을 사용하자

```shell
id -u
```

이제 사용자 관리에 대해 알아보자.

### 로컬에서 사용자 관리하기

첫 번째 옵션은 사용자를 로컬에서 관리하는 것이다.
직 시스템에 로컬로 저장된 정보만 사용되며 사용자 관련 정보는 시스템 네트워크에서 공유되지 않는다.
로컬 사용자 관리를 위해 리눅스는 간단한 파일 기반 인터페이스를 사용한다.
하지만 불행하게 이름 지정 체계가 다소 혼랍스럽다.

아래 네 개의 파일 목록이 엮여서 사용자 관리를 구현한다.

* 사용자 데이터베이스 /etc/password
* 그룹 데이터베이스 /etc/group
* 사용자 비밀번호 /etc/shadow
* 그룹 비밀번호 /etc/gshadow

/etc/password를 사용자 이름, UID, 그룹 구성원, 그리고 일반 사용자를 위한 홈 디렉터리와 로그인 셸 같은 기타 데이터를 기록하는 일종의 작은 사용자 데이터베이스로 생각하자.

```shell
cat /etc/passwd
```

위 파일의 하나의 행을 살펴보자.

>> root(7):x(6):0(5):0(4):root(3):/root(2):/bin/bash(1)

1. /bin/bash 사용할 로그인 셸. 대화식 로그인 로그인을 이요하지 않으려면 /sbin/nologin을 사용
2. 사용자의 홈디렉터리. 기본값은 / 이다.
3. 이름 또는 전화 번호 같은 연라처 데이터 등의 정보. 흔히 GECOS 필드라고도 알려져있다.
4. 사용자의 기본 그룹 GID. /etc/group 참조
5. UID. 리눅스는 1000 미만의 UID는 시스템 사용을 위해 예약한다.
6. 사용자의 비밀번호. x 문자는 암호화된 비밀번호가 /etc/shadow에 저장됨을 의미한다.
7. 사용자 이름은 32자 이하여야 한다.

/etc/passwd라는 파일 이름에서 유추할 수 있는 것이 실제로는 하나 빠져있다.

그것은 바로 암호다. 암호는 역사적인 이유로 /etc/shadow 파일에 저장된다.
이 파일을 읽으려면 root 권한이 필요하다.

사용자를 추가하려면 adduser 명령을 사용하면 된다.

```shell
sudo adduser test
```

시스템 계정을 생성하려면 -r 옵션을 전달하면 된다.
구성 세부 정보에 대해 알고 싶다면 UID/GID 범위 등의 옵션을 포함해 /etc/adduser.conf도 참조하자

### 중앙 집중식 사용자 관리

전문적인 설정으로 사용자를 관리해야하는 시스템이나 서버가 둘 이상인 경우, 로컬에서 사용자를 관리하는 방식은 이미 구식이다.

이런 경우 중앙에서 사용자를 관리하지만 하나의 특정 시스템에 로컬로 적용할 수 있는 관리 방식이 필요하다.

요구사항과 예산에 따라 사용가능한 몇 가지 접근방식이 있다.

* 디렉터리 기반: LDAP는 수십년된 프로토콜ㅊ 제품군으로 IETF에서 공식되어 있으며, IP를 통해 분산 디렉터리에 접근하고 관리하는 유지 방법을 정의
* 네트워크 이용: 커버로스를 사용해 네트워크로 사용자 인증
* 구성 관리 시스템 사용: 앤서블, 셰프, 퍼핏, 솔트트랙등의 시스템들을 사용해 여러 컴퓨테에서 일관되게 사용자 생성

## 권한

### 파일 권한

파일 권한은 '리소스에 접근'한다는 리눅스 개념의 핵심이다.

리눅스에서는 어쨌든 모든 것이 파일이기 때문이다.

먼저 몇 가지 용어를 알아보고 팡리 접근과 권한에 관련된 메타데이터를 자세히 살펴보자.
다음과 같이 좁은 범위부터 넒은 범위까지 세 가지 유형/범위의 권한이 있따.

* 사용자: 파일의 소유자.
* 그룹: 그룹은 하나 이상의 구성원이 있다.
* 나머지: 그 밖의 모두가 이 카테고리에 들어간다.

또 한 세가지 접근 유형이 존재한다. 읽기, 쓰기, 실행

실행 옵션을 키면 사용자가 읽기 권한도 가지고 있는 경우 이 파일을 실행할 수 도 있다.

> -rw-r--r--(7)  1(6) mh9(5) devs(4)    9(3) Apr(2)  12  11:42 test (1)

1. 파일 이름
2. 마지막으로 수정한 타임 스탬프
3. 파일 크기(바이트)
4. 파일이 속한 그룹
5. 파일 소유자
6. 하드링크 개수 
7. 파일 모드

> .(4) rwx(3) rwx(2) rwx(1)

1. 나머지 사용자의 권한
2. 그룹의 권한
3. 파일 소유자의 권한
4. 파일의 형식

파일 모드의 첫 번째 필드는 파일 형식을 나타낸다. 아래를 살펴보자.

* -: 일반 파일(예 touch abc를 한 경우)
* b: 블록 특수 파일
* c: 캐릭터 특수 파일
* C: 고성능(연속 데이터) 파일
* d: 디렉터리
* l: 심볼릭 링크
* p: 명명된 파이프(mkfifo로 생성)
* s: 소켓
* ?: 기타(알 수 없는) 파일 형식

0 위치에 사용되는 문자 중에는 M이나 P 같이 일부 다른 문자도 있다.
대부분 무시해도 되지만, 그 의미를 알고 싶다면 info ls -n "What information is listed" 을 실행해보자.

파일 모드에서 이런 권한을 조합해서, 표 4-3에 표시된 대로 대상 집합의 각 요소에게 어떤 것이 허용되는지를 정의하며 access 명령을 확인되고 실행된다.

| 패턴  | 적용되는 권한    | 십진법 표기 |
|-----|------------|--------|
| --- | 없음         | 0      |
| --x | 실행         | 1      |
| -w- | 쓰기         | 2      |
| -wx | 쓰기와 실행     | 3      |
| r-- | 읽기         | 4      |
| r-x | 읽기와 실행     | 5      |
| rw- | 읽기와 쓰기     | 6      |
| rwx | 읽기, 쓰기, 실행 | 7      |

* 755: 사용자는 모든 권한을 가지며, 그 외 모든 사람은 읽기와 쓰기 권한을 가진다.
* 700: 소유자는 모든 권한을 가지며, 그 외 모든 사람은 아무 권한이 없음
* 664: 소유자와 그룹은 읽기/쓰기 권한이 있으며, 나머지 사용자는 읽기만 가능.
* 644: 소유자는 읽고 쓰기가 가능하며, 그 외 모든 사람은 읽기만 가능
* 400: 소유자는 읽고 쓰기가 가능하며, 그 외 모든 사람은 읽기만 가능함

664는 특별한 의미가 있따. 이 권한은 내가 파일을 만들 때 할당하는 기본 권한이다.

chmod로 파일의 권한을 변경할 수 있다. 원하는 권한 설정을 명시적으로 지정하거나 단축어를 사용할 수 있다.

아래 명령어는 모든 파일을 실행 가능하게 만든다.

```shell
chmod +x /tmp/masktest
```

모든 사람에게 파일 실행 권한을 부여하고 싶지 않으면 chmod 744를 선택하자.

chown을 사용해 소유권을 변경할 수 있다.

```shell
sudo chown root myfile
```

sudo chown 이후에는 root가 해당 파일을 소유한다.


### 프로세스 권한

* RUID
  * RUID는 프로세스를 시작한 사용자의 UID다.
  * 인간 사용자 관점에서의 프로세스 소유권을 나타낸다.
  * 프로세스 자체에서는 getuid(2)를 사용해 자신의 RUID 얻을 수 있으며 셸에서 stat -c "%u %g" /proc/$pid/을 사용해 쿼리를 할 수도 있다.
* EUID
  * 리눅스 커널은 메시지 대기열과 같은 공유 리소스에 접근할 때 EUID를 사용해 프로세스가 갖는 권한을 결정한다.
  * 전통적인 유닉스 시스템에서는 EUID가 파일 접근에도 사용된 반면, 리눅스는 파일 접근 권한에 전용 파일 시스템 (UID)를 사용했었다.
  * 이 방법은 호환성을 이유로 아직도 지원된다.
* 저장된 SUID
  * SUID 맥락에서, 저장된 SUID는 프로세스가 실제 UID과 저장된 SUID 사이에서 유효 UID를 전환함으로써 권한을 가정할 수 있을 때 사용된다.
  * 예를 들어 프로세스가 특정 네트워크 포트를 사용하도록 허용하려면 root로 실행되는 것처럼 높은 권한이 필요하다.
* FUID
  * FUID는 리눅스 전용 ID로서 파일 접근 권한을 결정하는데 사용됏으며, 원래 파일 서버가 일반 사용자를 대행해서 동작하되 해당 사용자가 보내는 시그널로부터 프로세스를 격리하는 사용 사례를 지원하기 위해 도입됐다.
  * 프로그램은 일반적으로 이 UID를 직접 조작하지 않늗나.
  * 커널은 EUID가 변경되는 시기를 추적하고 이에 따라 파일 시스템 UID를 자동으로 변경한다.


커널은 파일 접근 권한 외에도 다음을 비롯한 여러 용도로 프로세스 UID를 사용한다.

* 신호를 보내기 위한 권한 설정, 예를 들어 특정 프로세스 ID에 대해 kill -9를 할 때 어떤 일이 발생하는지를 결정한다. 이에 대해서는 6장에서 다시 다룰 것이다.
* 스케줄링과 우선 순위에 대한 권한 처리
* 리소스 제한 확인. 컨테이너에 대해서는 9장에서 자세히 설명한 것이다.


## 고급 권한 관리

### 캐퍼빌리티

유닉스 시스템의 전통을 이어받은 리눅스에서는 root 사용자가 프로세스를 실행할 때 아무런 제한이 없다. 즉 커널은 당므 두 가지 경우만 구분한다.

* EUID가 0인 권한 있는 프로세스는 커널 권한 검사를 우회한다.
* EUID가 0이 아닌, 권한 없는 프로세스에 대해서는 프로세스 권한에서 설명한 것처럼 커널이 권한 검사를 수행한다.

커널 v2.2에 캐퍼빌리티 시스템콜이 도입되면서 이런 이분법적 세계관이 바뀌었다.
전통적으로 root와 관련됐던 권한은 이제 개별 단위로 나뉘어서 스레드마다 독립적으라 할당할 수 있게 됐다.

실제로, 캐퍼빌리티 시스템 콜이 도입되면서 이런 이분법적 세계관이 바뀌었다.
전통적으로 root와 관련됐던 권한은 이제 개별 단위로 나뉘어서 스레드마다 독립적으로 할당할 수 있게 됐다.

실제로 캐퍼빌리티가 없는 일반 프로세스는 직전 절에서 설명한 권한으로 제어된다고 볼 수 있다.
프로세스는 물론이고 실행 파일에 캐퍼빌리티를 할당해 작업 수행에 필요한 권한을 점진적으로 추가할 수 있다.

여기서 주의 사항이 하나 있는데, 캐퍼빌리티는 일반적으로 시스템 수준의 작업에만 관련된다.
즉 대부분의 경우 이런 캐퍼빌리티에 반드시 의존하지 않아도 된다. 널리 사용되는 캐퍼빌리티 몇 가지를 아래 표에서 확인할 수 있다.

| 캐퍼빌리티          | 의미                                   | 
|----------------|--------------------------------------|
| CAP_CHOWN      | 사용자가 파일의 UID/GID를 임의로 변경할 수 있게 허용한다. |
| CAP_KILL       | 다른 사용자에게 속한 프로세스에 실호를 보낼 수 있게 허용한다.  |
| CAP_SETUID     | UID를 변경할 수 있게 허용한다.                  |
| CAT_SETPCAP    | 실행중인 프로세스의 캐퍼빌리티를 설정할 수 있게 허용한다.     |
| CAT_NET_ADMIN  | 인터페이스 구성과 같은 다양한 네트워크 관련 작업을 허용한다.   |
| CAT_NET_RAW    | RAW와 PACKET 소켓의 사용을 허용한다.            |
| CAT_SYS_CHROOT | chroot의 호출을 허용한다.                    |
| CAT_SYS_ADMIN  | 파일 시스템 마운트를 포함한 시스템 관리 작업을 허용한다.     |
| CAT_SYS_PTRACE | strace를 사용하여 프로세스를 디버그할 수 있게 허용한다.   |
| CAT_SYS_MODULE | 커널 모듈의 로딩을 허용한다.                     |

### seccomp 프로필

seccomp를 직접 관리하는 것이 불편할 수 있지만 큰 번거로움 없이 사용할 수 있는 방법도 있다.
ex (쿠버네티스, 도커)

### 접근 제어 목록

접근 제어 목록, ACL을 사용하면 유연한 권한 메커니즘이 리눅스에 생긴다.

ACL은 사용자의 그룹 내에 없는 사용자나 그룹에 권한을 부여할 수 있다는 점에서 전통적인 권한의 단점을 해결할 수 있다.

## 우수 사례

* 최소 권한
* setuid를 피하자
* 감사: 모든 작업들을 변조할 수 없는 방식으로 결과 로그에 기록한다는 개념이다.