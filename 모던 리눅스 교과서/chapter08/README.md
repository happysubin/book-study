# chapter 08. 관측가능성

관측가능성은 문제가 발생한 이후에 확인하게 된다.
즉 뭔가가 충돌하거나 느리게 실행되고 나면 그제셔야 우리는 프로세스와 해당 프로세스의 CPU, 메모리 사용량을 살펴보거나 로그를 파헤치기 시작한다.
하지만 특정 알고리즘이 얼마나 오래 걸리는지 파악하려는 경우에서처럼 관측 가능성은 조사라는 특성과 가깝기도 하다.
마지막으로 예측적 관측 가능성도 사용할 수 있다. 예를 들어 현재 동작을 추정하여 미래에 일어날 조건에 대해 경고를 받는 식이다.

![KakaoTalk_Photo_2024-04-08-21-43-27](https://github.com/happysubin/book-study/assets/76802855/21f75c8b-68bf-4e89-9479-c2d07f759f34)

## 기본개요

### 관측가능성(옵저빌리티) 전략

옵저빌리티에 대해 널리 확립된 전략 중 하나가 우다 루프다.
이는 관측된 데이터를 기반으로 가설을 테스트하고 이에 따라 조치를 취하는 구조화된 방법, 시그널로부터 실행 가능한 통찰력을 얻는 방법을 제공한다.

예) 애플리케이션이 느리다고 가정. 그럼 느려진 원인으로 여러 후목을 지목한다.(메모리 부족, CPU 주기 부족, 네트워크 I/O 부족)
우선은 각 리소스가 얼마나 소비되는지부터 측정해야 할 것이다.
그런 다음 각 리소스의 할당을 개별적으로 변경하고 결과를 측정해본다.

앱에 더 많은 RAM을 제공했더니 성능이 향상됐는가? 그렇다면 이유를 찾은 것이다.
그렇지 않으면 다른 리소스를 연이어 사용해보면서, 소비량을 측정하고 이를 그 상황에서 관측된 영향과 연결하려 항상 노력해야 한다.


__관측가능성(옵저빌리티)__

* 외부 정보를 측정하여 시스템(리눅스)의 내부 상태를 평가하는 것.
* 일반적으로는 후속 조치를 취한다.
* 예를 들어 시스템이 느리게 반응하는 것을 느껴 사용 가능한 주 메모리 양을 측정했다면, 특정 앱이 모든 메모리를 독차지하는 상황을 발견했을 수 있다.
* 이때 우리는 그 상황을 해결하기 위해 해당 앱을 종료하기로 결정할 수 있다.

__시그널 유형__

* 기호적 수단이나 숫자 값, 또는 이들의 조합을 통해 시스템 상태에 대한 정보를 보여주고 내보내는 다양한 방식을 말한다.

__소스__

* 시그널을 생성하는 곳. 해당 시그널의 유형은 다양할 수 있다.
* 소스는 리눅스 운영체제일 수도, 애플리케이션일 수도 있다.

__목적지__

* 시그널을 소비, 저장, 추가적으로 처리하는 곳이다.
* GUI를 노출하는 목적지를 프론트엔드라고 한다.
* 예를 들어 로그 뷰어, 시계열을 표시하는 대시보드는 프론트엔드인 반면 S3 버킷은 아니다.

__텔레메트리__

* 소스에서 시그널을 추출하고 시그널을 목적지로 전송하는 프로세스로, 시그널을 수집 및 전처리하는 에이전트를 사용하는 경우가 많다.

### 시그널 유형

시그널은 추가 처리나 해석을 위해 시스템  상태를 전달하는 방법으로서, 크게 텍스트 페이로드와 숫자 페이로드로 구분한다.

살펴볼 시그널은 로그, 지표(메트릭), 추적(트레이스)이다.

__로그__

* 로그는 거의 모든 시스템이 생성하는 기본 시그널 유형
* 로그란 사람이 사용할 수 있는 텍스트 페이로드가 있는 개별 이벤트로서 일반적으로 이런 이벤트에는 타임스탬프가 지정된다.
* 로그는 메시지의 각 부분마다 명확한 의미가 정의되도록 구성하는 것이 이상적이다.
* 이 의미는 유효성 검사가 자동을 ㅗ수행될 수 있도록 형식 스키마를 통해 표현될때가 많다.
* 모든 로그가 일종의 구조를 지님에도 실무에서는 구조화된 로깅이라는 용어를 자주 듣는다.
* 사실 로그가 JSON을 이용해 구성된다는 의미다.

__지표(메트릭)__

* 지표는 (대부분 정기적으로)샘플링된 숫자 데이터 포인트로서, 시계열을 형성한다.
* 각각의 데이터 포인트는 차원이나 식별 메타데이터의 형태로 추가 컨텍스트를 가질 수 있다.
* 일반적으로는 원시(raw) 지표를 직접 사용하지 않는다.
* 대신 일종의 집계(aggregation)나 그래픽 표현을 사용하고, 특정 조건이 충족되면 알림을 받기도 한다.
* 지표는 운영 작업에도 유용하며, 앱이 완료한 트랜잭션 수나 특정 작업에 소요된 시간과 같은 질문에 답하기 위한 문제 해결에도 유용하다.

메트릭은 아래와 같이 다양한 유형으로 분류한다.

1. 카운터 (올라가기만함)
2. 게이지 (올라가고 내려감)
3. 히스토그램 (값의 분포를 보여줌)

__추적(트레이스)__

* 추적은 런타임 정보의 동적 모음으로서, 디버깅뿐만 아니라 성능 평가에도 자주 사용된다.
* 예시: 특정 원인에 대해 프로세스가 사용하는 시스템 콜에 대한 정보나 커널의 이벤트 시퀀스

## 로깅

로그란 사람이 사용하기에 최적화된 텍스트 페이로드가 있는 개별 이벤트다.

__개별 이벤트__

* 로그 항목을 사용해 코드에서 진행 중인 작업에 대한 정보를 공유하고 싶다고 가정.
* 예시: 데이터베이스 연결이 성공적으로 설정되었다는 로그행을 출력
* 로그 메시지의 범위를 적고 구체적으로 유지하면 메시지를 사용하는 사람이 코드에서 해당 위치를 더 쉽게 찾을 수 있다.

__텍스트 페이로드__

* 로그 메시지의 페이로드는 텍스트고 기본 소비자는 사람이다.
* 즉 커맨드라인에서 로그 뷰어를 사용하든 GUI가 있는 멋진 로그 처리 시스템을 사용하든 사람이 로그 메시지의 내용을 읽고 해석하고 그에 따라 조치를 결정하는 것이다.

구조적 관점에서 보면 전체적으로 로그는 다음과 같이 구성된다.

* 로그 항목, 메시지, 행의 모음: 개별 이벤트에 대한 정보를 캡처한다.
* 메타데이터, 컨텍스트: 전역범위 뿐만 아니라 메시지 단위로도 존재할 수도 있다.
* 개별 로그 메시지를 해석하는 방법을 보여주는 형식: 로그의 부분과 의미를 정의. 공백으로 구분된 행 중심 메시지나 JSON 스키마를 예로 들 수 있다.

로그로 인한 오버헤드는 비하는 편이 좋다.
이와 관련한 예로 logrotate를 이용한 로그 순환을 사용하는 경우가 있다.
데이터 온도라는 고급 개념도 유용할 수 있으며, 오래된 로그 파일을 더 저렴하고 느린 스토리지로 옮길 수도 있다.

로그 항목의 중요성이나 의도된 대상 소비자를 알려주기 위해 대부분의 로그는 레벨을 정의해둔다.

아래 명령어는 리눅스의 중앙 로그 디렉터리를 조회한다.
```shell
ls -al /var/log
```

로그를 실시간으로 확인하는 일반적인 패턴 중 하나는 로그를 계속 따라가는 것이다.
즉 새 로그행이 추가될 때 마다 로그의 마지막을 확인한다.

```shell
tail -f /var/log/syslog
```

-f 옵션을 사용해 syslogd 프로세스의 로그를 따라간다.

이제 리눅스에서 일반적으로 사용되는 두 가지 로깅 시스템을 알아보자.

### Syslog

Syslog는 커너렝서부터 데몬, 사용자 공간까지 이르는 다양한 소스의 로깅 표준이다.
네트워크 환경에 근간을 두고 있으며 최근의 프로토콜은 배포 시나리오 및 보안 고려사항과 함께 RFC 5424에 정의된 텍스트 형식으로 구성된다.

systemd가 모든 주요 리눅스 배포판에서 사용되는 init 시스템의 사실상 표준이 되면서 로깅에 대한 새로운 방법이 나타났는데 그것이 바로 systemd 저널이다.

### journalctl

systemd 에코시스템의 일부이며 로그 관리를 담당하는 구성 요소인 journalctl을 간략하게 다룬적이 있다.
Syslog 등 지금까지 사용한 시스템들과 달리 journalctl은 바이너리 형식을 사용해 로그 항목을 젖아한다.
이를 통해 더 빠르게 접근할 수 있으며 저장 공간도 더 많이 확보할 수 있다.

바이너리 저장 형식은 처음 등장했을 때 논란이 있었는데, 로그를 보고 검색할 경우 사람들이 익숙해하는 tail, cat, grep 명령을 사용할 수 없었기 때문이다.
그렇기에 journalctl을 사용하면 로그를 다루는 방법을 새로이 익혀야 하지만 배우기 어렵지 않다.

```shell
journalctl --since "3 hours ago"
journalctl --since "2021-09-26 15:30:00" --until "2021-09-26 18:30:00"
```

아래와 같이 systemd 단위로도 출력값을 제한할 수 있다.

```shell
journalctl -u greeter.service
journalctl -f
```

sytemd에서 관리하는 리눅스 배포판의 보안 구성 요소인 AppArmor를 다시 시작한다고 가정하자.
즉 한 터미널에서는 systemctl restart apparmor를 사용해 서비스를 다시 시작하고, 다른 터미널에서는 다음 명령을 시작한다.


```shell
journalctl -f -u apparmor.service
```

### 모니터링

모티렁이란 다양한 이유로 시스템과 애플리케이션 지표를 캡쳐하는 것이다.
모니터링과 관련해 가장 자주 수행하게 될 두 가지 유형의 활동은 다음과 같다.

* 하나 이상의 지표 추적
* 조건에 의거한 알림

이제 몇 가지 도구에 대해 살펴본다.

uptime 명령을 사용해 시스템 실행 시간, 메모리 사용량 등 기본 지표 몇 가지를 보여주는 간단한 예시다.

```shell
uptime
```

free -h 명령을 사용해 기본 메모리 사용률 몇 가지를 모니터링해보자.

```shell
free -h
```

vmstat 명령을 사용하면 메모리 사용량을 좀 더 정교하게 확인할 수 있다.
다음 예는 자체적으로 상태를 업데이트하게끔 vmstat를 사용하는 것이다.

```shell
vmstat 1
```

특정 작업에 걸리는 시간을 확인하려면 time 명령을 사용하면 된다.

```shell
time (ls -R / etc 2& > /dev/null)
```

### 디바이스 I/O와 네트워크 인터페이스

iostat를 사용하면 I/O 디바이스를 모니터링할 수 있다.

```shell
iostat -z --human
```

다음은 ss 명령을 통해 TCP, UDP 소켓 모두를 프로세스 ID와 함께 출력한다.

```shell
ss -atup
```

lsof는 list open files의 약자이며 사용 사례가 많은 다목적 도구다.
다음 예는 네트워크 연결에서 사용되는 lsof를 보여준다.

```shell
sudo lsof -i TCP:1-1024
```

lsof의 또 다른 사용 예는 프로세스 중심 뷰다.
프로세스의 PID를 알고 있는 경우 lsof를 사용하여 파일 디스크립터와 I/O 등을 추적할 수 있다.

```shell
lsof -p 5299
```

### 통합 성능 모니터

앞서 살펴본 도구들은 좋은 출발점이며 스크립트에서도 유용하다.
하지만 더 편리하게 모니터링하면 통합 솔루션이 더 좋다.

top은 아주 좋은 예시다

```shell
top
```

htop, atop, below 같은 많은 도구도 존재한다.

참고 (glances, guider, neoss, mtr)

### 계측

시그널, 특히 지표를 생성하기 위해 코드를 삽입하는 프로세스는 주로 여러분이 소프트웨어를 개발하는 경우와 관련이 있다.
이 프로세스를 일반적으로 __게측__이라고 하며, 일반적인 계측 전략에는 두 가지가 있다.

바로 자동 계측(개발자 작업 필요 X)과 사용자화 계측(코드 스니펫을 수동으로 삽입, 예를 들면 코드의 특정 지점에서 지표 생성)이다

풀 기반이나 스크레핑이라고도 하는 또 다른 접근 방식도 존재한다.

## 고급 관측 가능성(옵저빌리티)

### 추적과 프로파일링

추적이라는 용어는 여러 군데서 굉장히 많이 쓰인다.
리눅스의 맥락에서 보면, 단일 시스템에서 추적이란 시간 경과에 따른 프로세스 실행을 캡쳐하는 것을 의미한다.
단일 리눅스 시스템에는 다양한 데이터 소스가 있으며, 다음을 추적 소스로 사용할 수 있다.

* 리눅스 커널: 추적은 커널의 함수에서 가져올 수도 있고, 시슻템 콜에 의해 트리거될 수도 있다. 커널 프로브(kprobe)나 커널 트레이스포인트(tracepoint)가 그 예다.
* 사용자 공간: 사용자 공간 프로브(uprobe)를 통하는 등의 애플리케이션 함수 호출은 추적 소스 역할을 할 수 있다.

추적의 사용 예로는 다음과 같은 것이 있다.

* strace등의 추적 도구를 사용한 프로그램 디버깅
* perf를 사용한 프론트엔드 성능 분석

```shell
sudo perf top
```

앞으로는 eBPF가 추적을 구현하는 사실상 표준이 될 것으로 보인다.
특히 사용자 치점 추적 사례의 경우가 더 그렇다.

추적의 사용 사례 중하나는 프로파일링, 즉 자주 호출되는 코드 섹션을 식별하는 것이다.
프로파일링을 위한 저수준 도구로는 pprof, 밸그라인드, 플레임 그래프 시각화 등이 있다.

지속적인 프로파일링은 시간 경과에 따라 추적을 캡쳐하는 프로파일링의 고급 버전이다.
이처럼 타임 스태프가 있는 추적이 수집되면 이를 가지고 도표를 그리거나 비교하며 관심있는 부분을 대상으로 깊숙이 알아볼 수 잇다.
eBPF 기반의 오픈 소스 프로젝트 parca가 아주 좋은 예다