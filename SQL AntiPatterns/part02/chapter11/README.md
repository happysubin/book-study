## chapter11. 31가지 맛


개인 연락처 정보 테이블에서, 호칭은 몇 가지 값만 갖는 칼럼의 좋은 예다.
Mr, Mrs, Dr, Rev를 지원하면 사실상 거의 모든 사람을 고려한 것이다.
이 목록을 데이터 타입이나 제약 조건을 이용해 칼럼 정의에 지정해, 이 salutation 칼럼에 실수로 다른 문자열이 입력되지 않도록 할 수 있다.

```sql
CREATE TABLE PersonalContacts (
	...
	salutation VARCHAR(4)
		CHECK (salutation IN ('Mr.', 'Mrs.', 'Ms.', 'Dr.', 'Rev.')),
)
```

문제가 없을 것 같아 보이지만 추후에 프랑스에 자회사를 설립하면서 'M.', 'Mme.', 'Mll.eh'도 지원해야 한다고 한다.

이런 값도 지원하도록 연락처 테이블을 변경하는 것이 과제다. 이것은 어려운 작업이다. 테이블에 대한 접근을 차단하지 않고는 불가능할 수도 있다. 

### 목표: 칼럼을 특정 값으로 제한하기

칼럼의 값을 고정된 집합의 값으로 제한하는 것은 매우 유용하다. 해당 칼럼이 유효하지 않은 항목을 절대로 포함하지 않는다고 보장할 수 있으면, 칼럼을 사용하는 것이 단순해진다.

예를 들어, 예제 데이터베이스의 Bugs 테이블에서 statUS 칼럼은 주어진 버그에 대해 NEW, IN PROGRESS, FIXED와 같은 값을 가진다. 이들 상태의 의미는 프로젝트에서 버그를 어떻게 관리하느냐에 따라 다르지만, 중요한 점은 status 칼럼에 들어가는 데이터는 이 값 중 하나여야 한다는 것이다.

유효하지 않은 값은 데이터베이스가 거부하는 것이 인상적이다.

### 안티패턴: 칼럼 정의에 값 지정

많은 사람들이 칼럼에 정의할 때 유효한 값을 지정한다. 칼럼 정의는 메타데이터, 즉 테이블 구조 정의의 일부다.

예를 들어, 칼럼에 CHECK 제약 조건을 정의할 수 있다. 이 제약조건은 제약 조건을 실패하게 하는 INSERT나 UPDATE를 허용하지 않는다.

MYSQL은 칼럼을 특정 값의 집합으로 제한하는, ENUM이라 불리는 비표준 데이터 타입을 지원한다.

값을 문자열로 선언하지만, 내부적으로는 열거된 목록에서 해당 문자열이 몇 번째인지를 나타내는 서수로 저장하도록 구혆되었다.
따랏서 저장 공간을 덜 차지하지만, 이 컬럼으로 정렬하면 문자열 값이 알파벳 순으로 정렬되지 않고 목록의 서수 값으로 정렬된다. 이런 동작은 기대하지 못했을 수 있다.

다른 방법은 도메인이나 사용자 정의 타입을 사용하는 것이다. 이를 이용해 칼럼에 미리 지정한 값만 허용하도록 제한하고, 동일한 도메인이나 데이터 타입을 데이터베이스 내 여러 칼럼에 적용할 수 있다. 그러나 이런 기능은 많은 관계형 DBMS 제품에서 아직 지원되지 않고 있다.

마지막으로 미리 허용된 값을 확인하고 다른 값이 들어오면 에러를 발생시키는 트리거를 사용할 수 있다.

이 모든 방법은 단점을 가지고 있는데, 이런 방법의 문제를 살펴보자.

#### 중간에 있는게 뭐지?

버그 추적 시스템의 사용자 인터페이스를 개발하고 있다고 가정하자. 사용자는 버그를 편집할 수 있다.
사용자가 유효한 상태 값 중 하나를 선택하게 하기 위해 이들 값을 드롭다운 메뉴 컨트롤에 채우기로 했다. 데이터베이스에 어떻게 쿼리하면 status 칼럼에 현재 허용되는 값의 목록을 얻을 수 있을까?

아마 다음과 같이 간단한 쿼리를 날려 현재 사용 중인 값을 얻으면 어떨까 생각할지도 모르겠다.
 
```sql
SELECT DISTINCT status FROM Bugs;
```

그러나, 모든 버그의 상태가 NEW라면 이 쿼리는 NEW만을 리턴한다.
이 결과를 버그 상태를 위한 사용자 인터페이스 컨트롤에 사용하면, 현재 사용중인 상태 이외의 다른 상태로 버그를 바꿀 수 없다.

status 허용된 값의 완전한 목록을 얻으려면, 칼럼의 메타데이터를 쿼리해야 한다. 대부분의 데이터베이스는 이런 종류의 쿼리를 위해 시스템 뷰를 제공하지만, 사용 방법은 복잡할 수 있다.

예를 들어 MYSQL에서 ENUM 데이터 타입을 사용했다면, INFORMATION_SCHEMA에 있는 시스템 뷰를 사용해 다음과 같이 쿼리할 수 있다.

```sql
SELECT column_type
FROM information_schema.columns
WHERE table_schema = 'bugtracker_scheman'
    AND table_name = 'bugs'
    AND column_name = 'status';
```

INFORMATION_SCHEMA로부터 각각의 열거 값을 일반적인 결과 집합에서와 같이 간단히 얻지는 못한다. 대신 체크 제약 조건 또는 ENUM 데이터 타입의 정의를 담은 문자열을 얻게 된다.

계속해서 체크 제약 조건, 도메인, 사용자 정의 타입을 확인해야 할 경우 쿼리는 점점 더 복잡해진다.

#### 새로운 맛 추가하기 

가장 흔한 변경은 허용된 값을 추가하거나 삭제하는 것이다. ENUM이나 체크 제약 조건에 값을 추가하거나 삭제하는 문법은 없다.
단지 새로운 값의 집합으로 칼럼ㅇ르 재정의할 수 있을 뿐이다. 다음은 MYSQL에서 ENUM에 새로운 상태 값 DUPLICATE를 추가하는 예다.

```sql
ALTER TABLE Bugs MODIFY COLUMN status
    ENUM ('NEW', 'IN PROGRESS', 'FIXED' ,'DUPLICATE');
```

* 칼럼의 이전 정의에서 NEW, IN PROGRESS, FIXED가 허용되었다는 사실을 알아야 하는데, 현재 허용되는 값의 집합을 조회하기가 어렵다는 문제로 돌아간다.
* 어떤 데이터베이스 제품에서는 테이블이 비어 있지 않으면 칼럼 정의를 변경할 수 없다.
* 어떤 제품에서는 데이터가 있는 상태에서 ALTER TABLE 명령을 실행해 테이블을 재구성하는 기능을 지원하지만, 여전히 복잡하고 비용이 많이 드는 작업이다.
* 정책적으로 메타데이터를 변경하는 것은, 즉 테이블이나 칼럼의 정의를 변경하는 것은 드물어야 하고 주의를 요해야 한다.

#### 예전 맛은 절대 없어지지 않는다.

* 값을 더 이상 사용되지 않게 만들면, 과거 데이터가 망가질 수 있다.
* ENUM에서 FIXED를 삭제하면, 상태가 FIXED인 버그는 어떻게 할 것인가?
* 상태가 FIXED인 버그를 VERIFIED로 바꿔야할까?
* 아니면 없어진 값을 NULL이나 디폴트 값으로 바꿔야할까?
* 없어질 값이라도 과거 행이 참조하는 한 그대로 유지해야할 수도 있다.
* 그러나 이런 경우에 더 이상 사용되지 않는 값을 어떻게 식별할 수 있을까?

#### 포팅이 어렵다

체크 제약 조건, 도메인, 사용자 정의 타입은 모든 SQL 데이터베이스 제품에서 균일하게 지원되는 기능이 아니다.
ENUM 데이터 타입은 MYSQL의 고유한 기능이다.


### 안티패턴 인식 방법

ENUM이나 체크 제약조건의 문제는 값의 집합이 고정되지 않았을 때 나타난다. ENUM 사용을 고려하고 있다면 먼저, 값의 집합이 변할 것 같은지 스스로에게 물어보기 바란다. 변할 것 같다면 ENUM을 사용하지 않는 것이 좋다.

* 데이터베이스를 내려야 애플리케이션 메뉴의 선택항목을 추가할 수 있어. 길어야 30분이면 충분할거야. 모든게 잘 되면 말이지.
* status 칼럼은 다음 값중 하나만 가질 수 있어. 이 목록을 바꿀 일이 생기면 안 돼.
* 애플리케이션 코드에 있는 목록 값이 데이터베이스에 있는 비즈니스 규칙과 또 틀어졌어

### 안티패턴 사용이 합당한 경우

집합이 변하지 않는다면 ENUM을 사용해도 문제가 없다.

### 해법: 데이터로 값을 저장하기

칼럼 값을 제한하는 것보다 더 좋은 방법이 있따. Bugs.status 칼럼에 들어갈 수 있는 각 값을 행으로 하는 색인 테이블을 만드는 것이다. 그리고 Bugs.status가 새로 만든 테이블을 참조하도록 FK 제약조건을 선언한다.
```sql
CREATE TABLE BugsStatsu (
    status VARCHAR(20) PRIMARY KEY
);

INERT INTO BugStatus (status) VALUES('NEW'), ('IN PROGRESS'), ('FIXED');

CREATE TABLE Bugs (
    ...
    status VARCHAR(20),
    FOREIGN KEY (status) REFERENCES BugStatus(status)
        ON UPDATE CASCADE
);


```
Bugs 테이블에 행을 삽입하거나 업데이트할 때, status 칼럼의 값은 BugStatus 테이블에 있는 값을 사용해야 한다.
이렇게 하면 ENUM이나 체크 제약조건처럼 status값을 제한할 수 있다. 그리고 이 방법은 몇 가지 유연성을 제공한다.

#### 값의 집합 쿼리하기

위의 복잡한 색인 테이블 조회 코드와 비교하면 색인 테이블의 조회가 매우 쉬워진다.

```sql
SELECT status FROM BugStatus ORDER BY status;
```

#### 색인 테이블의 값 갱신하기

색인 테이블을 사용하면, 평범한 INSERT 문으로 값을 추가할 수 있다. 테이블에 대한 접근을 제한하지 않고도 이런 변경을 할 수 있다.

```sql
INSERT INTO BugStatus(status) VALUES ('DUPLICATE');
```

FK를 ON UPDATE CASCADE 옵션과 함께 선언했따면, 값의 이름도 쉽게 바꿀 수 있다.

```sql
UPDATE BugStatus SET status = 'INVALID' WHERE status = 'BOGUS';
```

#### 더 이상 사용하지 않는 값 지원하기

Bugs에 있는 행이 참조하는 한, 색인 테이블에서 행을 삭제할 수는 없다.
status 칼럼의 FK가 참조 정합성을 강제하므로, 색인  테이블에 값이 존재해야 한다.

그러나 색인 테이블에 또 다른 속성 컬럼을 추가해 더 이상 사용되지 않는 값을 표시할 수 있다.
이렇게 하면 Bugs.status 칼럼의 과거 데이터를 유지하는 동시에, 사용자 인터페이스에 표시되어야 할 값과 더 이상 사용하지 않는 값을 구분할 수 있게 된다.


```sql
ALTER TABLE BugStatus ADD COLUMN active
    ENUM ('INACTIVE', 'ACTIVE') NOT NULL DEFAULT 'ACTIVE';
```

값을 DELETE 하는 대신 더 잇아 사용되지 않는ㄷ다고 표시하기 위해 UPDATE 한다.

```sql
UPDATE BugStatus SET actvie = 'INACTIVE' WHERE status = 'DUPLICATE';
```

사용자 인터페이스에 표시할 값의 집합을 얻을 때는 ACTIVE인 값을 조회하면 된다.

```sql
SELECT status FROM BugStatus WHERE active = 'ACTIVE';
```

이 방법은 ENUM이나 체크 제약 조건을 사용하는 방법보다 훨씬 융튱성 있다. ENUM이나 체크 제약 조건은 값에 별도의 속성을 추가할 수 없기 때문이다.

#### 포팅이 쉽다

FK 제약조건을 사용한 참조정합성이란 표준 SQL 기능만 사용한다. 따라서 포팅이 쉬워진다.

또한 각 값을 별도의 행으로 저장하기 때문에 색인테이블에는 사실상 무한한 개수의 값을 저장할 수 있다.

