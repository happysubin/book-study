## chapter05. 키가 없는 엔트리


### 데이터베이스 아키텍처 단순화

관계형 데이터베이스 설계는 각 테이블 자체에 대한 것이기도 하고 테이블간의 관계에 대한 것이기도 하다.

참조 정합성은 데이터베이스를 적절히 설계하고 운영하는 데 있어 중요한 부분이다.

어떤 칼럼 또는 칼럼 묶음에 FK 제약조건을 선언하면, 그 칼럼에 들어가는 값은 부모 테이블의 PK 또는 유일키에 존재해야 한다.

그러나 다양한 개발자들이 참조 정합성 제약조건을 사용하지 마라고 하는데, 보통 아래와 같은 이유를 말한다.

1. 데이터 업데이트 시 제약조건과 충돌할 수 있다.
2. 참조 정합성 제약조건을 지원할 수 없는 매우 융튱성 있는 데이터베이스를 사용하고 있다.
3. FK에 데이터베이스가 자동생성하는 인덱스 때문에 성능에 영향을 받는다고 믿는다.
4. FK를 지원하지 않는 데이터베이스를 사용하고 있다.
5. FK 선언을 위해 문법을 찾아봐야 한다.

### 안티패턴: 제약 조건 무시

FK 제약조건을 생략하는 것이 처음에는 데이터베이스 설계를 단순하고 유연하고 빠르게 하는 것처럼 보이겠지만, 다른 방식으로 대가를 치러야 한다.
참조 정합성을 보장하기 위한 코드를 직접 작성해야 하는 책임을 떠안아야 하기 때문이다.

#### 무결점 코드

많은 사람들이 참조 정합성을 위해 애플리케이션 코드르 작성해 데이터 관계를 만족시키려 한다.

행을 삽입할 때마다, FK 칼럼의 값이 참조하는 테이블에 존재하는 값인지를 확인해야 한다.

행을 삭제할 때마다, 자식 테이블이 적절히 업데이트 되는 지 확인해야 한다.

쉽게 말하면, __실수를 하지 않아야 한다__

FK, 제약조건을 사용하지 않고 참조 정합성을 만족하기 위해서는, 변경하기 전에 별도의 SELECT 쿼리를 실행해 해당 변경이 참조 정합성을 깨드리지 않는지 확인해야 한다.

예를 들어 보자. 검증을 진행한 후, 삭제하기 전에 유저가 들어와 새로운 버그를 입력하면 어떻게 될까?

이런일은 발생할 것 같지 않겠지만, 분명히 깨진 참조가 생길 수 있다.

유일한 해결책은 확인하기 전에 Bugs 테이블을 잠금 설정하고 계정을 삭제한 후에 잠금을 해제하는 것이다.

이런 식의 잠금을 필요로 하는 아키텍처는 높은 동시성과 확장적응성이 필요한 환경에서는 제대로 동작하지는 않는다.

#### 오류 확인

책 초반부에 보면 손상된 데이터를 찾기 위해 스크립트를 돌려서 손상된 데이터를 이메일로 보내주는 로직이 있었다.

예를 들어 버그 테이블에서 statsu 칼럼은 버그상태 색인 테이블을 참조한다.

유효하지 않은 상태를 가진 버그를 찾기 위해 다음과 같은 쿼리를 사용할 수 있다.

```sql
SELECT b.bug, b.status
FROM Bugs b LEFT OUTER JOIN BugStatus s
    ON (b.status = s.status)
WHERE s.status IS NULL;
```

이와 비슷한 쿼리를 데이터베이스 내 모든 참조 관계에 대해 작성해야 함을 짐작할 수 있다. 

매우 귀찮은 잡일이고, 깨진 참조를 발견했을 때 올바르게 정정하기 힘들 때도 있을 것이다.

#### 내 잘못이 아냐!

데이터베이스는 일관성 있게 유지해야 한다.

데이터베이스 내 모든 참조가 항상 유효해야 한다. 그러나 데이터베이스에 접근하는 모든 애플리케이션과 스크립트가 올바르게 변경을 가하는지 확신할 수 없다.

> 대부분의 비즈니스 로직이 검증인데, 그럼 비즈니스 로직 코드를 잘못 짠 것이라는 의미?

#### 진퇴양난 업데이트

많은 개발자가 여러 테이블의 관련된 칼럼을 업데이트할 때 불편해지기 때문에 FK 제약 조건을 꺼린다.

예를 들어, 다른 행이 의존하는 어떤 행을 삭제해야 할 때, FK 제약조건을 위반하지 않기 위해 자식 행을 먼저 삭제해야한다.

자식 테이블마다 한 번씩 여러 문장을 손수 실행시켜야 한다. 나중에 개선을 위해 데이터베이스에 자식 테이블을 추가한다면, 새로 추가한 테이블의 행도 삭제하도록 코드를 수정해야 한다.
그러나 이 정도 문제는 해결할 수 있다.

해결할 수 없는 문제는 자식 행이 참조하고 있는 컬럼을 UPDATE하려 할 때 발생한다. 부모를 업데이트하기 전에는 자식 행을 업데이트할 수 없고, 자신을 참조하는 자식 행을 업데이트하기 전에는 부모를 업데이트할 수 없다.

둘을 동시에 변경해야 하지만, 두 개의 분리된 업데이트 문으로는 이렇게 하기가 불가능하다. 이러지도 저러지도 못하는 상황이 발생한다.

대부분의 개발자들이 이런 상황을 어렵다고 생각해 아예 FK를 사용하지 않기로 결정해버린다.


### 안티패턴 인식 방법

1. 어떤 값이 한 테이블에는 있고 다른 테이블에는 없는지 확인하려면 쿼리를 어떻게 작성해야 하지?? -> 보통 부모가 업데이트되거나 삭제되어 고아가 된 자식 행을 찾으려는 것이다.
2. 테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지를 확인하는 빠른 방법이 없을까? -> 부모행이 존재하는지를 확인하려는 것이다. FK가 이를 자동으로 확인해주며, 효율적으로 확인하기 위해 부모 테이블의 인덱스를 활용한다.
3. FK?라고 FK는 데이터베이스를 느리게 만들기 때문에 사용하지 말라고 들었는데?

### 안티패턴이 합당한 경우

FK 제약조건을 지원하지 않는 데이터베이스를 사용할 때.

관계를 모델링할 때 FK를 사용할 수 없는 극단적으로 유연한 데이터베이스 설계도 있다. 전통적인 참조 정합성 제약조건을 사용할 수 없다면, 이는 다른 SQL 안티패턴이 사용되고 있음을 나타내는 강력한 징후다.

이는 6장과 7장에서 살펴본다.

### 해법: 제약 조건 선언하기

제약 조건을 사용하면 처음부터 잘못된 데이터가 입력되지 않도록 할 수 있다.

FK를 사용하면 불필요한 코드를 작성하지 않아도 되고, 데이터베이스를 변경할 때도 모든 코드가 동일한 제약 조건을 따른다는 것을 확인할 수 있다.

> 코드 1000라인 당 평균 15 ~ 50개의 버그가 소프트웨어 업계 평균 수치라고 한다. 띠용

#### 여러 테이블 변경 지원

FK는 애플리케이션 코드로 흉내 낼 수 없는 다른 기능이 있다.
단계적 업데이트다. __Cascading update__

```
CREATE TABLE Bugs (
    ...
    reported by BIGINT UNSIGNED NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'NEW',
    FOREIGN KEY (reported_by) REFERENCES Accounts(account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
    FOREIGN KEY ( status ) REFERENCES BugStatus(status)
        ON UPDATE CASCADE
        ON DELETE SET DEFAULT
);
```

위 방법은 부모 행을 업데이트 또는 삭제할 경우 데이터베이스가 해당 부모를 참조하는 자식 행을 알아서 처리해준다.
부모 테이블인 BugStatus나 Accounts를 업데이트하면 Bugs에 있는 자식 행까지 자동으로 업데이트된다.

ON UPDATE 또는 ON DELETE 절을 선언하는 방식에 따라 단계적 작업의 결과를 제어할 수 있다. 

> 예를 들어, reported by에 걸린 FK의 RESTRICT는 Bugs의 행이 참조하는 한 계정을 삭제할 수 없음을 말한다.
> 제약 조건이 삭제를 막고 에러를 발생시킨다. 반면 status 값을 삭제하는 경우, 해당 상태였던 버그들이 모두 디폴트 상태 값으로 자동으로 재설정된다.

어느 경우든 데이터베이스는 두 테이블을 자동으로 변경한다. FK 참조는 변경 전이나 변경 후 모두 만족한다.

#### 오버헤드

1. 데이터 insert 전에 select보다 그냥 FK 제약조건이 성능이 낫다.
2. 여러 테이블을 변경하기 위해 테이블 잠금을 사용할 필요가 없다. (?)
3. 불필요하게 생기는 고아 데이터를 정정하기 위해 품질 제어 스크립트를 주기적으로 돌릴 필요가 없다.