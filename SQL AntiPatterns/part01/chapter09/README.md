## chapter09. 메타데이터 트러블

다음과 같은 Customers 테이블이 있다.

고객의 연락처 정보, 그들의 사업 형태, 해당 고객으로부터 발생한 매출 같은 데이터가 저장되어 있다.

```sql
CREATE TABLE Customers (
    customer_id NUMBER(9) PRIMARY KEY,
    contact_info VARCHAR(255),
    business_type VARCHAR(20),
    revenue     NUMBER(9,2)
);
```

최근에 활동적인 고객을 추적할 수 있도록 매출을 연도별로 나눠야 할 필요가 생겼다.

그들은 각 컬럼 이름이 연도별 매출을 나타내는 일련의 칼럼을 새로 추가하기로 결정했다.

```sql
ALTER TABLE Customers ADD (revenue2002 NUMBER(0,2));
ALTER TABLE Customers ADD (revenue2003 NUMBER(0,2));
ALTER TABLE Customers ADD (revenue2004 NUMBER(0,2));
```

그 후 이들은 추적이 필요한 고객들에 대해서만 데이터를 입력했다. 이 연도별 매출 칼럼의 값은, 데이터를 불완전하게 입력했기 때문에, 대부분의 행에서 NULL로 남겨졌다. 프로그래머들은 이렇게 대부분이 사용되지 않는 칼럼을 다른 정보로 저장할 수는 없을까 궁리하기 시작했다.

그들은 매년 칼럼을 하나씩 추가해야 했고, 매년 회의를 하고 새로 구성한 테이블 스페이스로 데이터 이관 계획을 세우고, 새로운 칼럼을 추가했다. 굉장한 리소스 낭비다.

### 목표: 확장성 지원

데이터 양이 늘어나면 어떤 데이터베이스든 쿼리든 성능이 떨어진다. 쿼리가 수천행을 곧바로 리턴한다 해도, 테이블에는 보통 동일한 쿼리의 성능이 받아들일 수 없을 정도가 될 때까지 계속해서 데이터가 쌓이게 마련이다. 인덱스를 잘 이해하고 사용하면 도움이 되지만, 그래도 테이블의 데이터는 계속 늘어날테고, 이는 쿼리 성능에 영향을 준다.

__목표는 쿼리 성능을 향상시키고 지속적으로 크기가 늘어나는 테이블을 지원하도록 데이터베이스를 구상하는 것이다.__


### 안티패턴: 테이블 또는 컬럼 복제


다른 모든 조건이 동일하다면, 행이 적은 테이블을 조회하는 것이 행이 많은 테이블을 조회하는 것보다 빠르다는 사실을 경험을 통해 안다.
이는 우리가 어떤 작업을 해야 하든 모든 테이블이보다 적은 행을 포함하도록 만들어야 한다는 그릇된 생각을 하게 만든다.

그리고 두 가지 형태의 안티패턴으로 나타난다.

* 많은 행을 가진 큰 테이블을 여러 개의 작은 테이블로 분리한다. 작은 테이블의 이름은 테이블의 속성 중 하나의 값을 기준으로 해서 짓는다.
* 하나의 컬럼을 여러 개의 칼럼으로 분리한다. 칼럼 이름은 다른 속성의 값을 기준으로 해서 짓는다.

#### 테이블이 우글우글

데이터를 분리해 별도의 테이블에 넣으려면, 어떤 행을 어떤 테이블로 보낼지 결정하는 정책이 필요하다.
예를 들어, date_reported 칼럼의 연도를 사용해 데이터를 분리할 수 있다.

```sql
CREATE TABLE Bugs_2008 (...);
CREATE TABLE Bugs_2009 (...);
CREATE TABLE Bugs_2010 (...);
```

데이터베이스에 행을 삽입할 때 삽입하는 값에 따라 올바른 테이블을 사용하는 것은 사용자 책임이다.

```sql
INSERT INTTO Bugs_2010(..., date_reported, ...)
VALUES(..., '2010-06-01', ...);
```

다음해 1월 1이 됐따. 새로운 버그를 입력할 때 애플리케이션에서 에러가 발생한다. Bugs_2011 테이블을 생성하는 것을 까먹었기 때문이다.

```sql
INSERT INTO Bugs_2011 (..., date_reported, ...)
VALUES (..., '2011-02-20', ...);
```

새로운 데이터 값이 들어오면 새로운 메타데이터 객체가 필요하다는 뜻이다.
보통 이런 것은 SQL에서 데이터와 메타데이터 사이에 있는 관계가 아니다.

#### 데이터 정합성 관리 

한해동안 보고된 버그 개수를 세려하는데, 숫자가 들어맞지 않는다. 아로보니 2010년 버그가 실수로 2009년에 입력되어 있는 것이다.

이런 설계가 바람직한 방법은 아니지만 사전에 이런 실수를 막을 수 있는 방법이 존재한다.

```sql
CREATE TABLE Bugs_2009 (
    ...
    date_reported DATE CHECK (EXTRACT(YEAR FROM date_reported) = 2009)
)

CREATE TABLE Bugs_2010 (
    ...
    date_reported DATE CHECK (EXTRACT(YEAR FROM date_reported) = 2010)
)
```


#### 데이터 동기화

고객지원 분석가가 어떤 버그의 보고 일자를 변경해달라고 요청했다. 
데이터베이스에는 버그 보고일자가 2010-01-03으로 되어 있지만, 실제로는 버그를 보고한 고객이 팩스로 그보다 한 주 전인 2009-12-27에 보내온 것이다. 간단한 UPDATE로 날짜를 바꿀 수 있어야 한다.

```sql
UPDATE Bugs_2010
SET date_reported = '2009-12-27'
WHERE bug_id = 1234;
```

그러나 2009와 2010은 테이블이 다르므로 2010에서 데이터를 삭제하고 삭제한 데이터의 내용을 기반으로 2009 테이블에 데이터를 INSERT 해야 한다.

#### 유일성 보장

PK 값은 모든 분할된 테이블에 걸쳐 유일함이 보장되어야 한다. 한 테이블에서 다른 테이블로 행을 옮겨야 하면, PK 값이 다른 행과 충돌하지 않는다는 확신이 있어야 한다.

시퀀스 객체를 지원하는 데이터베이스를 사용한다면, 키 값 생성을 위해 모든 분리된 테이블에 대해 하나의 시퀀스를 사용할 수 있다.

테이블당 Id 유일성만을 보장하는 데이터베이스에서는 조금 까다로워진다. PK 값 생성만을 위한 별도 테이블을 하나 정의해야 한다.

#### 여러 테이블에 걸쳐 조회하기

불가피하게 여러 테이블에 걸쳐 조회할 필요가 생겼다. 예시로 연도 상관없이 오픈된 순간부터의 모든 버그 개수를 알려달라는 것이다.

그러면 아래와 같이 모든 테이블을 UNION으로 묶어 전체 집합으로 재구성한 다음 여기에 대해 쿼리를 실행할 수 있다.

```sql
SELECT b.status, COUNT(*) AS count_per_status FROM (
    SELECT * FROM Bugs_2008 
        UNION ALL
    SELECT * FROM Bugs_2009 
        UNION ALL
    SELECT * FROM Bugs_2009 ) AS b
GROUP BY b.status;
```

2011 년도가 되면 그에 알맞게 쿼리를 수정해줘야 한다.

#### 메타 데이터 동기화

상사가 각 버그를 해결하는데 필요한 시간을 추적하기 위한 칼럼을 추가하록 한다.

```sql
ALTER TABLE Bugs_2010 ADD COLUMN hours NUMERIC(9,2);
```

테이블을 분리했다면, 새 칼럼은 변경한 테이블 하나에만 적용된다. 다른 테이블에는 새로운 칼럼이 없다.

위에서 살펴본 것처럼 UNION을 사용하면 2009, 2008에는 위에서 만든 칼럼이 ㅇ벗으므로 문제가 생긴다.

칼럼이 다르면 와일드카드를 사용할 수 없고 공통되는 칼럼의 이름을 나열해야 한다.

#### 참조 정합성 관리

Comments와 같은 종속 테이블이 Bugs를 참조한다면, 종속 테이블에서 FK를 선언할 수 없게 된다.
FK에는 하나의 테이블을 지정해야 하는데, 이 경우에는 부모 테이블이 여러 개로 분리되어 있기 때문이다.

```sql
CREATE TABLE Comments (
    comment_id SERIAL PRIMARY KEY,
    bug_id BIGINT UNSIGNED NOT NULL,
    FOREIGN KEY (bug_id) REFERENCES Bugs_????(bug_id)
)
```

분리된 테이블은 부모일 때뿐 아니라 자식이 될 때도 문제가 있다.

예를 들어, Bugs.reported_by는 Accounts 테이블을 참조한다. 연도에 상관없이 주어진 사용자가 보고한 모든 버그를 보려 한다면, 다음과 같이 쿼리를 작성해야 한다.

```sql
SELECT * FROM Accounts a
JOIN (
    SELECT * FROM Bugs_2008
    UNION ALL
    SELECT * FROM Bugs_2009
    UNION ALL
    SELECT * FROM Bugs_2010
) t ON (a.account_id = t.reported_by)
```

#### 메타데이터 트리블 칼럼 식별하기

버그 데이터베이스에 프로젝트의 상태의 요약정보를 기록하는데 테이블을 만들어 각 칼럼에 소계를 저장할 수 있다. 
즉 다음과 같은 테이블에서 bugs_fixed_2011이 필요해지는 것은 시간 문제일 뿐이다.

```sql
CREATE TABLE ProjectHistory (
    ...
    bugs_fixed_2008 INT,
    bugs_fixed_2009 INT,
    bugs_fixed_2010 INT,
)
```

### 안티패턴 인식 방법

매일 사용하는 데이터와 오래된 데이터를 분리해 별도 보관하는 방식으로 테이블 수동 분할을 사용할 수 있다.

일정 시간이 지난 오래된 데이터를 조회할 필요가 크게 줄어드는 것은 종종 있는 일이다.

현재 데이터와 오래된 데이터를 함께 조회할 필요가 없다면, 오래된 데이터를 다른 위치로 옮기고 해당 테이블에서 삭제하는 것이 적절하다.

가끔씩 필요한 분석을 위해 오래된 데이터를 동일한 테이블 구조로 별도 보관하면 현재 데이터에 대한 쿼리 성능도 훨씬 좋아질 수 있다.

### 안티패턴 인식 방법

* 그러면 우리는 ~당 테이블(또는 칼럼)을 생성해야해
* 이 데이터베이스에 테이블을 최대 몇 개까지 만들 수 있을까?
* 오늘 아침에 애플리케이션이 새로운 데이터를 추가하는데 실패한 이유를 알아냈어. 새헤에 대한 테이블을 만드는 걸 까먹었지 뭐야.
* 어떻게 하면 여러 테이블을 한꺼번에 검색하는 쿼리를 작성할 수 있을까? 모든 테이블은 같은 컬럼을 가지고 있어
* 어ㄸ허게 하면 테이블 이름을 파라미터로 넘길 수 있을까? 테이블 이름 뒤에 연도를 동적으로 붙여서 쿼리를 해야해

### 해법: 파티션과 정규화

테이블이 매우 커졌을 때, 테이블을 직접 분리하는 것보다 성능을 향상시키는 더 좋은 방법이 있다.

여기에는 수평 분할, 수직 분할, 종속 테이블을 사용하는 방법이 포함된다.

#### 수평 분할

수평 분할이라 불리는 기능을 사용하면 큰 테이블을 분리했을 때의 단점 없이 장점만 살릴 수 있다.

행을 여러 파티션으로 분리하는 규칙과 함께 논리적 테이블을 하나 정의하면 나머지는 데이터베이스가 알아서 해준다.

물리적으로는 테이블이 분리되어 있지만, SQL에서는 마치 하나의 테이블인 것처럼 사용할 수 있다.

융튱성도 있어서, 각 테이블에서 자신의 행을 별도 스토리지로 분리하는 방식도 정의할 수 있다.


#### 수직 분할 

수평 분할이 테이블을 행으로 나누는데 반해, 수직 분할은 칼럼으로 테이블을 나눈다.

칼럼으로 테이블을 나누는 방법은 크기가 큰 칼럼이나 거의 사용되지 않는 칼럼이 있을 때 유리하다.

BLOB와 TEXT칼럼은 크기가 가변적이고 매우 커질 수 있다. 많은 데이터베이스 제품이 스토리지 효율과 조회 효율 모두를 위해 이런 데이터 타입의 칼럼을 다른 칼럼과 분리해 저장한다. 해결책은 역시나 종속 테이블을 만드는 것이다.

#### 메타 데이터 증식 문제

메타데이터 증식 문제의 해결 방법도 종속 테이블을 만드는 것이다.

```sql
CREATE TABLE ProjectHistory (
    project_id BIGINT,
    year SMALLINT,
    bugs_fixed INT,
    PRIMARY KEY (project_id, year),
    FOREIGN KEY (project_id) REFERENCES Projects(project_id)
);
```

프로젝트 하나를 한 행으로 하고 연도별 칼럼을 사용하는 대신, 수정된 버그 개수를 한 컬럼에 여러 개의 행으로 저장하는 것이 좋다.

이런 식으로 테이블을 정의하면, 해가 바뀌더라도 새로운 칼럼을 추가할 필요가 없다. 이 테이블에는 프로젝트에 대해 얼마든행을 저장할 수 있다.