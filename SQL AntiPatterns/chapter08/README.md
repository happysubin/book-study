## chapter08. 다중 컬럼 속성

전화번호에 관한 테이블을 설계하면 약간 까다롭다.

사람들은 여러 개의 전화번호를 사용한다. 집 전화번호, 회사 전화번호, 팩스 번호, 휴대폰 번호가 일반적이다.

그러나 다른 번호는 어떡할까? 개인용 단말기 번호나 보조 휴대폰, 현장 사무실, 그리고 예상치 못한 다른 범주가 있을 수 있다.

이런 덜 일반적인 경우에 대해서도 칼럼을 만들 수 있지만, 데이터 입력 양식에 거의 사용되지 않는 필드를 추가해야 하므로 지저분해 보인다.

칼럼이 얼마나 많아야 충분할까?

### 목표: 다중 값 속성 저장

예제는 다음과 같다.

버그 데이터베이스에 태그를 허용해 버그를 분류하고 싶다.. 어떤 버그는 인쇄, 리포트, 이메일과 같이 해당 버그가 영향을 미치는 소프트웨어 서브시스템에 따라 분류될 것이다. 어떤 버그는 결함의 성질에 따라 분류될 수도 있다. 예를 들어 프로그램이 죽는 버그는 crash 태그를 달고, 속도가 느린 문제는 performance 태그를 달고, 사용자 인터페이스에서 색상 선택이 부적절하다면 cosmetic 태그를 달 수 있다.

태그는 상호 배타적일 필요가 없기 때문에 여러 태그를 다는 것도 가능해야 한다. 어떤 결함은 여러 시스템에 영향을 미치거나 인쇄 속도에 영향을 줄 수 있다.

### 안티패턴: 여러 개의 칼럼 생성

속성에 여러 값이 들어가는 것을 고려해야 하지만, 각 칼럼에는 하나의 값만을 저장해야 한다는 것을 안다.
테이블에 여러 개의 칼럼을 만들고 각 컬럼에 하나의 태그를 저장하게 하는 것이 자연스러워 보인다.

```sql
CREATE TABLE Bugs (
    bug_id SERIAL PRIMARY KEY,
    description VARCHAR(1000),
    tag1 VARCHAR(20),
    tag2 VARCHAR(20),
    tag3 VARCHAR(20)
)
```

주어진 버그에 태그를 달 때, 이 세 칼럼 중 하나에 값을 넣는다. 사용되지 않는 칼럼은 null인 상태로 남는다.

```sql
UPDATE Bugs SET tag2 = 'performance' WHERE bug_id = 3456;
```

#### 값 검색

주어진 태그를 가진 버그를 찾으려면 세 칼럼 모두를 확인해야 한다. 셋 중 어느 칼럼에 태그 문자열이 있는지 알 수 없기 때문이다.

예를 들어, performance 태그를 가진 버그를 조회하려면 다음과 같은 쿼리를 사용해야 한다.

```sql
SELECT * FROM Bugs
WHERE tag1 = 'performance'
    or tag2 = 'performance'
    or tag3 = 'performance'
```

performance와 printing 두 태그를 모두 가진 버그를 찾아야할 수도 있다.

이를 위해서는 다음과 같은 쿼리를 사용해야 한다. OR는 AND보다 우선순위가 낮기 때문에 괄호 사용에 주의해야 한다.

```sql
SELECT * FROM Bugs
WHERE (tag1 = 'performance' OR tag2 = 'performance' OR tag3 = 'performance' ) 
    AND (tag1 = 'printing' OR tag2 = 'printing' OR tag3 = 'printing');
```

여러 칼럼에서 하나의 값을 찾기 위한 쿼리는 길이도 길고 지루해 보인다.
전통에서 살짝 벗어난 방법으로 IN을 사용하면 좀 더 간결하게 만들 수 있다.

```sql
SELECT * FROM Bugs
WHERE 'performance' IN (tag1, tag2, tag3)
    AND 'printing' IN (tag1, tag2, tag3)
```

#### 값 추가와 삭제

칼럼 집합에 값을 추가하거나 삭제하는 것도 문제다. 어느 칼럼이 비어있는지 알 수 없기 때문에 단순히 UPDATE를 사용해 칼럼 중 하나를 변경하는 것은 안전하지 않다. 확인을 위해 애플리케이션에서 해당 행을 조회해야할 것이다.

```sql
SELECT * FROM Bugs WHERE bug_id = 12345;
```

이렇게 조회를 해서 tag2 가 null인 것을 확인해야 UPDATE 문을 만들 수 있다.

```sql
UPDATE Bugs SET tag2 = 'performance' WHERE bug_id = 3456; 
```

테이블을 조회하고 업데이트하는 동시성 문제가 생길 수 있다. (누가 덮어씀)

NULLIF 함수를 사용해 동시성 문제를 피할 수도 있다. 물론 애플리케이션에서 분산 락을 사용할 수도 있고

#### 유일성 보장

여러 칼럼에 동일한 값이 나타나지 않게 하고 싶겠지만, 다중 칼럼 속성 안티 패턴을 이용하는 경우에는 데이터베이스에서 이를 예방하지 못한다.

#### 값의 증가 수 처리

칼럼 3개가 부족하다면 어떻게 해야 할까?

테이블을 정의하는 시점에 태그의 최대 개수가 얼마나 될지 어떻게 예측할 수 있을까?

생각할 수 있는 방법은 처음에 적당한 개수의 칼럼을 만들고 갈수록 추가하는 것이다.

그러나 이는 다음과 같은 이유로 비용이 많이 든다.

* 이미 데이터를 포함하고 있는 데이터베이스 테이블 구조를 변경하려면 테이블 전체를 잠금 설정하고 다른 클라이언트의 접근을 차단하는 과정이 필요하다.
* 어떤 데이터베이스는 희망하는 구조의 새로운 테이블을 정의해 예전 테이블에서 모든 데이터를 복사한 다음 예전 테이블을 삭제하는 식으로 테이블 변경을 구현한다. 테이블에 많은 데이터가 쌓여 있다면 작업에 많은 시간이 걸린다.
* 다중 칼럼 속성의 집합에 칼럼을 추가한 경우, 모든 애플리케이션에서 이 테이블을 참조하는 모든 SQL문을 확인해 새로운 칼럼을 지원하도록 수정해야 한다.

### 안티패턴 인식 방법

사용자 인터페이스나 문서에 여러 개의 값을 할당할 수 있지만 최대 개수가 제한되어 있는 속성이 기술되어 있다면, 다중 칼럼 속성 안티패턴이 사용되고 있음을 나타내는 것으로 볼 수 있다.

이 안티패턴이 사용되고 있음을 나타내는 다른 징조는 다음과 같은 말이 들릴 때다

* 태그를 최대 몇 개까지 붙일 수 있도록 지원해야 하지? -> 다중 값 칼럼을 정의 하기 위함
* SQL에서 여러 칼럼을 한꺼번에 검색하려면 어떻게 해야 하지? -> 주어진 값을 여러 컬럼에 걸쳐 검색해야 한다면, 이들 칼럼은 실제로 하나의 논리적 속성으로 저장되어야 함을 나타낸다.

### 안티패턴 사용이 합당한 경우

__어떤 경우는 속상의 개수가 고정되고 선택의 위치나 순서가 중요할 수 있다.__

예를 들어, 주어진 버그가 여러 사용자 계정과 연관될 수 있지만, 각 연관은 본질적으로 유일할 수 있다. 하나는 버그를 보고한 사용자, 다른 하나는 버그 수정을 위해 할당된 프로그래머, 나머지는 수정을 검증하기 위해 할당된 QA 담당자가 될 수 있다. 각 칼럼에 들어가는 값은 같은 종류지만, 그 의미와 사용처가 달라 논리적으로 다른 속성이 된다.


### 해법: 종속 테이블 생성

가장 좋은 해법은 다중 값 속성을 위한 칼럼을 하나 가지는 종속 테이블을 만드는 것이다.

여러 개의 값을 여러 개의 칼럼 대신 여러 개의 행에 저장하는 것이다. 또한 종속 테이블에 FK를 정의해 해당 값이 Bugs 테이블의 부모 행과 연관되도록 한다.

```sql
CREATE TABLE Tags (
    bug_id BIGINT UNSIGNED NOT NULL,
    tag VARCHAR(20),
    PRIMARY KEY (bug_id, tag),
    FOREIGN KEY (bug_id) REFERENCES Bugs(bug_id)
);
```

하나의 버그에 연관된 모든 태그가 한 칼럼에 있으면, 주어진 태그에 대한 버그를 검색하는 작업이 좀 더 직관적이게 된다.

```sql
SELECT * FROM Bugs JOIN Tags USING (bug_id)
WHERE tag = 'performance'l
```

두 개의 태그가 붙은 버그를 찾는 것과 같은, 보다 복잡한 작업도 쉽게 처리할 수 있다.

```sql
SELECT * FROM Bugs
    JOIN Tags AS t1 USING (bug_id)
    JOIN Tags AS t2 USING (bug_id)
WHERE t1.tag = 'printing' AND t2.tag = 'performance';
```

연관을 추가하고 삭제하기도 다중 칼럼 안티패턴을 사용할 때보다 훨씬 쉬워진다. 단순히 종속 테이블에 행을 추가하거나 삭제하면 된다.

PK 제약조건은 중복이 허용되지 않음을 보장한다. 주어진 태그는 특정 버그에 한 번만 적용될 수 있다. 중복된 태그 적용을 시도하면 SQL 실행 시 에러가 발생한다.

버그에 필요한만큼 갯수 제한 없이 태그를 적용할 수 있다.