
# 1장 연관관계

## 항목 1. @OneToMany 연관관계를 효과적으로 구성하는 방법

1. 단방향 @OneToMany 사용 X
2. 항상 부모(일) 자식(다) 측으로 전이를 사용(커스케이드)
3. 부모 측에 mappedBy 지정
4. 부모 측에 orphanRemoval 지정
5. 만약 양방향 연관 관계면 연관 관계의 양측을 동기화 상태로 유지(연관관계 편의 메서드)
6. 글로벌 지연로딩 전략 활용
7. equals와 hashCode 오버라이딩
8. @JoinColumn을 사용해 명시적으로 지정

자식 엔티티 삭제처리는 많은 SQL문이 생성될 수 있으므로 주의. 벌크 처리를 하는 것이 가장 좋은 방법.

## 항목 2. 단방향 @OneToMany 연관관계를 피해야 하는 이유

더 많은 쿼리가 발생하므로 비효율적

> 참고 OrderColumn으로 연관관계(List) 정렬 가능

다 관계인 엔티티가 연관관계의 주인이면 안된다.

## 헝목 3. 단방향 @ManyToOne의 효율성

쓸데 없는 쿼리가 나가지 않으며 효율적. chapter01에서 OneToMany 부분만 지우면 됨.

## 항목 4. @ManyToMany 연관 관계를 효율적으로 구성하는 법

걍 별도의 중간 엔티티를 정의하자.

* 연관관계의 주인을 선택해야한다.
* List가 아닌 Set 사용
* 연관관계의 양측 동기화 상태 유지
* CascadeType.All 및 CascadeType.REMOVE 사용하지 않기. 대부분의 경우 PERSISTE와 MERGE를 사용하자.
* 조인 테이블 설정하자.
* 지연 로딩 사용
* equals와 hashCode 오버라이딩하고 toString()은 주의해서 정의

## 항목 5. @ManyToMany에서 Set이 List보다 나은 이유

List 쿼리가 여러번 나간다. Set이 더 효율적. 

## 항목 6. CascadeType.REMOVE 및 orphanRemoval=true를 사용해 하위 엔티티 제거를 피해야하는 이유와 시기

애플리케이션이 삭제를 하는 경우 CascadeType.REMOVE나 orphanRemoval=true를 함께 사용할 수 있다.
이 방법은 유용하며, 부모와 자식을 위한 낙관적 잠금 메커니즘의 이점을 누릴 수 있다.

대신 쿼리가 많이 나가 성능 문제가 있을 수 있는데 이는 벌크 처리를 통해 DELETE 문의 수를 최적화 가능하다.
벌크 처리의 단점은 아래와 같다.

* 자동화된 낙관적 잠금 메커니즘을 무시한다.
* 영속성 컨텍스트는 벌크 작업에 의해 수행된 수정 사항을 반영하고자 동기화되지 않기 때문에 유효하지 않은 컨텍스트를 가질 수 있다.
* 전이 삭제 또는 orphanRemoval을 활용할 수 없다.

와 같은 단점이 문제가 된다면 벌크 작업을 피하거나 직접 해당 문제를 처리하는 2가지 선택사항이 있다.
가장 어려운 부분은 영속성 컨텍스트에 로드되지 않은 자식에 대한 자동 낙관적 잠금 메커니즘 작업을 에뮬레이션하는 것이다.

예제에서는 자동 낙관적 잠금 메커니즘이 비활성화됐다고 가정하지만 flushAutomatically = true 또는 clearAutomatically = true를 통해 영속성 컨텍스트 동기화 문제를 관리할 수 있다.
그러나 이 2가지 설정이 항상 필요한 것은 아니다. 사용 방법은 달성해야 할 목적에 따라 다르다.