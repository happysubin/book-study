# chapter 2장. 엔티티

## 항목 13. 엔티티의 플루언트 API 스타일 적용 방법

이펙티브 자바의 빌더 패턴과 동일. 

## 항목 14. 하이버네이트 프록시를 통한 자식 측에서 부모 연관관계 채우기

스프링 내장 메서드인 findById() 또는 getOne()을 통해 식별자로 엔티티를 가져올 수 있다.
findById() 메서드는 스프링 내부적으로 EntityManger#find()를 사용하고 getOne()은 EntityManger#getReference()를 사용한다.

findById()는 영속성 콘텍스트, 2차 캐시 또는 데이터베이스로부터 엔티티를 반환하는데, 반환된 엔티티는 선언된 엔티티 매핑과 동일한 타입이다.

이와는 달리 getOne() 호출은 하이버네이트 프록시 객체를 반환하는데, 실제 엔티티 타입과 다르다.
이 하이버네이트 프록시는 자식 엔티티가 부모에 대한 참조와 함께 등록될 때 유용하다.
이런 상황에서 데이터베이스로부터 부모 엔티티를 가져오는 것은 성능 저하를 가지며 하이버네이트가 초기화되지 않은 프록시에 대한 외래키 값을 설정할 수 있기 때문에 무의미한 작업일 뿐이다.

@ManyToOne으로 이를 확인.


## 항목 15. 영속성 레이어에서 자바 8 Optional 사용 방법

이번에는 영속성 레이어에서 자바 8 Optional API 사용을 위한 모범
사례를 알아보는 것이다.

### 엔티티에서의 Optional

엔티티의 옵셔널은 특정 게터에서 사용한다. 현재는 코틀린을 사용하고 있으므로 걱정 없지만 예시 코드만 살펴본다.

리포지토리에서는 늘 하던 방식으로 Optional로 감싸서 꺼내면 된다.

## 항목 16. 불변 엔티티 작성 방법

불변 엔티티는 다음 계약 사항을 준수해야 한다.

1. @Immutable 애노테이션이 지정돼야 한다.
2. 어떤 종류의 연관관계도 포함하지 않아야 한다.
3. hibernate.cache.use_reference_entries 설정이 true로 지정돼야 한다.

> 불변 엔티티는 분해된 상태가 아닌 엔티티 참조로 2차 캐시에 저장된다.
> 이렇게 되면 분해된 상태에서 엔티티를 재구성하는 성능 저하를 방지할 수 있다. (새 엔티티 인스턴스를 만들고 분해된 상태로 채운다.)

## 항목 17. 엔티티 복제 방법

엔티티의 복제는 일상적인 작업은 아니지만 때론 처음부터 엔티티를 만들지 않아도 되는 가장 쉬운 방법이다.
수동 복제, clone()을 통한 복제, 복사 생성자를 통한 복제, Cloning 라이브러리 사용, 직렬화를 통한 복제, JSON을 통한 복제 등과 같은 잘 알려진 많은 복제 기술이 있다.

엔티티의 경우 깊은 복제를 사용할 필요가 거의 없지만 Cloning 라이브러리가 많이 도움이 된다.
다른 대부분의 경우 속성의 일부만 복사하면 되는데, 이 경우 복사 생성자가 복제되는 항목에 대한 전체 제어를 제공할 수 있다.

## 항목 18. 더티 트래킹을 활성화하는 이유와 방법

> 더티 체킹은 현재 연속성 컨텍스트에 로드된 이후 수정된 관리 중인 엔티티를 플러시 시점에 감지하는 하이버네이트 메커니즘이다.
> 그런 다음 애플리케이션을 대신해 적절한 SQL 업데이트문을 실행한다.
> 하이버네이트는 관리 엔티티의 속성이 하나만 변경된 경우에도 모든 관리 엔티티를 스캔한다.!!!!

위와 같은 더티 체킹 메커니즘은 성능 저하가 발생할 수 있다.

하이버네이트 5부터의 더티 체킹 메커니즘은 속성의 변경 사항을 추적하는 엔티티의 기능인 더티 트래킹 메커니즘에 의존한다.
이 더티 트래킹 메커니즘은 더 나은 성능을 제공하는데, 이런 이점은 특히 엔티티 수가 상당히 많을 때 눈에 띄인다.
이 메커니즘이 작동하려면 하이버네이트 Bytecode Enhancement 프로세스가 애플리케이션에 추가돼야 하며, 개발자는 특정 플래그 설정을 통해 더티 트래킹 메커니즘을 활성화해야 한다.

관련 링크는 다음과 같다.

1. 설명
https://docs.jboss.org/hibernate/orm/5.4/topical/html_single/bytecode/BytecodeEnhancement.html
2. 도입 방식
https://stackoverflow.com/questions/62121172/how-to-enable-hibernate-bytecode-enhancement-in-gradle

위 글에서 더 살펴보면 하이버네이트에서는 enableLazyInitialization과 enabledDirtyTracking 설정이 버전 6.2에서 기본적으로 활성화되었다.

![스크린샷 2024-05-07 오후 9 26 08](https://github.com/happysubin/book-study/assets/76802855/46299d43-4a0e-418f-9bef-484c60cfcb5d)

빌드시킨 코드를 디컴파일하면 확인할 수 있다.

하이버네이트 Bytecode Enhancement는 다음과 같은 3가지 주요 메커니즘을 제공한다.

* 더티 트래킹
* 속성 지연 초기화
* 연관 관계 관리

## 항목 19. 불리언을 Yes/No로 매핑하는 방법

본인도 자주 사용하는 AttributeConverter를 활용함. 애플리케이션에서는 boolean 활용, 데이터베이스에는 String을 varchar로 저장.

참고로 @Enumerated 애노테이션이 달린 속성은 AttributeConverter를 적용할 수 없다.
